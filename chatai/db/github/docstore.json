[[["5040da0e-0a63-4916-a188-4c95dc435e54",{"pageContent":"---\ntitle: CSS 基础\ndate: '2024-03-15'\ntags: ['CSS']\ndraft: false\nsummary: CSS 基础知识及面试常考内容整理\n---\n\n## BFC\n\n块级格式上下文，可以看做元素的属性，当元素有了BFC这个属性，这个元素可以看做**隔离了的容器**，容器里面的元素**不会在布局上影响到外面的元素**。\n\n### BFC特性\n\n1. 每一个BFC区域只包含其子元素，不包含其子元素的子元素\n2. 每一个BFC区域相互独立，互不影响\n\n### 如何触发BFC\n\n给元素添加BFC属性，需满足下列任一条件","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":1,"to":20}}}}],["4be754a4-89e2-4ca1-9524-16f3289294ec",{"pageContent":"1. 每一个BFC区域只包含其子元素，不包含其子元素的子元素\n2. 每一个BFC区域相互独立，互不影响\n\n### 如何触发BFC\n\n给元素添加BFC属性，需满足下列任一条件\n\n- 根元素( html )\n- 设置float浮动，不包含none\n- 绝对定位元素 (元素的 position 为 absolute 或 fixed)\n- display 为 inline-block、table-cell、table-caption、table、table-row、table-row-groutable-header-group、table-footer-group、inline-table、flow-root、flex 或 inline-flex、grid 或 inline-grid\n- 设置 overflow，不为 visible\n- contain 值为 layout、content 或 paint 的元素\n- 多列容器（column-count 或 column-width (en-US) 值不为 auto，包括 column-count 为 1）\n  \n### BFC的作用","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":15,"to":30}}}}],["35e2d5af-6ee2-4db4-9310-9aa13cdb6c13",{"pageContent":"- **避免外边距重叠**\n\n案例\n```html\n<style>\n  .box{\n    width: 200px;\n    height: 200px;\n    background: #5aa878;\n    margin: 100px;\n  }\n</style>\n<body>\n  <div class=\"box\"></div>\n  <div class=\"box\"></div>\n</body>\n```\n可以看到，块的上外边距 margin-top 和下外边距 margin-bottom 会合并为单个边距，如果两个边距相等取其中一个，若大小边距不一样区最大边距。\n\n解决方案\n```html\n<style>\n  .box{\n    width: 200px;\n    height: 200px;\n    background: #5aa878;\n    margin: 100px;\n  }\n  .container{\n    overflow: hidden;\n  }\n</style>","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":32,"to":63}}}}],["360d0bf5-2d16-4ef5-8425-4a485dbe218e",{"pageContent":"<div class='container'>\n  <div class=\"box\"></div>\n</div>\n<div class=\"container\">\n  <div class=\"box\"></div>\n</div>\n```\n给这两个box给各自一个div包裹，然后给这个div添加 overflow: hidden; 属性触发 container 的 BFC，最后就可以看到理想的结果 200px。\n\n- **清除浮动**\n\n案例\n```html\n<style>\n  .container{\n    border: 2px solid yellowgreen;\n  }\n  .content{\n    width: 100px;\n    height: 100px;\n    background: #47cabf;\n    margin: 100px;\n    float: left;\n  }\n</style>","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":65,"to":89}}}}],["1de17dee-7d7f-4057-9e15-dc700e415680",{"pageContent":"<div class=\"container\">\n  <div class=\"content\"></div>\n</div>\n```\n期望效果：边框包裹着一个100px的方块。\n实际效果：子元素添加了浮动导致子元素脱离了文档流，所以父元素只剩下2px的边框了\n解决方案：给父级元素增加 overflow: hidden; 除发BFC，即清除了浮动。\n\n- **防止元素被浮动元素覆盖**\n\n案例\n```html\n<style>\n  .box1{\n    width: 100px;\n    height: 100px;\n    background: blue;\n    float: left;\n  }\n  .box2{\n    width: 200px;\n    height: 200px;\n    background: red;\n  }\n</style>","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":91,"to":115}}}}],["c58263f9-bd18-48b9-b169-b3d2b79248d7",{"pageContent":"<div class=\"box1\"></div>\n<div class=\"box2\"></div>\n```\n期待效果：两个盒子并排存在。\n实际效果：两盒盒子会重叠。\n解决方案：给 box2 添加 overflow: hidden; 触发 BFC。\n\n- **防止父子元素外边距塌陷**\n\n案例\n```html\n<style>\n  .box1{\n    width: 200px;\n    height: 200px;\n    background: blue;\n  }\n  .box2{\n    width: 100px;\n    height: 100px;\n    background: red;\n    margin-top: 20px;\n  }\n</style>\n\n<div class=\"box1\">\n  <div class=\"box2\"></div>\n</div>\n```\n期望效果：子节点据父节点 20px\n实际效果：两个块元素完全重叠\n解决方案：给父元素添加 BFC 属性\n\n## 选择器\ncss 选择器包括","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":117,"to":151}}}}],["befb9a3d-ee0d-4953-9be3-8be7b0c76690",{"pageContent":"## 选择器\ncss 选择器包括\n\n- 元素选择器 通过元素的标签名选中元素，如p、h1、div等\n- 类选择器 通过元素的class属性值选中元素，以.开头，如.classname\n- ID选择器 通过元素的id属性值选中元素，以#开头，如#idname\n- 属性选择器 通过元素的属性值选中元素，如[attr]、[attr=value]、[attr^=value]等\n- 伪类选择器 通过元素的状态或位置选中元素，如:hover、:active、:first-child等\n- 伪元素选择器 通过元素的特定位置选中元素的某个部分，如::before、::after等\n- 后代选择器 通过元素的嵌套关系选中元素，如ancestor descendant\n- 子元素选择器 选择直接子元素，如parent > child\n- 兄弟元素选择器 选择紧邻的兄弟元素 prev + next\n- 通配符选择器 * 选择所有元素\n\n选择器优先级","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":150,"to":164}}}}],["5d99fa1d-9512-4a37-a6b7-3e653fe96471",{"pageContent":"选择器优先级\n\n1. !important 具有最高优先级的样式，会覆盖其他所有样式。\n2. 内联样式 直接在HTML元素中通过style属性设置的样式。\n3. ID选择器 使用#选择器选中的元素。\n4. 类选择器、属性选择器、伪类选择器 使用.、[]、:选择器选中的元素。\n5. 元素选择器、伪元素选择器 使用元素名、::选择器选中的元素。\n6. 后代选择器、子元素选择器、兄弟元素选择器 通过元素的嵌套关系或位置选中的元素。\n7. 通用选择器 选中页面中的所有元素。\n\n## 盒模型\n\n盒模型（Box Modle）可以用来对元素进行布局，由内到外包含实际内容、内边距、边框、和外边距四个部分。\n\n**盒模型的属性**\n\n- width 内容的宽度\n- height 内容的高度\n- padding 内边距\n- border 边框。\n- margin 外边距。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":164,"to":184}}}}],["feb1758e-d0bc-4a4a-bcb8-d2ea7cf97b1f",{"pageContent":"**盒模型的属性**\n\n- width 内容的宽度\n- height 内容的高度\n- padding 内边距\n- border 边框。\n- margin 外边距。\n\n![](https://cdn.nlark.com/yuque/0/2024/png/253721/1712023175750-7130aa71-4eed-4c12-8f61-5f179878772f.png#averageHue=%23dee5bc&clientId=u0462f017-437c-4&from=paste&id=u09daa2c5&originHeight=728&originWidth=1024&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=ue13ce33a-9be5-4f09-823e-ee21163fea6&title=)\n\n**盒模型的分类**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":178,"to":188}}}}],["d066eddc-ad61-4a0f-8433-c46a99163495",{"pageContent":"**盒模型的分类**\n\n- W3C盒模型(标准盒模型) width 和 height 指的是内容区域的宽度和高度\n- IE盒模型(怪异盒模型) width 和 height 包括内容区域、边框、padding内边距\n  \n## Flex布局\n\n**Flexbox Layout**, 官方名为 CSS Flexible Box Layout Module， 意为”弹性布局”，是 CSS3 中引入的一种更加灵活高效的布局/对齐/排序方式。 任何一个容器都可以指定为 Flex 布局\n\n使用时将容器设置为弹性盒子布局。\n```css\ndisplay: flex; // 弹性盒子布局\n```\n\n### Flex 容器属性","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":188,"to":202}}}}],["3c45f4ad-8048-4d8a-8f31-a942732da764",{"pageContent":"### Flex 容器属性\n\n| 属性值 | 含义 |\n| --- | --- |\n| flex-direction | 决定主轴的方向(row、row-reverse、column、column-reverse) |\n| flex-wrap | 决定如果一条轴线排不下，如何换行(nowrap、wrap、wrap-reverse) |\n| flex-flow | flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap |\n| justify-content | 定义主轴上的对齐方式(flex-start、flex-end、center、space-between、space-around) |\n| align-items | 定义了项目在交叉轴(Y轴)上的对齐方式(flex-start、flex-end、center、baseline、stretch) |\n| align-content | 设置多根轴线的对齐方式，也就是行间距。如果项目只有一行，该属性不起作用 |\n\n### Flex 项目属性","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":202,"to":213}}}}],["b35eb30e-f5b3-4ac0-b78f-f54bd4cb8b19",{"pageContent":"| 属性值 | 含义 |\n| --- | --- |\n| order | 定义项目的排列顺序。数值越小，排列越靠前，默认为 0, 可以为负数 |\n| flex-grow | 定义项目的放大比例，默认是 0，如果容器有剩余空间，也不放大。如果所有项目均有设置 flex-grow 值，它们会按照比例填充全部空间 |\n| flex-shrink | 定义项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。\n当容器内所有项目宽度之和，大于了容器的宽度，里面的项目就会被压缩。当项目 flex-shrink 属性为 0，则项目不会被压缩 |\n| flex-basis | 定义项目占据主轴空间的大小，默认值为 auto，就是项目本身的大小。\n可以设为 跟 width 或者 height 一样的值，就是项目占据的固定空间 |\n| flex | flex-grow、flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto |","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":215,"to":223}}}}],["3a824b58-01bd-412b-a239-7614c59f6616",{"pageContent":"| flex | flex-grow、flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto |\n| align-self | 允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch |","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":223,"to":224}}}}],["f3da158c-cdc3-4546-be33-0bf057fe59c4",{"pageContent":"## Animation 动画\n\nAnimation 是 CSS3 中具有颠覆性的特征之ー，可以通过设置多个节点来精确控制一个或一组动画。常用来实现复杂的动画效果。Animation 属性由其子元素合并而成。\n\n### 定义动画\n```css\n@keyframes move {\n  from {\n    transform: translateX(0px);\n  }\n\n  to {\n    transform: translateX(1200px);\n  }\n}\n```\n\n### 使用动画\n```css\ndiv {\n  width: 100px;\n  height: 100px;\n  background-color: red;\n  /* 调用动画 */\n  animation-name: move;\n  /* 持续时间 */\n  animation-duration: 5s;\n}\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":226,"to":254}}}}],["f6036deb-9731-4d09-988c-c48599774e0e",{"pageContent":"### 常用属性\n| 属性 | 描述 |\n| --- | --- |\n| @keyframes | 定义动画 |\n| animation | 所有动画属性的简写，除了 animation-play-state属性 |\n| animation-name | 指定需要使用的动画（ 必须的 ） |\n| animation-duration | 规定动画完成一个周期所花费的秒或毫秒( 必须的 ) |\n| animation-timing-function | 规定动画的速度曲线，默认是”ease” |\n| aniamtion-delay | 规定动画何时开始，默认是0 |\n| animation-iteration-count | 规定动画被播放的次数，默认是1，还有 infinite(无限次) |\n| animation-direction | 规定动画是否在下一周期逆向播放，默认是” normal”，alternate逆播放 |\n| animation-play-state | 规定动画是否正在运行或暂停。默认是” running” ，还有 paused 暂停 |","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":256,"to":267}}}}],["f78e3b44-eb7e-4197-b8d0-a5d2198a04c8",{"pageContent":"| animation-play-state | 规定动画是否正在运行或暂停。默认是” running” ，还有 paused 暂停 |\n| animation-fill-mode | 规定动画结束后状态，保持 forwards 回到起始 backwards |","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":267,"to":268}}}}],["0fd7cb39-36dc-4f98-8387-08090356d090",{"pageContent":"### 属性解析\n\n**aniamtion-direction**\n\n动画是否逆向播放，可选值如下：\n\n- normal 默认的\n- reverse 从终点运动向起点 终点=>起点\n- alternate 到达终点后是否原路返回( 起点=>终点=>起点 ) 当 animation-iteration-count < 2 时无效\n- alternate-reverse 终点=>起点=>终点 animation-iteration-count < 2 时无效\n\n**animation-fill-mode**\n\n动画结束后状态，可选值如下：\n\n- forwards 保持当前位置\n- backwards 回到初始位置\n\n**animation-timing-function**\n\n规定动画的速度曲线，默认是 ease，可选值如下：","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":270,"to":290}}}}],["9f4a3313-c75c-4310-a99c-dc602b70dc0b",{"pageContent":"- forwards 保持当前位置\n- backwards 回到初始位置\n\n**animation-timing-function**\n\n规定动画的速度曲线，默认是 ease，可选值如下：\n\n- linear 动画从头到尾的速度是相同的。匀速\n- ease 默认。动画以低速开始，然后加快，在结束前变慢\n- ease-in 动画以低速开始\n- ease-out 动画以低速结束\n- ease-in-out 动画以低速开始和结束\n- steps 指定了时间函数中的间隔数量（步长），即动画从头到尾，需要多少步完成\n\n示例\n```css\ndiv {\n  width: 0;\n  height: 30px;\n  background-color: red;\n  /* animation: move 5s linear  forwards; */\n  /* steps 指定分几步完成动画，有了 steps 就不需要 ease linear */\n  animation: move 5s steps(10) forwards;\n}","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":285,"to":308}}}}],["aa05edc5-c8fa-4a65-992e-8337463af661",{"pageContent":"@keyframes move {\n  0% {}\n  100% {\n    width: 800px;\n  }\n}\n```\n\n打字机效果\n```html\n<style>\n  div {\n    font-size: 40px;\n    font-family: monospace;\n    width: 0px;\n    white-space: nowrap;\n    animation: move 5s steps(9) forwards;\n    overflow: hidden;\n  }\n\n  @keyframes move {\n    0% {}\n    100% {\n      width: 360px;\n    }\n  }\n</style>\n\n<div>动画实现打字机效果</div>\n```\n\n**animation**\n\n动画简写属性（动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 动画起始或者结束的状态）\n\n```css\nanimation: move 1s ease 2s 3 alertnate fowwards;\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":310,"to":347}}}}],["86d56b22-f6e1-4afa-b5ba-f54dadbb85a5",{"pageContent":"```css\nanimation: move 1s ease 2s 3 alertnate fowwards;\n```\n\n### animation 动画的事件监听\n```javascript\ndom.addEventListener(\"animationstart\", (e) => {\n  // 动画开始时触发\n});\n\ndom.addEventListener(\"animationend\", (e) => {\n  // 动画结束时触发\n});\n\ndom.addEventListener(\"animationiteration\", (e) => {\n  // 动画重复播放时触发\n});\n```\n\n## transition 过渡\n\ntransition 将元素从一种样式在指定时间内平滑的过渡到另一种样式。\n\n相关属性\n### transition-property\n\n用来设置元素中参与过渡的属性名称。可取值如下","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":345,"to":371}}}}],["d8d64f27-838a-4078-823f-1bae3a68213b",{"pageContent":"transition 将元素从一种样式在指定时间内平滑的过渡到另一种样式。\n\n相关属性\n### transition-property\n\n用来设置元素中参与过渡的属性名称。可取值如下\n\n- none：表示没有属性参与过渡效果；\n- all：表示所有属性都参与过渡效果；\n- property：定义应用过渡效果的 CSS 属性名称列表，多个属性名称之间使用逗号,进行分隔\n  \n### transition-duration\n\n设置元素过渡的持续时间，单位为秒或毫秒，默认为0。\n\n### transition-timing-function\n\n设置元素过渡的动画类型，可选值如下：","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":366,"to":383}}}}],["77704ddb-80be-4a37-be86-e3dddacc64fa",{"pageContent":"设置元素过渡的持续时间，单位为秒或毫秒，默认为0。\n\n### transition-timing-function\n\n设置元素过渡的动画类型，可选值如下：\n\n| 属性值 | **描述** |\n| --- | --- |\n| linear | 以始终相同的速度完成整个过渡过程，等同于 cubic-bezier(0,0,1,1) |\n| ease | 以慢速开始，然后变快，然后慢速结束的顺序来完成过渡过程，等同于 cubic-bezier(0.25,0.1,0.25,1) |\n| ease-in | 以慢速开始过渡的过程，等同于 cubic-bezier(0.42,0,1,1) |\n| ease-out | 以慢速结束过渡的过程，等同于 cubic-bezier(0,0,0.58,1) |\n| ease-in-out | 以慢速开始，并以慢速结束的过渡效果，等同于 cubic-bezier(0.42,0,0.58,1) |\n| cubic-bezier(n, n, n, n) | 使用 cubic-bezier() 函数来定义自己的值，每个参数的取值范围在 0 到 1 之间 |","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":379,"to":392}}}}],["edcd9abc-a1cc-4126-8cd0-e822766b1e67",{"pageContent":"### transition-delay\n\n设置过渡效果延迟的时间，单位为秒或毫秒，默认为 0。\n\n### transition\n\n简写属性，用于同时设置上面的四个过渡属性。\n\n实例\n```css\ndiv {\n  width: 100px;\n  height: 100px;\n  border: 3px solid black;\n  margin: 10px 0px 0px 10px;\n  transition: width .25s linear 1.9s, background 1s 2s, transform 2s;\n}\ndiv:hover {\n  width: 200px;\n  background-color: blue;\n  transform: rotate(180deg);\n}\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":394,"to":416}}}}],["b1457ed4-e8a1-49b1-a6f7-da5cfc000e5b",{"pageContent":"写法等价于\n```css\ntransition-property: width, background, transform;\ntransition-duration: .25s, 1s, 2s;\ntransition-timing-function: linear, ease, ease;\ntransition-delay: 1.9s, 2s, 0s;\n```\n\n### 事件监听\n\ntransition 只支持 **transitoinend** 事件\n\n## Transform 变换\n\ntransform 是元素转换属性，其属性值为转换函数，使用该属性可以让元素向指定方向移动、缩放大小、旋转等变化。\n\n常用转换函数\n\n- rotate 旋转函数\n- translate 移动函数\n- scale 缩放函数","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":418,"to":438}}}}],["158307e2-7089-4915-8eae-4cb451ffabca",{"pageContent":"常用转换函数\n\n- rotate 旋转函数\n- translate 移动函数\n- scale 缩放函数\n\n语法如下\n```css\ntransform: translate(x, y);  // 移动到 x, y。或者可以分开写\ntransform: translate3d(x, y, z); // 3d 转换\ntransform: translateX(n);    // 沿 x 轴方向，参数为正沿 x 轴正向，为负沿 x 轴负向\ntransform: translateY(n);    // 沿 y 轴方向，参数为正沿 y 轴正向，为负沿 y 轴负向\ntransform: translateZ(n);    // 沿 z 轴方向，参数为正沿 z 轴正向，为负沿 z 轴负向\n```\nrotate、scale 与 translate 用法基本一致。\n\n**transform-origin**\n\n**transform-origin**(x, y) 用于指定转换的中心点，相对于容器的左上角，可设置 px,%,top,center,bottom\n\n## Position 定位","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":434,"to":454}}}}],["9428ac30-e3f4-458e-8f3f-9bc76c98a5c7",{"pageContent":"**transform-origin**(x, y) 用于指定转换的中心点，相对于容器的左上角，可设置 px,%,top,center,bottom\n\n## Position 定位\n\nposition 即定位。可以让盒子 **自由的** 在某个盒子内移动位置或固定在屏幕中某个位置，并且可以压住其他盒子，有**层叠**的概念，即可以让多个盒子前后叠压来显示。\n\n### 定位组成\n\n定位 由 **定位模式** 和 **边偏移** 组成。\n\n- 定位模式  用于指定一个元素在文档中的定位方式\n- 边偏移 决定了该元素的最终位置\n  \n### 定位模式\n\nposition 属性可选值如下\n\n**1、relative**\n\n**相对定位** 是元素在移动位置的时候，是相对于它自己**原来的位置**来说的。\n有以下两个特点\n\n- 它是相对于自己原来的位置来移动的（移动位置的时候参照点是自己原来的位置）。\n- **原来**在标准流的**位置**继续占有，后面的盒子仍然以标准流的方式对待它。\n\n**2、absolute** (**脱离文档流**)","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":452,"to":477}}}}],["d21092f9-9d6a-4df5-8327-9df6abe69ba7",{"pageContent":"**2、absolute** (**脱离文档流**)\n\n**绝对定位**是元素在移动位置的时候，相对于最近的非 static 定位的父级元素定位的。\n\n特点如下\n\n- 脱离文档流，完全不占位置\n- 父元素没有定位，则以**浏览器**为准进行定位（Document 文档）\n- 祖先元素有定位（相对、绝对、固定定位），则以**最近一级**的有定位祖先元素为参考点移动位置\n\n**子节点是绝对定位的话，父节点要用相对定位**\n\n**3、static**\n\n静态定位,元素的**默认**定位方式，**无定位的意思**。\n\n**4、fixed**(**脱离文档流**)\n\n**固定定位**是元素**固定于浏览器可视区的位置**。\n\n特点\n\n- 以**浏览器的可视窗口**为参照点移动元素\n- 不再占有原先的位置\n- **当父级元素有 transform 属性时，会将该元素当做参照物**\n\n**5、sticky**\n\n粘性定位，相对于最近的可滚动祖先进行定位。\n\n### 边偏移\n\n边偏移的属性如下","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":477,"to":509}}}}],["a30adce9-2b3c-4508-b3f9-c7847cc6a371",{"pageContent":"**5、sticky**\n\n粘性定位，相对于最近的可滚动祖先进行定位。\n\n### 边偏移\n\n边偏移的属性如下\n\n- top **顶端**偏移量，定义元素相对于其父元素**上边线的距离**\n- bottom **底部**偏移量，定义元素相对于其父元素**下边线的距离**\n- left **左侧**偏移量，定义元素相对于其父元素**左边线的距离**\n- right **右侧**偏移量，定义元素相对于其父元素**右边线的距离**\n  \n## Z-index\n\nz-index 属性用来设置元素的堆叠顺序(元素层级)，值越大，元素的层级越高。当元素发生重叠时，层级高的元素会覆盖在层级低的元素的上面，使层级低的元素重叠部分被遮盖住。\n\n### 取值范围","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":503,"to":520}}}}],["0b28ab4d-99a2-421f-a268-026c20f872fa",{"pageContent":"z-index 属性用来设置元素的堆叠顺序(元素层级)，值越大，元素的层级越高。当元素发生重叠时，层级高的元素会覆盖在层级低的元素的上面，使层级低的元素重叠部分被遮盖住。\n\n### 取值范围\n\n- auto 默认值，如果各级祖先元素均未设置该属性，则相当于0\n- number 整数数值，取值范围是 -2147483584 ~ 2147483584，数值越大，层级越高\n- inherit 继承父元素的z-index的属性值\n  \n### 适用范围\n只能在设置了 **position: relative | absolute | fixed** 的元素或者父元素设置了 **display: flex** 属性的子元素中起作用，在其他元素中不起作用。\n\n设置了定位且 z-index 属性值相同的同级元素，层级由元素的书写顺序决定，后面元素覆盖前面。\n\n## box-shadow\nbox-shadow 属性用来向边框添加阴影。\n\n用法\n\n```css\nbox-shadow: h-shadow v-shadow blur spread color inset;\n```\n\n相关属性值含义","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":518,"to":540}}}}],["f84f079c-02a7-4924-86ff-8e9099287dac",{"pageContent":"用法\n\n```css\nbox-shadow: h-shadow v-shadow blur spread color inset;\n```\n\n相关属性值含义\n\n- h-shadow 阴影在 x 轴的位置，允许负值\n- v-shadow 阴影在 y 轴的位置，允许负值\n- blur 阴影的模糊半径，不允许为负值\n- spread 阴影的尺寸，允许负值\n- color 阴影的颜色\n- inset 将外部阴影 (outset) 改为内部阴影\n\n示例\n```css\nbox-shadow: 0px 0px 20px 20px rgba(0,0,0,0.5);\n```\n\n## 媒体查询\n\n允许开发者根据设备的特定条件（如视口宽度、屏幕分辨率、设备方向等）来应用不同的样式规则。使得网页设计能够响应不同的设备和视口大小，实现响应式布局。\n\n### 媒体类型\n\n媒体类型描述设备的一般类别。一般常用 screen ，描述电脑、手机和平板屏幕。\n\n- all 适用于所有的设备\n- print 适用于打印模式\n- screen 主要用于屏幕\n- speech 主要用于语音合成器\n  \n### 媒体特性","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":534,"to":567}}}}],["d111cd66-975f-40e3-90dc-6abe37533838",{"pageContent":"- all 适用于所有的设备\n- print 适用于打印模式\n- screen 主要用于屏幕\n- speech 主要用于语音合成器\n  \n### 媒体特性\n\n媒体特性描述了 user-agent 输出设备或是浏览器环境的具体特征。\n\n- width viewport 的宽度\n- height viewport 的高度\n- aspect-ratio viewport 的宽高比\n- orientation viewport 的旋转方向\n\n用法如下\n```css\n@media (min-width: 700px) {  } // ...\n@media (max-width: 700px) {  } // ...\n\n/**\n* 旋转方向 \n*/\n@media (orientation: portrait) {  } // ... 竖屏\n@media (orientation: landscape) {  } // ... 横屏\n```\n\n### 逻辑操作符","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":562,"to":588}}}}],["3fa3ba7a-cfab-475d-8f2f-733e3b51f4a1",{"pageContent":"### 逻辑操作符\n\n逻辑操作符 not and 和 only 可用于联合构造复杂的媒体查询。\n```css\n@media screen and (min-width: 680px) and (max-width: 1200px) {  }  \n@media screen, print and (min-width: 700px) {  } // ... 逗号表示或操作\n```\n\n### link标签方式\n```html\n/* 区分横屏竖屏 */\n<link rel=\"stylesheet\" href=\"./a.css\" media=\"(orientation:portrait)\">\n<link rel=\"stylesheet\" href=\"./b.css\" media=\"(orientation:landscape)\">\n```\n\n## CSS 高频效果实现\n\n### 垂直居中\n```html\n<div class=\"centerCtx\">\n  实现文字垂直水平居中\n</div>\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":588,"to":610}}}}],["454e4907-7d9d-4e49-b1d8-14467e1221a6",{"pageContent":"## CSS 高频效果实现\n\n### 垂直居中\n```html\n<div class=\"centerCtx\">\n  实现文字垂直水平居中\n</div>\n```\n\n**1、使用flex**\n```css\ndisplay: flex;\njustify-content: center;\nalign-items: center;\n```\n\n**2、grid 布局**\n```css\ndisplay: grid; /* 设置为grid布局 */\nplace-items: center; /* 同时进行水平和垂直居中对齐 */\n```\n\n**3、absolute定位中top、left、bottom、right为0，margin: auto**\n```html\n<div class=\"parent\">\n  <div class=\"child\">实现文字垂直水平居中</div>\n</div>\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":603,"to":630}}}}],["3944a5ce-edb8-43ba-b909-cc33dfa2b398",{"pageContent":"```css\n.parent {\n  height: 400px; /* 设置高度，确保能看到效果 */\n  width: 600px;\n  border: 1px solid #ccc;\n  position: relative;\n}\n\n.child {\n  width: 146px;\n  height: 24px;\n  position:absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  margin: auto;\n}\n```\n\n**4、使用 margin 和 translate**\n```css\n.child {\n  width: 146px;\n  height: 24px;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  /* 等价于 */\n  /* margin-top: -12px; */\n  /* margin-left: -73px; */\n}\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":632,"to":665}}}}],["3890de09-88bd-4b27-976b-d952820dc7d5",{"pageContent":"**5、table-cell 布局**\n```css\n.parent {\n  height: 400px; /* 设置高度，确保能看到效果 */\n  width: 600px;\n  border: 1px solid #ccc;\n  display: table-cell;\n  vertical-align: middle;\n  text-align: center;\n}\n.child {\n  width: 146px;\n  height: 24px;\n  display: inline-block;\n}\n```\n\n### 文本超出省略\n\n**1、单行文本**\n```css\noverflow: hidden;            // 溢出隐藏\ntext-overflow: ellipsis;     // 溢出用省略号显示\nwhite-space: nowrap;         // 规定段落中的文本不进行换行\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":667,"to":691}}}}],["3756f441-510e-4284-bd15-bf04c69aca76",{"pageContent":"**2、多行文本**\n```css\noverflow: hidden;               // 溢出隐藏\ntext-overflow: ellipsis;        // 溢出用省略号显示\ndisplay: -webkit-box;           // 作为弹性伸缩盒子模型显示\n-webkit-box-orient: vertical;   // 设置伸缩盒子的子元素排列方式：从上到下垂直排列\n-webkit-line-clamp: 3;          // 显示的行数\n```\n\n### 实现0.5px的线\n\n**1、使用 scale 缩放实现**\n```css\nwidth: 300px;\nheight: 1px;\nbackground-color: red;\ntransform: scaleY(0.5);\n```\n\n**2、使用 box-shadow**\n```css\nwidth: 300px;\nheight: 1px;\nbox-shadow: 0 0.5px 0 0 rgba(0,0,0, 0.5); // 设置纵向偏移量为0.5\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":693,"to":717}}}}],["3011ed0f-03db-437c-b141-b0588d5ed156",{"pageContent":"**3、使用伪类实现**\n```css\n.child {\n  position: relative;\n  border: none; /* 移除默认边框 */\n}\n\n.child::before {\n  content: \"\";\n  display: block;\n  width: 300px; /* 设置为两倍大小的线条宽度 */\n  height: 1px; /* 保持与原始线条相同高度 */\n  background-color: black; /* 设置颜色 */\n  transform: scaleY(0.5); /* 将高度缩放到0.5倍 */\n  position: absolute;\n  top: -0.5px; /* 调整位置使其在原始线条上方显示 */\n}\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":719,"to":736}}}}],["4a4265ec-4b31-4fce-98d8-19df9b59341b",{"pageContent":"**4、移动端可以使用 meta viewport**\n```html\n<meta name=\"viewport\" \n  content=\"width=device-width, \n  initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5\"/>\n```\n### 响应式布局\n\n- 媒体查询 针对不同尺寸屏幕书写不同的样式，需要写多套样式\n- 百分比布局 在设置宽高时通过设置百分比去控制，但很难控制百分比是相对于哪个元素\n- vw、vh 与百分比类似，固定相对于视窗的百分比，强制与视窗绑定，无法设置临界值\n- rem 以根元素的 font-size 为基准设置宽高，根元素 font-size 根据屏幕尺寸动态变化\n- \n### css绘制三角形\n\n**1、使用 border 绘制**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":738,"to":753}}}}],["7854f120-b2a7-430a-89e3-99efb43c5b2f",{"pageContent":"**1、使用 border 绘制**\n\n设置容器宽高为0，设置3边的 border，两边颜色透明，中间的border设置颜色。\n```css\nwidth: 0;\nheight: 0;\nborder-left: 5px solid transparent;\nborder-bottom: 5px solid red;\nborder-right: 5px solid transparent;\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/CSS基础.mdx","loc":{"lines":{"from":753,"to":762}}}}],["fa9171e3-8fa1-4b9d-8930-c6c4bf9cb315",{"pageContent":"---\ntitle: ES6 新特性\ndate: '2024-03-30'\ntags: ['ES6']\ndraft: false\nsummary: ES6 新特性内容整理\n---\n\n### 变量声明\n\nES6推荐使用 let 声明局部变量，相比之前的 var，let 具有块级作用域，可以避免变量提升和污染全局作用域的问题。\n\nconst 则用来声明常量，一旦赋值就不能改变。const 也具有块级作用域，并且必须在声明时就初始化。\n\n**特点**\n\n- 不会进行变量提升，在变量声明之前调用都会报错\n  \n### 解构赋值\n\n解构赋值是一种快速从数组或对象中提取数据并赋值给变量的简洁写法。它可以减少代码量，提高可读性，并且支持默认值、嵌套结构、别名等特性。\n\n示例\n```javascript\n// 数组解构：按照数组元素位置对应赋值给变量\nlet [f, g, h] = [1, 2, 3];\nconsole.log(f); // 1\nconsole.log(g); // 2\nconsole.log(h); // 3","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":1,"to":29}}}}],["354fb307-bcec-4cb1-b379-7760d19d7cb5",{"pageContent":"// 对象解构：按照对象属性名对应赋值给同名变量（也可以使用别名）,可以设置默认值\nlet {name, age = 20} = {name: \"Alice\", age: 18};\nconsole.log(name); // Alice\nconsole.log(age); // 18\n\n// 解构赋值的应用场景：交换变量、函数参数、返回值等\nlet u = 6;\nlet v = 7;\n[u, v] = [v, u]; // 不需要使用临时变量来交换u和v的值\nconsole.log(u); // 7\nconsole.log(v); // 6\n```\n\n**特点**\n\n- **在解构对象时，会去查找原型链上的属性和方法**\n\n**展开运算符**\n\n展开运算符可以将一个数组或对象展开为多个元素或属性，用于函数调用、数组合并、对象复制等场景。\n```javascript\nconst obj = { a: 1, b: 2 };\nconst obj2 = {...obj};\nobj.b = 5;\nconsole.log(obj2);  // {a: 1, b: 2}\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":31,"to":56}}}}],["0fc685a9-ac06-437b-9386-0ac27d640461",{"pageContent":"### 箭头函数\n\n箭头函数是一种使用 => 符号定义函数的简洁写法。它可以省略 function 关键字、参数括号、返回值括号等，使得代码更加简洁和清晰。\n\n示例\n```javascript\nconst getName = () => {\n  return 'Lily';\n}\n```\n特点\n\n- 不改变 this 的指向，即箭头函数内部的 this 始终指向定义时所在的对象\n- 箭头函数可以使用 call 和 apply，但是会忽略第一个参数\n- 箭头函数不能作为构造函数，且没有原型对象\n  \n### 模板字符串\n\n模板字符串是一种使用反引号 “ 包裹字符串，并且支持插入变量或表达式的新语法 。它可以避免使用 + 号连接字符串和变量，并且支持多行字符串和标签模板等特性。\n\n**String.raw** 用于获取原始字符串\n\n示例\n```javascript\nconst str = \"c:\\workspace\\network\"\nconsole.log(str);\n```\n\n会打印出","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":58,"to":86}}}}],["b4844708-157a-45ba-8afa-f1389400c608",{"pageContent":"示例\n```javascript\nconst str = \"c:\\workspace\\network\"\nconsole.log(str);\n```\n\n会打印出\n\n![](https://cdn.nlark.com/yuque/0/2024/png/253721/1712025617882-c3e4737f-e7aa-4c52-a4a5-29eb73c63718.png#averageHue=%23faf9f8&clientId=u29b0bd49-d21c-4&from=paste&id=u516f2f20&originHeight=170&originWidth=518&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u89961a70-3067-4ce1-be84-0fabcfc28d3&title=)","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":80,"to":88}}}}],["7c1e907d-c614-47b5-9aab-dbb915569112",{"pageContent":"浏览器会将 \\ \\n 识别为特殊字符。而使用**String.raw** 之后，就可以正常打印出字符串。\n```javascript\nconst str = String.raw`c:\\workspace\\network`\nconsole.log(str);\n```\n![](https://cdn.nlark.com/yuque/0/2024/png/253721/1712025617917-b5c4b0bc-695f-4cc2-a927-fc66f803386e.png#averageHue=%23f9f8f7&clientId=u29b0bd49-d21c-4&from=paste&id=ub152dd63&originHeight=166&originWidth=558&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u05f52994-031e-4e4c-98a0-6952b7563d5&title=)\n\n### 数组常用操作","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":90,"to":97}}}}],["e0b6f6e8-188b-463a-b0b6-32d36744bbd1",{"pageContent":"- concat 合并数组并返回新数组，不改变原数组\n- entries 返回数组的迭代器（类似于generator的返回）\n- every 检查数组中的每一项是否符合条件\n- some 检查数组中是否存在某一项符合条件\n- flatMap 相当于先调map，再调flat(1)\n- splice 在给定的索引处删除或替换了一些元素，改变原数组\n- Array.from 通过浅拷贝的方式生成数组\n- reverse 反转数组，改变原数组\n- pop 删除并返回最后一个元素，改变原数组\n- push 添加一个元素并返回新数组的长度\n- shift 删除第一个元素并返回该元素，与pop对应\n- unshift 在数组头部添加一个元素并返回新数组的长度，与push对应\n- sort 正数升序、负数降序，会改变原数组\n- toSorted 与 sort 方法一致，它返回一个新数组，不改变原数组\n- with(index, value) 返回一个全新的数组，将 `index` 索引处的元素替换为 `value`\n- toReversed 反转数组，不改变原数组，返回一个新数组","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":99,"to":114}}}}],["230b0d44-5f01-4508-aaef-f02c6105e44d",{"pageContent":"- with(index, value) 返回一个全新的数组，将 `index` 索引处的元素替换为 `value`\n- toReversed 反转数组，不改变原数组，返回一个新数组\n- toSpliced 返回一个新数组，并在给定的索引处删除或替换了一些元素\n  \n### Map和Set\n#### Set","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":113,"to":118}}}}],["e828da98-4578-47de-8e96-92f99cef8a4c",{"pageContent":"Set 是一个数据的列表。它与数组的区别是 Set 里面的数据不允许重复。这里判定重复的方法是绝对相等 ===。 所以 2 和 ‘2’ 可以在同一个 Set 里。\n\n如果存储对象是引用对象，则set会确保内存地址的唯一。所以如果两个变量指向同一个对象。set会只保留一个。\n\n**Set 常用方法及属性**\n\n- add 添加项\n- delete 删除项\n- has 查看是否有某项\n- clear 清空 set\n- size 元素的数量\n\n**注意**\n\n**Set 中 NaN 是同一个值，尽管 js 中 NaN !== NaN，但是一个 Set 中只能有一个 NaN。undefined 和 null也只能有一个**。\n\n示例\n```javascript\nconst set1 = new Set(); // 初始化\nconst set2 = new Set([1, 2, 3, 4]); // 返回类数组对象\n\nset1.add('a');\nset1.add('b');\nset1.has('a'); // true\nset1.delete('a');\n```\n\n#### WeakSet","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":120,"to":147}}}}],["46f91035-42e5-443f-b79e-38c6fa667f13",{"pageContent":"set1.add('a');\nset1.add('b');\nset1.has('a'); // true\nset1.delete('a');\n```\n\n#### WeakSet\n\nWeakSet 与set 主要有两个区别：\n\n- WeakSet 只能存储对象 ，即 内存地址， 存的值如果不是内存地址会报错\n- WeakSet 是弱引用 ，即如果引用类型对象只有在 weakSet 里有调用，则垃圾回收机制运行的时候会回收它\n\n基于这个特点，WeakSet 的参数只能是**对象应用**（即参数只能是变量名）；WeakSet **不能 forEach** 遍历，因为保存的对象随时可能消失。\n\n**WeakSet 也没有 size 属性。**\n\n#### Map\n\nMap是一种类似于对象的集合，但是它可以使用任意类型的值作为键，包括数字，字符串 ，set ，array， Object 等。\n\n常用方法","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":141,"to":162}}}}],["3c4d0219-aee0-49ff-ba77-1c710e824732",{"pageContent":"#### Map\n\nMap是一种类似于对象的集合，但是它可以使用任意类型的值作为键，包括数字，字符串 ，set ，array， Object 等。\n\n常用方法\n\n- set(key, value) 插入键值对\n- get(key) 根据 key 值获取数据\n- has(key) 判断是否存在某个 key 值\n- delete(key) 删除 key 值\n- clear() 清空键值对\n\n示例\n```javascript\nconst map = new Map();\n\nmap.set('key1', 'value1');\nmap.set('key2', 'value2');\nmap.set('key3', 'value3');\n\nconsole.log(map.get('key1')); // 输出: value1\nconsole.log(map.size); // 输出: 3\n\nmap.forEach((value, key) => {\n  console.log(`${key} = ${value}`);\n});\n```\n\n#### WeakMap","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":158,"to":186}}}}],["8d47c5c2-a897-42fe-beb6-165e02ebb165",{"pageContent":"map.forEach((value, key) => {\n  console.log(`${key} = ${value}`);\n});\n```\n\n#### WeakMap\n\nWeakMap 与 Map 类似，都是键值对的数据结构。不同点：\n\n- WeakMap 只接受对象作为键， null 除外。使用普通值会报错\n- WeakMap 的 【键名】指向的对象可以被垃圾回收机制回收\n\n它设计的目的在于，如果需要对对象添加一些文字说明的情况，则可能会导致被描述对象的内存无法被正常回收。\n\n**WeakMap 没有 size 属性，不能使用 forEach 循环。**\n\n#### Set 与 Map 区别","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":181,"to":197}}}}],["87b44d62-9a88-49d7-a0b4-30e04782a515",{"pageContent":"**WeakMap 没有 size 属性，不能使用 forEach 循环。**\n\n#### Set 与 Map 区别\n\n- **数据存储方式** \n  \n  Map是一种键值对的集合，每个键对应一个值；Set是一组唯一值的集合，不允许重复。\n- **键的类型** \n  \n  在Map中，键可以是任意数据类型，包括基本数据类型和对象；在Set中，值本身就是键，因此只能存储基本数据类型和对象。\n- **迭代顺序**\n  \n  Map会按照插入顺序迭代元素，可以通过迭代器访问键值对；Set不保留插入顺序，迭代器只能访问值本身。\n- **大小和性能** \n  \n  Map可以动态增长并且可以使用size属性获取元素个数；Set的大小也可以通过size属性获取。在大型数据集上，Map通常比Set执行更好。\n- **元素查找**\n  \n  在Map中，可以通过键来查找对应的值；在Set中，可以直接判断值是否存在\n\n### 异步\n#### Promise\n\nPromise 是一种用于处理异步操作的对象，它表示一个未来可能完成或失败的事件。\n\nPromise 三种状态：","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":195,"to":220}}}}],["4ced1339-c23a-460a-9d04-3b1abfb90ee8",{"pageContent":"### 异步\n#### Promise\n\nPromise 是一种用于处理异步操作的对象，它表示一个未来可能完成或失败的事件。\n\nPromise 三种状态：\n\n- pending（等待）\n- fulfilled（成功）\n- rejected（失败）\n\n**状态只能从 pending 变成 fullfilled 或者 rejected，一旦变更后无法再修改状态**。\n\nPromise 可以通过 then 方法添加成功或失败时执行的回调函数，也可以通过 catch 方法添加失败时执行的回调函数。\n\n**Promise 静态方法**(接受参数均为任务数组)\n\n- Promise.all 返回一个任务，任务数据全部成功则成功，任意一个失败则失败\n- Promise.any 返回一个任务，任务数组任意一个成功则成功，全部失败则失败\n- Promise.allSettled 返回一个任务，任务数组全部已决则成功，该任务不会失败\n- Promise.race 返回一个任务，任务数组任意一个已决则已决，状态和其一致","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":215,"to":235}}}}],["3467e5cd-c08b-401c-9135-f4b8b59cae4d",{"pageContent":"**手写 Promise 实现**\n```javascript\nclass MyPromise {\n  constructor(executor) {\n    this.status = 'pending';\n    this.value = '';\n    this.reason = '';\n    this.callBackResoles = [];\n    this.callBackRejects = [];\n\n    const resolve = (value) => {\n      if(this.status === 'pending'){\n        this.status = 'resolved';\n        this.value = value;\n        this.callBackResoles.forEach(fn => fn());\n      }\n    };","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":237,"to":253}}}}],["fd187602-ec9d-4753-b5d0-418d4d762d50",{"pageContent":"const reject = (reason) => {\n      if(this.status === 'pending'){\n        this.status = 'rejected';\n        this.reason = reason;\n        this.callBackRejects.forEach(fn => fn());\n      }\n    };\n\n    try {\n      executor(resolve, reject);\n    } catch (error) {\n      reject(error);\n    }\n\n  }","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":255,"to":269}}}}],["d955b044-2dde-4c37-8d38-ff879f282ffa",{"pageContent":"try {\n      executor(resolve, reject);\n    } catch (error) {\n      reject(error);\n    }\n\n  }\n\n  then(onFulfilled, onRejected) {\n    if(this.status === 'resolved') {\n      onFulfilled(this.value);\n    } else if(this.status === 'rejected') {\n      onRejected(this.reason);\n    } else {\n      if(onFulfilled) {\n        this.callBackResoles.push(() => onFulfilled(this.value));\n      }\n\n      if(onRejected) {\n        this.callBackRejects.push(() => onRejected(this.reason));\n      }\n    }\n  }\n}","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":263,"to":286}}}}],["2378c22b-ef3a-45d1-8f52-279ada688402",{"pageContent":"const promise1 = new MyPromise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('1');\n  }, 1000);\n});\n\npromise1.then(res => {\n  console.log(' premise then :', res);\n});\n```\n\n**手写 Promise.all**\n```javascript\nstatic all(promises) {\n  return new MyPromise((resolve, reject) => {\n    let count = 0;\n    let values = [];\n    let reasons = [];","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":288,"to":305}}}}],["1912e189-b94c-490f-879c-72a59081a9fc",{"pageContent":"promises.forEach((promise, index) => {\n      promise.then(value => {\n        count++;\n        values[index] = value;\n        checkAllPromise();\n      }, reason => {\n        reasons[index] = reason;\n        checkAllPromise();\n      });\n    });\n    function checkAllPromise() {\n      if(count === promises.length) {\n        if(count === 0){\n          reject(reasons);\n        } else {\n          resolve(values); // 全部解析成功 返回结果\n        }\n      }\n    }\n  });\n}","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":307,"to":327}}}}],["aff7a466-852c-451e-a3c1-44ca26469982",{"pageContent":"const promise1 = new MyPromise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('1');\n  }, 1000);\n});\n\nconst promise2 = new MyPromise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(\"333\");\n  }, 1000);\n});\n\nMyPromise.all([promise1, promise2]).then((res) => {\n  console.log(' finished : ', res);\n});\n```\n\n#### Generator 函数\n\nGenerator 函数是 ES6 提供的一种异步编程解决方案，Generator 函数内部可以封装多个状态, 因此又可以理解为是一个状态机。**generator函数返回值为一个可迭代的函数**。\n\n**创建 Generator 函数**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":329,"to":350}}}}],["98704e4b-f1e6-4a7f-84cf-79c920c868e9",{"pageContent":"**创建 Generator 函数**\n\n在普通函数后面添加上 *，即可创建 generator 函数。\n```javascript\nfunction* getMsg() {\n  console.log(\"this is generator\");\n}\n```\n\n**函数的执行**\n\ngenerator 函数必须使用 next 执行。\n```javascript\ngetMsg().next();\n```\n\n**yield 关键字**\n\nyield实际就是暂缓执行的标示，每执行一次 next()，相当于指针移动到下一个yield位置。以此实现函数的分段执行。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":350,"to":368}}}}],["c20903a1-fb64-49d7-af37-3a984862686b",{"pageContent":"**yield 关键字**\n\nyield实际就是暂缓执行的标示，每执行一次 next()，相当于指针移动到下一个yield位置。以此实现函数的分段执行。\n\n示例\n```javascript\nfunction* getMsg() {\n  yield \"hello\";\n  yield \"generator\";\n  return;\n}\nvar fun = getMsg();\nconsole.log(fun.next()); // { value: 'hello', done: false }\nconsole.log(fun.next()); // { value: 'generator', done: false }\nconsole.log(fun.next()); // { value: 'undefined', done: true }\n```\n**可以通过 […generator()] 快速获得返回函数的执行结果**\n\n#### async/await\n\n**Async**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":366,"to":386}}}}],["6298e876-8277-40a5-a5c8-9c5936b4aa11",{"pageContent":"#### async/await\n\n**Async**\n\n带 **async** 关键字的函数，是声明异步函数，返回值是 Promise 对象，如果 async 关键字函数返回的不是Promise，会自动用 Promise.resolve() 包装。\n```javascript\nasync function getName() {\n  return 'Lily';\n}\ngetName(); // 返回 Promise 对象\n```\n**Await**\n\n**await** 是一个运算符，用于等待一个 Promise 对象的结果，只能在异步函数中使用。\n```javascript\nconst fetchName = () => {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve('Lily');\n    }, 2000);\n  });\n};","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":384,"to":405}}}}],["db4cee14-50ed-49e4-a0b1-5e5581b6afeb",{"pageContent":"const getName = async() => {\n  const name = await fetchName();\n  console.log(name);\n};\n\ngetName();\n```\n\n**处理异常**\n\n使用 async / await 一般需要使用 try…catch.. 处理异常。\n\n**总结**\n\n- async / await 可以看作自带启动器的 generator 函数的语法\n\n[co函数库](https://link.zhihu.com/?target=https%3A//github.com/tj/co) 是一个 generator 函数的自启动执行器\n\n### Proxy\n\n在目标对象之前架设一层”拦截”，外界对该对象的访问，都必须先通过这层拦截 。\nProxy 就是专门为对象设置访问代理器的，无论是读还是写都要经过代理，通过proxy就能轻松监视对象的读写过程。\n\n**创建 Proxy**\n```javascript\nconst target={\n  name: 'Lily',\n  age: 23,\n};","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":407,"to":435}}}}],["d1250ac8-1811-46ac-8788-52cca14f9f8c",{"pageContent":"**创建 Proxy**\n```javascript\nconst target={\n  name: 'Lily',\n  age: 23,\n};\n\nconst proxy = new Proxy(target, {\n  get(){  }, // 监视对象属性的访问\n  set(){  } // 监视对象设置属性的过程\n});\n```\n\n**实例方法**\n\n- get 用于拦截某个属性的读取操作，参数为(目标对象, 属性名, **Proxy 实例本身[可选]**)\n- set 用来拦截某个属性的赋值操作,参数为(目标对象, 属性名, 属性值, **Proxy 实例本身[可选]**)\n- apply 拦截函数的调用、call 和 apply 操作,参数为(目标对象、目标对象的上下文对象(this) 和 目标对象的参数数组)\n\n**示例**\n```javascript\nvar handler = {\n  apply(target, ctx, args){\n    return Reflect.apply(...arguments);\n  }\n};\n```\n\n### 装饰器","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":430,"to":458}}}}],["2562c0cc-d582-4321-a08c-ca035af6baf0",{"pageContent":"### 装饰器\n\n装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。\n装饰器是一种函数，写成@ + 函数名。它可以放在类和类方法的定义前面。\n\n**特点**\n\n- 作用于Class类，类的属性以及方法上\n- 接收三个参数：对象、属性名称、属性描述符（属性描述符通常用于传递给Object.defineProperty）\n- 类似于高阶函数，简化了调用方式，相当于一种语法糖\n\n示例\n```javascript\nfunction SetProto(target) {\n  target.prototype.name = 'Lily';\n  target.prototype.getAge = function() {\n    console.log('Add function');\n    return 20;\n  };\n}\n\n@SetProto\nclass Test { }\n\nconst test = new Test();\nconsole.log(test.name); // Lily\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":458,"to":484}}}}],["d8e46d47-0fd1-463e-bf27-61d0d6f89212",{"pageContent":"@SetProto\nclass Test { }\n\nconst test = new Test();\nconsole.log(test.name); // Lily\n```\n\n方法装饰器(**必须返回descriptor**)\n```javascript\n// 调用方法前输出日志\nfunction Log(target, name, descriptor) {\n  var oldValue = descriptor.value;\n\n  descriptor.value = function() {\n    console.log(`Calling function ${name} with ${Object.values(arguments)}, result: `, oldValue.apply(this, arguments));\n    return oldValue.apply(this, arguments);\n  };\n\n  return descriptor;\n}","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":479,"to":498}}}}],["aeeae56d-d067-4e5b-bbd8-6becfdf24164",{"pageContent":"return descriptor;\n}\n\nclass Test {\n  @Log\n  add(a, b) {\n    return a + b;\n  }\n}\n\nlet test = new Test();\ntest.add(1, 2);\n```\n\n### 模块化\n\n模块化是指将一个大的程序文件，拆分成许多小的文件，然后将小文件组合起来。\n\n**模块化的优点**\n\n- 防止命名冲突\n- 代码复用\n- 高可维护性\n  \n#### 模块化雏形(IIFE)\n\n立即执行函数的作用是创建一个独立的作用域。这个作用域里面的变量，外面访问不到。\n```javascript\nconst module = (() => {\n  let count = 0;\n  return {\n    increase: () => ++count;\n    reset: () => {\n      count = 0;\n    }\n  }\n})();\n\nmodule.increase();\nmodule.reset();\n```\n\n**优缺点**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":497,"to":539}}}}],["4faadbb7-f8bd-4506-86df-7d11b1cedcb3",{"pageContent":"module.increase();\nmodule.reset();\n```\n\n**优缺点**\n\n- 避免作用域命名污染\n- 提升性能（减少了对作用域的查找）\n- 避免全局命名冲突\n- 有利于代码压缩（可以用简单字符串代替）\n- 保存闭包状态\n- 颠倒代码执行顺序\n  \n#### CJS(commonjs)\nCommonJs 是 node.js 制定的标准，特征如下：\n\n- 通过 module + export 去对外暴露接口\n- 通过 require 去调用其他模块\n\n示例\n```javascript\n// 引入部分\nconst dependencyModule1 = require('../dependencyModule1');\nconst dependencyModule2 = require('../dependencyModule2');\n\n// 核心逻辑\nlet count = 0;\n\n// dependencyModule1, dependencyModule2……\n// 代码块1\nconst increase = () => ++count;","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":535,"to":565}}}}],["fd76a021-3664-431b-b9da-ededb3ef2926",{"pageContent":"// dependencyModule1, dependencyModule2……\n// 代码块1\nconst increase = () => ++count;\n\n// 代码块2\nconst reset = () => {\n  // dependencyModule1\n  count = 0;\n}\n\n// 暴露接口部分\nexport.increase = increase;\nexport.reset = reset;\n// 等价于\nmodule.exports = {\n  increase,\n  reset\n};\n\n// 引入模块\nconst { increse, reset } = require('dep.js');\nincrease();\nreset();\n```\n\n**暴露的本质是 exports 对象**。\n\n**特点**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":563,"to":590}}}}],["4e183079-7e27-455e-9227-3685b40c2c15",{"pageContent":"**暴露的本质是 exports 对象**。\n\n**特点**\n\n- 使用 require 导入时，若导入模块未执行则会先执行，已经执行过的则直接导入\n- requirejs 导入的为对象的值，因此修改导入的对象不会改变原对象\n- require 支持动态导入，但是**同步加载**，只有导入的模块代码执行完成才能成功导入\n  \n#### AMD\n\nAMD 主要解决了 CommonJS 无法异步导入的问题，通过 define 定义模块，通过 require 和回调的方式导入模块。**经典的实现框架 require.js**。\n\n定义及引入方式\n```javascript\n// 通过define来定义一个模块，然后再用require去加载\ndefine(id, [depends], callback)\nrequire([module], callback)\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":588,"to":605}}}}],["6cea9ea0-931c-4090-a07d-9920689c53ec",{"pageContent":"示例\n```javascript\n// 定义模块\ndefine('amdModule', ['dependencyModule1', 'dependencyModule2'],      (dependencyModule1, dependencyModule2) => {\n  // 业务逻辑\n  let count = 0\n\n  // 代码块1\n  const increase = () => {\n    // dependencyModule2……\n    ++count;\n  }\n\n  // 代码块2\n  const reset = () => {\n    // dependencyModule1\n    count = 0;\n  }\n})\n\n// 引入模块\nrequire(['amdModule'], amdModule => {\n  amdModule.increse();\n})\n```\n\nAMD模块在浏览器端可以通过RequireJS实现，也支持动态导入。\n\n#### UMD","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":607,"to":635}}}}],["8dd6ef00-f88d-4c4f-ad07-360216f97321",{"pageContent":"AMD模块在浏览器端可以通过RequireJS实现，也支持动态导入。\n\n#### UMD\n\nUMD 则是一种同时兼容AMD、CMD 与 CommonJS的方式，每一个模块都由一个自执行函数包裹，在自执行的函数中通过判断 module、define 等关键字实现兼容处理。\n\n```javascript\n(\n  // 目标：一次去定位区分CJS和AMD\n  // 1. CJS factory\n  // 2. module module.exports\n  // 3. define\n  typeof module === 'Object'\n  && module.exports\n  && typeof define !== 'function'\n  ? // 是CJS\n  factory => module.exports = factory(require, exports, module)\n  : // 是AMD\n  define\n)\n```\n\n**优缺点**\n\n- 解决了服务、客户端异步动态依赖的问题\n- 会有引入成本，没有考虑按需加载\n  \n#### CMD","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":633,"to":660}}}}],["061470e5-363e-4d28-afbf-f0161eb32363",{"pageContent":"**优缺点**\n\n- 解决了服务、客户端异步动态依赖的问题\n- 会有引入成本，没有考虑按需加载\n  \n#### CMD\n\nCMD相比AMD模块化规范，其优点在于，在页面初始化时，不会一次性去加载所有的子模块，而是可以在项目运行期间，需要使用到时，再去按需加载。**主要应用框架 sea.js**\n\n实现方式\n```javascript\n// 依赖就近\ndefine('module', (require, exports, module) => {\n  let $ = require('map');\n  // ...代码块1\n  if (xxx) {\n    return;\n  }\n\n  //加载依赖-异步模式\n  const module_async = require.async('./module_async');\n\n  if (xxx) {\n    return;\n  }\n\n  let depends2 = require('./dependencyModule2');\n  // 代码块2\n})\n```\n\n**优缺点**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":655,"to":686}}}}],["fe1a923f-1fe8-4f3d-aa06-545f4aca6704",{"pageContent":"let depends2 = require('./dependencyModule2');\n  // 代码块2\n})\n```\n\n**优缺点**\n\n- 按需加载，依赖就近 (有点)\n- 依赖打包\n- 扩大了模块内的体积\n  \n#### ESM(ES Module)\nES Module 模式是 ES6 新引入的模块化规范。被认为是大一统的模块化设计规范。\n\n在 html 文件中中引用\n```html\n<script type=\"module\">\n  console.log('this is es module')\n</script>\n```\n\n在 NodeJs中引用\n\n**在 package.json 中添加 type: module。**\n\n**基本特性**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":681,"to":706}}}}],["dde9c0df-3cc1-434b-b360-e5335aad5283",{"pageContent":"在 NodeJs中引用\n\n**在 package.json 中添加 type: module。**\n\n**基本特性**\n\n- ESM 自动采用严格模式，不管你是否在模块的头部加上 use strict\n- 每个模块都有自己的上下文，都运行在单独的私有作用域中，不污染全局作用域\n- 每一个模块只加载一次（是单例的），若再去加载同目录下同文件，直接从内存中读取\n- ESM 是通过 CORS 的方式请求外部 JS 模块的\n- ESM 的 script 标签加 **type=”module”**，等同于 defer 属性\n\n**导入导出**\n\n导入模块使用 **import** 关键字，导出模块使用 **export** 关键字。\n```javascript\n// 创建一个名为 math.js 的模块文件，并且导出两个函数：add 和 multiply\nexport function add(x,y) {\n  return x + y;\n}\n\nexport function multiply(x,y) {\n  return x * y;\n}","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":702,"to":725}}}}],["20a92555-1d36-4f50-8a37-564b471436da",{"pageContent":"export function multiply(x,y) {\n  return x * y;\n}\n\n// 在另一个文件中，使用 import 关键字导入 math.js 模块\nimport { add, multiply } from \"./math.js\"; // 导入指定的函数（需要使用花括号）\nconsole.log(add(1,2)); // 3\nconsole.log(multiply(2,3)); // 6\n\n// 可以使用 as 关键字给导入或导出的函数起别名\nimport {add as plus, multiply as times} from \"./math.js\";\nconsole.log(plus(1,2)); // 3\nconsole.log(times(2,3)); // 6\n\nexport {add as plus, multiply as times}; // 导出并重命名函数","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":723,"to":737}}}}],["465100cb-70c2-442a-bf80-c10d82e938b8",{"pageContent":"export {add as plus, multiply as times}; // 导出并重命名函数\n\n// 可以使用 * 符号导入或导出所有的函数（需要起一个别名）\nimport * as math from \"./math.js\"; // 导入所有函数并起一个别名为math\nconsole.log(math.add(1,2)); // 3\nconsole.log(math.multiply(2,3)); // 6\n\nexport * from \"./math.js\"; // 导出所有函数\n\n// 可以使用 default 关键字指定一个默认的导出（只能有一个，默认导出不需要花括号）\nexport default function subtract(x,y) {\n  return x - y;\n}\n\nimport subtract from \"./math.js\"; // 导入默认导出（不需要花括号）\nconsole.log(subtract(5,4)); // 1\n```\n\n**动态加载模块**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":737,"to":755}}}}],["c377cab6-e244-4a6d-84eb-431915e5770e",{"pageContent":"**动态加载模块**\n\n```javascript\nimport('/modules/myModule.js')\n  .then((module) => {\n    // Do something with the module.\n  });\n```\n\n**export 具名导出时导出的是引用地址，export default 导出时与其他模块化一样是复制值**。\n\n### 迭代器和生成器\n\n迭代器是一种遵循迭代协议的对象，可以按照一定的顺序访问一个集合中的元素。迭代器有一个 **next** 方法，每次调用返回一个包含 **value** 和 **done** 属性的对象，**value** 表示当前元素的值，**done** 表示是否还有更多元素。ES6提供了一种新的语法 for…of 循环，可以方便地遍历迭代器。\n\n生成器是一种特殊的函数，可以返回一个迭代器对象，并且可以在函数体内使用 **yield** 关键字暂停和恢复执行。生成器使用 **function*** 关键字声明，并且可以接收参数。(**Generator 函数**)\n\n创建迭代器","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":755,"to":772}}}}],["702c8f4e-501b-46c8-8296-d2848292b9f9",{"pageContent":"创建迭代器\n\n```javascript\n// 创建一个迭代器对象：使用 Symbol.iterator 符号作为属性名，并且返回一个具有 next 方法的对象\nlet iterator = {\n  [Symbol.iterator]() {\n    let i = 0;\n    return {\n      next() {\n        if (i < 5) {\n          return {value: i++, done: false}; // 返回当前元素的值和状态\n        } else {\n          return {done: true}; // 返回结束状态\n        }\n      }\n    };\n  }\n};\n\n// 使用 for...of 循环遍历迭代器对象（不需要调用 next 方法）\nfor (let value of iterator) {\n  console.log(value); // 0 1 2 3 4\n}\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ES6新特性.mdx","loc":{"lines":{"from":772,"to":795}}}}],["2607211e-43f4-4253-94ec-5f979c8d1126",{"pageContent":"---\ntitle: HTML 基础知识\ndate: '2024-03-10'\ntags: ['HTML']\ndraft: false\nsummary: HTML 需要掌握的基础知识及面试常考内容整理\n---\n\n## DOM\n- 档对象模型，包括文档、节点和元素\n- 所有元素都是节点，节点包括注释和文本等\n- 常用dom操作，getElementById、querySelector、appendChild等\n  \n## BOM\n浏览器对象模型，提供了很多用于访问浏览器的对象，核心是window。包括以下对象：\n\n- location 获取或设置浏览器的地址相关信息\n- navigator 用于访问用户浏览器的信息\n- history 提供了操作浏览器会话历史的API\n- screen 获取当前窗口的屏幕属性\n- frames 获取当前窗口中的所有 iframe 元素\n\n## 事件模型\n\n浏览器事件模型中的过程主要分为三个阶段：**捕获阶段、目标阶段、冒泡阶段**。相关API包括：","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/HTML基础.mdx","loc":{"lines":{"from":1,"to":25}}}}],["0635e659-2566-4753-bbe6-ad27d2394d9c",{"pageContent":"## 事件模型\n\n浏览器事件模型中的过程主要分为三个阶段：**捕获阶段、目标阶段、冒泡阶段**。相关API包括：\n\n- addEventListener 添加事件监听\n- removeEventListener 移除事件监听\n- AbortController 控制器对象，可以终止Web请求或者用于移除事件监听\n- preventDefault 阻止默认事件\n- stopPropagation 阻止冒泡\n\nAbortController 使用实例（**已经abort的请求是不能重复调用**）\n\n```html\n<body>\n  <button id='fetchMsg'>发送请求</button>\n  <button id='abortFetch'>废弃请求</button>\n</body>","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/HTML基础.mdx","loc":{"lines":{"from":23,"to":39}}}}],["e2abc4a7-4be8-4d71-9d2e-71d24af5bab0",{"pageContent":"<script>\n  const controller = new AbortController();   // 新建一个 AbortController 实例\n  let signal = controller.signal;    // signal 是AbortController 实例的属性\n\n  const fetchBtn = document.getElementById('fetchMsg');\n  const abortBtn = document.getElementById('abortFetch');\n\n  fetchBtn.addEventListener('click', fetchContent);\n\n  abortBtn.addEventListener('click', function () {\n      controller.abort();  // 调用abort方法\n  })","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/HTML基础.mdx","loc":{"lines":{"from":41,"to":52}}}}],["f519923d-3779-499e-abc5-23176719533e",{"pageContent":"abortBtn.addEventListener('click', function () {\n      controller.abort();  // 调用abort方法\n  })\n\n  function fetchContent() {\n    fetch(url, {signal}).then(function(res) {\n      //...\n    }).catch(function(e) {\n      console.error(e);\n    })\n  }\n</script>\n```\n\n### 事件委托\n\n事件委托也称之为事件代理，是JavaScript中常用绑定事件的常用技巧。即把原本需要绑定在子元素的响应事件委托给父元素，让父元素担当事件监听的职务。原理是DOM元素的事件冒泡。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/HTML基础.mdx","loc":{"lines":{"from":50,"to":66}}}}],["0f933a83-c8d5-4db6-98fc-bb78e430a4a7",{"pageContent":"事件委托也称之为事件代理，是JavaScript中常用绑定事件的常用技巧。即把原本需要绑定在子元素的响应事件委托给父元素，让父元素担当事件监听的职务。原理是DOM元素的事件冒泡。\n\n## HTML标签\n### link\n用于加载外部链接的元素，通常用于加载 CSS 和 favicon 文件，通过设置 ref = ‘preload’、ref = ‘prefetch’，配合 as 属性可以加载其他类型的文件。\n```html\n<link rel=\"preload\" href=\"myFont.woff2\" as=\"font\"\n  type=\"font/woff2\" crossorigin=\"anonymous\">\n```\n\n### script\n\n- **无属性**\n\n解析到标签，立刻pending，同时下载执行。在渲染该 script 标签之下的文档元素之前，不等待后续载入的文档元素，读到就加载并执行。\n\n- **defer**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/HTML基础.mdx","loc":{"lines":{"from":66,"to":82}}}}],["363f7fa2-4a51-4a60-96f9-ac91533f0cdb",{"pageContent":"- **无属性**\n\n解析到标签，立刻pending，同时下载执行。在渲染该 script 标签之下的文档元素之前，不等待后续载入的文档元素，读到就加载并执行。\n\n- **defer**\n\n解析到标签，开始异步下载，继续往后进行文档元素的加载，dom加载完成之后开始执行js。即所有元素解析完成之后，DOMContentLoaded 事件触发之前执行。\n\n- **async**\n\n解析到标签，开始异步下载，下载完成之后立刻执行并且**阻塞**dom元素的继续绘制，执行完成之后，再继续向下加载dom。\n\n- **crossOrigin**\n\n默认值 anonymous，设置了 crossorigin 就相当于开启了 CORS 校验。设置为 use-credentials 可以跨域携带cookie。\n\n- **referrerpolicy**\n\n设置在获取脚本时可以携带的 Referer 信息，默认只有 HTTPS 会发送 Referer 信息。\n\n- **integrity**\n\n允许比对接收到的资源和指定的加密签名以及验证资源完整性。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/HTML基础.mdx","loc":{"lines":{"from":78,"to":100}}}}],["88e8d74c-9bf2-4615-bf63-8a75d92a9088",{"pageContent":"设置在获取脚本时可以携带的 Referer 信息，默认只有 HTTPS 会发送 Referer 信息。\n\n- **integrity**\n\n允许比对接收到的资源和指定的加密签名以及验证资源完整性。\n\n## HTML5\n### 新增语义化标签\nheader、footer、section、video、audio等\n\n### video\n可以直接使用 src 指定资源，也可以在 source 子元素中使用 src 指定资源。当存在多个 source 元素时，默认取**第一个能加载成功**的资源。\n相关开源资源 [video.js](https://videojs.com/)\n\n**相关属性**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/HTML基础.mdx","loc":{"lines":{"from":96,"to":110}}}}],["feb1ad4b-ec38-439a-92a8-60551ea7c836",{"pageContent":"**相关属性**\n\n- controls 属性用于控制播放工具栏\n- crossorigin 属性用于控制跨域，与script 一致\n- loop 是否循环播放\n- muted 是否静音\n- poster 视频封面海报，不设置默认取视频的第一帧\n- preload 预加载，**none** 不预加载，**metadata** 进预加载没提元数据，**auto** 预加载整个视频，如果存在**autoplay**，则会忽略preload属性\n\n**支持监听的事件**\n\n- loadeddata 加载数据完成时触发\n- onloadstart 加载内容开始时触发\n- pause 暂停操作\n- play 开始播放\n- seeking 重新定位媒体播放的位置完成后触发，表示定位已经结束\n- ended 播放完成触发\n  \n### audio\n用法和相关属性与 video 相似。其他属性：\n\n- duration 音频文件的长度\n- currentTime 当前播放时间点\n\n相关开源资源 [Howler.js](https://howlerjs.com/)","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/HTML基础.mdx","loc":{"lines":{"from":110,"to":134}}}}],["d1419343-60ae-4a58-97cd-ca8490d9f453",{"pageContent":"- duration 音频文件的长度\n- currentTime 当前播放时间点\n\n相关开源资源 [Howler.js](https://howlerjs.com/)\n\n### canvas\ncanvas 生成的是位图，默认宽高 300px * 150px。通过 canvas element 的 **getContext**(“2d”) 获取上下文。\n\n常用方法\n\n- getContext 获取上下文（参数’2d’或’webgl’）\n- beginPath 用于创建一个新的路径\n- moveTo 移动到新的坐标点，不创建路径\n- lineTo 划线到指定坐标点\n- stroke 绘制路径的边框\n- rect 绘制矩形\n- fillRect 绘制填充矩形\n- clearRect 清除指定矩形区域内的像素内容\n- drawImage 渲染图片\n- toDataURL 将画布内容转为DataURL\n- …\n\n解决模糊问题（通过css设置显示内容为canvas宽高的一半）","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/HTML基础.mdx","loc":{"lines":{"from":131,"to":153}}}}],["8cb48538-e246-42a8-8d97-6fb3dff9adec",{"pageContent":"解决模糊问题（通过css设置显示内容为canvas宽高的一半）\n\n```javascript\nvar ctx = canvas.getContext('2d');\nctx.translate(0.5, 0.5);\n```\n\n### svg\n\n生成的是矢量图，可自由缩放，由标签组成，可在标签上绑定事件。\n常用的标签包括：text、path、g、rect、circle、foreignObject等。width、height 属性定义 svg 的宽高，viewBox 设置画布中展示的内容大小。\n\n### history\n用于操作浏览器在标签页访问的会话历史记录。hisotry 对象无法复写，且历史记录存在上限。\n\n支持的方法\n\n- go 前进刷新，go(-1) 后退并刷新原页面\n- back 后退不刷新原页面，back(-1)\n- forward 前进\n- pushState **无刷新**地向当前history插入一条历史记录\n- replaceState 直接替换当前历史记录","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/HTML基础.mdx","loc":{"lines":{"from":153,"to":174}}}}],["58af4436-c9e0-4f9d-bece-5b91951805fd",{"pageContent":"**popstate** 浏览器点击前进或后退时触发的事件。pushState 和 replaceState **不会触发**该事件。\n\n### Geolocation\n\nnavigator 的 geolocation 对象主要用来获取位置信息，包含一系列相关位置操作方法，需要选择IE9及以上的浏览器。主要包含三个方法：\n\n- getCurrentPosition(successCb, errorCb, positionOptions) 获取当前地址信息（请求一次）\n- watchPosition(successCallback, errorCallback, positionOptions) 监视当前地理位置（请求多次）\n- clearWatch(watchId) 清除监视功能\n\nsuccessCallBack 会返回一个对象参数 coords，包含以下信息：","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/HTML基础.mdx","loc":{"lines":{"from":176,"to":186}}}}],["5efd94f7-a8ad-48ef-b28d-7a4fa5e83243",{"pageContent":"successCallBack 会返回一个对象参数 coords，包含以下信息：\n\n- coords.latitude 十进制数的纬度\n- coords.longitude 十进制数的经度\n- coords.accuracy 所提供的以米为单位的经度和纬度估计的精确度\n- coords.altitude 海拔，海平面以上以米计\n- coords.altitudeAccuracy 所提供的以米为单位的高度估计的精确度\n- coords.heading 宿主设备当前移动的角度方向，相对于正北方向顺时针计算\n- coords.speed 以米每秒为单位的设备的当前对地速度\n\nerrorCallback 接受错误对象作为参数，包含code属性、message信息。\n\n**code** 属性：\n\n- 当属性值为1时，用户不允许地理定位（拒绝授权），“Permission denied”\n- 当属性值为2时，无法获取当前位置，“Position unavailable”\n- 当属性值为3时，操作超时，“Timeout”\n\n**message** 属性","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/HTML基础.mdx","loc":{"lines":{"from":186,"to":204}}}}],["c403ec5c-44b8-4945-89a5-f21da8495cbe",{"pageContent":"**message** 属性\n\n属性值是一个字符串，包含了错误信息，这个错误信息在我们开发和调试时非常有用\npositionOptions 是一个可选属性的列表，说明如下：\n\n- enableHighAccuracy 启用高精确度模式，这个参数通知浏览器启用HTML5\n- Geolocation 服务的高精确度模式，默认值为false\n- timeout 超时限制，单位毫秒，如果在该时间内未获取到地理位置信息，则返回错误\n- maximumAge 表示浏览器重新计算位置的时间间隔，单位毫秒，默认为零，这意味着浏览器每次请求都必须重新计算位置\n  \n## 本地缓存\n### LocalStorage\n\n持久化存储，不手动删除或者清除浏览器缓存会一直存在。存储空间可以达到5MB，以 key – value 字符串的形式存储。\n提供的方法：","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/HTML基础.mdx","loc":{"lines":{"from":204,"to":218}}}}],["96023e99-32f8-4dda-a9d2-3f6df505df93",{"pageContent":"持久化存储，不手动删除或者清除浏览器缓存会一直存在。存储空间可以达到5MB，以 key – value 字符串的形式存储。\n提供的方法：\n\n- setItem(key, value) 将数据以键值对的形式存到 LocalStorage 中\n- getItem(key) 获取 LocalStorage 中键值为 key 的数据\n- removeItem(key) 删除 LocalStorage 中键值为 key 条目\n- clear() 清空 LocalStorage 中的数据\n- key(number) 获取 LocalStorage 数据列表中指定索引的 key 值\n  \n### cookie\n\n由服务端返回 Set-Cookie 的 header 设置，在前端也可以通过 document.cookie 设置。每个 cookie 都是一个键值对数据。\n\ncookie的存储空间位4KB，可以通过 max-age 或者 expires 设置其过期时间。\n```javascript\ndocument.cookie = \"name = tom\"\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/HTML基础.mdx","loc":{"lines":{"from":217,"to":233}}}}],["52bf5cab-00de-47ce-925d-c45cce9ca568",{"pageContent":"cookie的存储空间位4KB，可以通过 max-age 或者 expires 设置其过期时间。\n```javascript\ndocument.cookie = \"name = tom\"\n```\n\ndocument.cookie 也可以用于获取 cookie 数据，但是无法访问带有 HttpOnly 的 cookie。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/HTML基础.mdx","loc":{"lines":{"from":230,"to":235}}}}],["55cf0c65-24bd-4397-9708-94486454c306",{"pageContent":"document.cookie 也可以用于获取 cookie 数据，但是无法访问带有 HttpOnly 的 cookie。\n\n| **属性** | **含义** |\n| --- | --- |\n| **Name** | Cookie的名称 |\n| **Value** | 对应名称的值 |\n| **Domain** | Cookie的域名 |\n| **Path** | Cookie生效的路径 |\n| **Expires** | 过期时间，过了这个时间后Cookie失效 |\n| **Max-age** | 生效时间，表示Cookie在多长时间后失效 |\n| **Size** | Cookie的长度，为name和value的长度和 |\n| **HttpOnly** | 防止通过JavaScript访问Cookie |\n| **Secure** | 只在HTTPS协议的情况下才会将Cookie传到后端 |\n| **SameSite** | 是否允许跨站请求时发送Cookie |\n| **Partitioned** | 第三方Cookie分区 |\n| **Priority** | 优先级 |","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/HTML基础.mdx","loc":{"lines":{"from":235,"to":250}}}}],["8b159284-1dff-40f0-a0ea-4571b75a08c3",{"pageContent":"**Cookie 生命周期**\n\nCookie是有生命周期的，在设置Cookie值时，可以同时设置有效期。当超过了这个有效期之后，Cookie便会失效，前端请求时，不会携带过期的Cookie。\n\nCookie的有效期有三种类型：\n\n- Session 如果Cookie的有效期为Session，一般关闭会话时，Cookie便会失效\n- Expires 过期时间，是一个确定的日期时间，当浏览器的当前时间超过这个时间，Cookie便会失效\n- Max-age 表示Cookie的存活时间，以秒作为单位\n\n**注意**\n\n上述的生命周期都是服务端指定的。如果设置了Expires，则是把服务器时间和浏览器本地时间相比较，如果时间不同步，配置就会出现问题。而Max-age设置的是秒数，始终是浏览器本地时间自己相比较，不会出现时间不同步的问题。\n\n### sessionStorage\n\nsessionStorage 是HTML5新增的一个临时会话存储对象，用于临时保存同一窗口(或标签页)的数据，当关闭当前窗口或浏览器时会自动删除所存储内容。\n特点","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/HTML基础.mdx","loc":{"lines":{"from":252,"to":269}}}}],["96fef29c-1abf-4027-b84a-6e85ba9c72c6",{"pageContent":"sessionStorage 是HTML5新增的一个临时会话存储对象，用于临时保存同一窗口(或标签页)的数据，当关闭当前窗口或浏览器时会自动删除所存储内容。\n特点\n\n- 数据时效性 页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话，直到关闭对应浏览器标签或窗口才会清除\n- 页面共享 在新标签或窗口打开一个页面时会复制顶级浏览会话的上下文作为新会话的上下文\n- 独立性 打开多个相同的 URL 的 Tabs 页面，会创建各自的 sessionStorage\n- 存储方式 采用key、value的方式。value的值必须为字符串类型\n- 存储限制 不同浏览器限制不同，主流浏览器限制是5MB\n\n属性与方法\n\n**sessionStorage** 与 **localStorage** 的属性方法基本一致。\n\n### IndexedDB \nIndexedDB是在浏览器端实现的一种事务性数据库，以文件的形式存储在用户本地。 只要本地磁盘空间足够，就可以一直存储。清除浏览器缓存时，不会清除数据，只能手动删除数据库。\n\n**特点**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/HTML基础.mdx","loc":{"lines":{"from":268,"to":284}}}}],["ee858399-cd96-4648-850a-f4b4318a19d8",{"pageContent":"**特点**\n\n- 键值对储存 即JavaScript对象\n- 异步 避免同步引起阻塞\n- 支持事务\n- 支持索引\n- 同源限制 按域名隔离，跟localStorage相同\n- 储存空间大 可以达到250M\n- 支持二进制储存 支持 ArrayBuffer 和 Blob 对象\n\n**核心接口**\n\n- 数据库 IDBDatabase 对象\n- 对象仓库 IDBObjectStore 对象\n- 索引 IDBIndex 对象\n- 事务 IDBTransaction 对象\n- 操作请求 IDBRequest 对象\n- 指针 IDBCursor 对象\n- 主键集合 IDBKeyRange 对象\n\n**打开/新建数据库 open**\n```javascript\nconst request = window.indexedDB.open(databaseName, version);\n```\n\nopen 返回一个 IDBRequest 对象，又三个事件：","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/HTML基础.mdx","loc":{"lines":{"from":284,"to":309}}}}],["9c1be010-4c76-45b2-9047-cc798091b9fc",{"pageContent":"open 返回一个 IDBRequest 对象，又三个事件：\n\n**success**\n```javascript\nrequest.onsuccess = function (event) {\n  // 数据库打开成功\n  db = request.result;\n  // db = event.target.result; 也能拿到\n};\n```\n\n**error**\n```javascript\nrequest.onerror = function (event) {\n  // 打开报错\n};\n```\n\n**upgradeneeded** \n\n表示升级数据库，即传递的版本参数大于目前浏览器里该名字的数据库的版本参数\n```javascript\nrequest.onupgradeneeded = function (event) {\n  db = event.target.result;\n}\n```\n\n以上一个事件同时存在时，会先执行 **upgradeneeded** 事件。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/HTML基础.mdx","loc":{"lines":{"from":309,"to":336}}}}],["e7a19d53-3eae-4261-85a3-1616c97caacc",{"pageContent":"以上一个事件同时存在时，会先执行 **upgradeneeded** 事件。\n\n表结构的操作都是在 onupgradeneeded 事件里执行。\n```javascript\nrequest.onupgradeneeded = function(event) {\n  db = event.target.result;\n  var objectStore;\n  if (!db.objectStoreNames.contains('class')) {\n    objectStore = db.createObjectStore('class', {\n      keyPath: 'id'\n    });\n  }\n}\n```\n\n自增主键\n```javascript\nobjectStore2 = db.createObjectStore(\n  'class2',\n  { autoIncrement: true }\n);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/HTML基础.mdx","loc":{"lines":{"from":336,"to":357}}}}],["e201ed0d-96ea-403e-8a7c-82a04a0147a9",{"pageContent":"建完表建索引\n```javascript\nobjectStore.createIndex('name', 'name', { unique: true });\n```\n\n关闭和删除数据库\n```javascript\ndb.close();\nwindow.indexedDB.deleteDatabase(dbName);\n```\n\n**CRUD 操作 API**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/HTML基础.mdx","loc":{"lines":{"from":359,"to":370}}}}],["563c5e19-786b-42bb-b014-2964fd422c36",{"pageContent":"**add** 插入一条数据\n```javascript\nfunction add(class) {\n  var request = db.transaction(['class'], 'readwrite') // 新建事务，readwrite, readonly(默认), versionchange \n    .objectStore('class') // 拿到IDBObjectStore 对象\n    .add({  // 插入记录\n      id: class.id,\n      name: class.name\n    });\n  request.onsuccess = function(event) {\n    console.log('数据写入成功');\n  }\n  request.onerror = function(event) {\n    console.log('数据写入失败');\n  }\n  request.onabort = function(event) {\n    console.log('事务回滚');\n  }\n}\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/HTML基础.mdx","loc":{"lines":{"from":372,"to":391}}}}],["01e75eac-16b7-4a9a-8b6c-ef3ef9863732",{"pageContent":"**get** 读取一条数据\n```javascript\nvar transaction = db.transaction(['class']);\nvar objectStore = transaction.objectStore('class');\nvar request = objectStore.get(1); // 传主键\n```\n\n**openCursor** 游标，读取所有记录\n```javascript\nobjectStore.openCursor().onsuccess\n// 也可以在索引上打开 objectStore.index(\"id\").openCursor()\n\n// 可以传入参数作为游标的范围\nobjectStore.openCursor(IDBKeyRange.only(1))\n\n// IDBKeyRange上还有lowerBound( )、upperBound( )、bound( )方法\nIDBKeyRange.bound(1, 10, false, true) //范围是[1, 10)","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/HTML基础.mdx","loc":{"lines":{"from":393,"to":409}}}}],["975497ea-50fb-4d02-bae2-4d10ecb104d5",{"pageContent":"// openCursor 第二个参数表示方向，可取值 next，nextunique，prev，prevunique\nobjectStore.openCursor(null, \"prev\")\n```\n\n**put** 更新记录\n```javascript\nvar request = objectStore.put({id: 10, name: '高二六班'});\n```\n\n**delete** 删除记录\n```javascript\nvar request = objectStore.delete(1); // 主键\n```\n\n**clear** 清空记录\n```javascript\nvar request = objectStore.clear();\n```\n\n## 其他\n### DOCTYPE\n\n用于告诉浏览器以什么方式渲染文档，不声明的话默认使用怪异模式。页面添加 DOCTYPE，那么就等同于开启了标准模式\n\n- **BackCompat** 怪异模式，浏览器使用自己的怪异模式解析渲染页面\n- **CSS1Compat** 标准模式，浏览器使用W3C的标准解析渲染页面","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/HTML基础.mdx","loc":{"lines":{"from":411,"to":436}}}}],["ab6688f5-c84e-4c6f-b485-bb5e752b3089",{"pageContent":"- **BackCompat** 怪异模式，浏览器使用自己的怪异模式解析渲染页面\n- **CSS1Compat** 标准模式，浏览器使用W3C的标准解析渲染页面\n\n怪异模式使用比较旧的 IE5 排版方式，盒模型包含了 padding 和 border\n**DOCTYPE取值**\n- html5\n  \n```html\n<!DOCTYPE html>\n```\n\n- HTML 4.01 Strict\n\n该DTD包含所，有的HTML元素和属性，但不含展示性的和弃用元素(比如 font)，不允许框架集(Framesets)。\n```html\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n```\n\n- HTML 4.01 Transitional","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/HTML基础.mdx","loc":{"lines":{"from":435,"to":453}}}}],["fa3a1357-6f73-4ae4-95f2-08818a253a8c",{"pageContent":"- HTML 4.01 Transitional\n\n该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。\n```html\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n```\n\n- HTML 4.01 Frameset\n\n该 DTD 等同于 HTML 4.01 Transitional，但允许框架集内容。\n```html\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\" \"http://www.w3.org/TR/html4/frameset.dtd\">\n```\n\n### 空元素\n空元素包含：br、img、hr、input、link、meta等。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/HTML基础.mdx","loc":{"lines":{"from":453,"to":468}}}}],["171e798f-d780-4218-870a-66a03a4e45bf",{"pageContent":"---\ntitle: JavaScript基础\ndate: '2024-03-20'\ntags: ['JavaScript']\ndraft: false\nsummary: JavaScript 基础知识必须掌握的内容\n---\n\n## 数据类型\n### 基本数据类型\n\n- string 字符串类型\n- number 数字类型，包括整数和浮点数\n- boolean 布尔值，true 或 flase\n- symbol 表示独一无二的值，防止变量名覆盖（es6新增）\n- undefined 表示未定义的数据类型\n- null 表示空对象指针的数据类型\n  \n### 引用数据类型\n\n- Object 对象类型\n- Array 数组类型\n- Function 函数\n\n**Function、Array、Date 等其实都是 Object 类型**\n\n### 基本类型与引用类型的区别\n\n基本类型与引用类型是根据**存储方式**的不同而区分的。基本数据类型直接存放在**栈**中，引用数据类型是存放于**堆**内存中，并将其**地址信息存储在栈**中。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":1,"to":29}}}}],["501fc707-133d-4a6b-8f14-9a275fb2350b",{"pageContent":"基本类型与引用类型是根据**存储方式**的不同而区分的。基本数据类型直接存放在**栈**中，引用数据类型是存放于**堆**内存中，并将其**地址信息存储在栈**中。\n\n示例\n```javascript\nvar a = 100;\nvar b = a;\na = 101;\nconsole.log(b)  // 输出 100，a 与 b 互不影响\n\nvar c = { x: 100 };\nvar d = c;\nc.x = 120;\nconsole.log(d.x); // 输出 120，d变量中实际是存储的c的地址信息，c 与 d同时指向一个对象\n```\n\n### 判断类型的方法\n\n- typeof 判断变量类型，返回值为字符串形式number,boolean,string,function,object,undefined\n- instanceof 用于判断一个实例是否是某个对象的实例","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":29,"to":47}}}}],["a86c78c8-cfb2-45ac-9496-dfbca6bf5e84",{"pageContent":"用法\n```javascript\ntypeof A        // 判断数据类型\nA instanceof B    // 判断 A 的原型链上是否有 B 的原型\n```\n**instanceof 只能判断引用类型数据的具体类型**，**可以用来精确判断数据的类型**\n\n示例\n```javascript\nconsole.log(typeof 123);  // 'number'\n\nconst a = {x: 1, y: 2};\nconsole.log(a instanceof Object);   // true\n\nconst c = new String('hello');\nconsole.log(typeof c);  // 'object'\nconsole.log(c instanceof String);   // true  精确判断String\n```\n\n### 隐式类型转换\n\n在js中，当运算符在运算时，如果两边数据类型不统一，CPU 就无法计算，这时编译器会自动将运算符两边的数据做一个数据类型转换，转成一样的数据类型再进行计算。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":49,"to":70}}}}],["0b73eaf9-a21a-4eac-af8e-f03fc6f176f7",{"pageContent":"### 隐式类型转换\n\n在js中，当运算符在运算时，如果两边数据类型不统一，CPU 就无法计算，这时编译器会自动将运算符两边的数据做一个数据类型转换，转成一样的数据类型再进行计算。\n\njs 隐式类型转换有数值类型转换、字符串类型转换、布尔类型转换、对象类型转换等。\n**隐式转换规则**\n\n- 转成 string 类型 +（字符串连接符）\n- 转成 number 类型 ++ –（自增自减运算符）+ – * / % **（算术运算符）> < >= \\<= == !=（关系运算符）\n- 转成 boolean 类型 ! !!（逻辑非运算符）\n\n**注意** **+ ，它既是连接符，也是运算符**。\n\n- 当 + 两边都有值，且至少一个值是字符串类型，就会出现字符串拼接\n- 当只有 + 后面有值，例如: +\"123\"等同于Number(\"123\")，会将字符串转换为数字123","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":68,"to":82}}}}],["79baa21f-6b41-4c78-8f89-bcfadefdf366",{"pageContent":"- 当 + 两边都有值，且至少一个值是字符串类型，就会出现字符串拼接\n- 当只有 + 后面有值，例如: +\"123\"等同于Number(\"123\")，会将字符串转换为数字123\n\n示例\n```javascript\nconsole.log(\"\" + null);          // \"null\"\nconsole.log(\"\" + undefined);     // \"undefined\"\nconsole.log(\"\" + 123);           // \"123\"\nconsole.log(\"1\" + \"23\");         // \"123\"\nconsole.log(\"\" + [1]);           // \"1\"\nconsole.log(\"\" + {});            // \"[object Object]\"\n```\n\n**转换的过程**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":81,"to":94}}}}],["c8c7effd-da8b-4674-a11b-c66e4f74354a",{"pageContent":"**转换的过程**\n\n- 先调用对象的 Symbol.toPrimitive 这个方法，如果不存在这个方法（结果是undefined），目前已知的只有new Date()有这个方法，\n- 再调用对象的 valueOf 获取原始值，如果获取的不是原始值，\n- 再调用对象的 toString 把其变成字符串\n- 最后再把字符串基于 Number 转换为数字\n\n示例\n```javascript\nconsole.log([] + 1);      \n// `[].valueOf()`没有原始值，再调用`[].toString()`得到`\"\"`，字符串遇到`+`运算符可以进行拼接，就不需要转成数字 => \"1\"\n\nconsole.log([2] - true);  \n// `[].valueOf()`没有原始值，再调用`[].toString()`得到`\"2\"`，再调用`Number(\"2\")`得到数字2。true直接调用`Number(true)`得到1。最后2 - 1 => 1","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":94,"to":107}}}}],["c0a56b08-bc6d-4e43-9852-d0c3d2a6aa16",{"pageContent":"console.log({} + 1);      \n// `{}.valueOf()`没有原始值，再调用`{}.toString()`得到\"[object Object]\"，遇到`+` 号进行字符串拼接 => \"[object Object]1\"\n\nconsole.log({} - 1);      \n// `{}.valueOf()`没有原始值，再调用`{}.toString()`得到\"[object Object]\"，再调用`Number(\"[object Object]\")`得到NaN，最后NaN - 1 => NaN\n```\n\n**结论**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":109,"to":116}}}}],["1f85ebcc-6eaf-4280-a892-6338d7be86dd",{"pageContent":"**结论**\n\n- 对象 == 字符串 | 数字，是把对象转换为字符串或数字，先后进行比较\n- null == undefined，两个等号的情况下是成立的，除此之外，null 和 undefined 和除本身以外的任何值都不相等\n- 对象 == 对象，比较的是堆内存地址，只有地址一样，结果才为 true\n- NaN !== NaN，NaN和任何值都不相等，包括和他自己\n- 除此之外，如果两边的数据类型不一样，全部统一转换为数字类型，然后进行比较\n  \n### 判断数组的方法","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":116,"to":124}}}}],["7f6d490f-a187-42ab-bd68-5afd5c545111",{"pageContent":"- Array.isArray()\n- arr instanseOf Array\n- arr.constructor === Array\n- Array.prototype.isPrototypeOf(arr) B.isPrototypeOf(b) 用于判断B是不是在b对象的原型链上\n- Object.prototype.toString.call(arr) === “[object Array]”\n- Object.getPrototypeOf(arr) === Array.prototype getPrototypeOf 获取当前对象的__proto__\n  \n## 变量作用域、闭包\n\nJS是静态作用域，即函数中变量作用域在程序运行前便已经确定。\n\n### 作用域分类\n\n- 全局作用域 作用于整个JavaScript代码块\n- 局部作用域（函数作用域） 作用于函数内的代码环境，该函数外部不能被访问\n- 块作用域 (es6新增) 块作用域由 { } 包括\n\n**注意**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":126,"to":143}}}}],["b6b8b3e5-cc2b-4cf1-a7e4-55fa68380bb9",{"pageContent":"**注意**\n\n- **如果在函数内定义了和全局变量相同名称的局部变量，那么在函数内部使用就近原则：即在函数内部局部变量起作用**\n- **应尽量避免使用全局变量，以免团队开发变量发生冲突**\n\n**块级作用域（es6新增）**\n\n- 块级作用域内声明的变量只能在块内生效，即 let 和 const 的声明\n- 块级作用域内不允许重复声明变量，但也会存在声明提前，形成暂时性死区\n\n**全局声明的 var 会影响全局变量，但是let 和 const不会**\n\n**作用域链**\n一个块内调用的变量如果不存在，便会往上一个块中去找，从而形成作用域链\n\n### 变量提升\n\n变量提升是 JavaScript 引擎在代码执行前将变量的声明部分提升到作用域的顶部的行为。这意味着可以在变量声明之前使用变量，尽管它们尚未被赋值。\n\n**变量提升的原理**\n\nJavaScript 引擎在代码执行前的编译阶段会对变量和函数进行解析，将它们的声明提升到作用域的顶部。这意味着变量的声明会被提升，但初始化（赋值）不会提升。因此，在使用变量之前，它的声明必须存在于当前作用域中。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":143,"to":164}}}}],["9776e514-eba6-456e-acc4-6e937cba4038",{"pageContent":"**提升范围**：**当前作用域下**\n\n**提升优先级**\n\n- 变量优先（函数需要变量，所以变量优先）\n- 变量、函数同时提升时，变量的优先级更高\n\n**变量提升的影响**\n\n- 变量声明提升 可以在变量声明之前使用变量，避免了在使用变量前必须先声明的限制\n- 值的初始化 尽管变量声明被提升，但变量的赋值操作仍然保留在原来的位置。如果在初始化之前使用变量，其值将为 undefined\n\n**注意事项**\n\n- 始终在作用域的顶部声明变量，以避免混淆和意外的行为\n- 尽量避免依赖变量提升，提倡在使用变量之前先进行声明\n- 使用严格模式（\"use strict\"）可以禁止变量提升，强制遵循更严格的变量声明和使用规范\n  \n### this上下文\n\n**this 是在执行时动态读取上下文所决定的**。\n\n**this 指向总结**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":166,"to":188}}}}],["54c3638f-9e79-48bc-90c5-b621a42de77f",{"pageContent":"**this 是在执行时动态读取上下文所决定的**。\n\n**this 指向总结**\n\n| **调用方式** | **示例** | **函数中 this 指向** |\n| --- | --- | --- |\n| new 调用 | new method() | 新对象 |\n| 直接调用 | method() | 全局对象 window |\n| 通过对象调用 | obj.method() | 前面的对象obj |\n| call | method.call(ctx) | call 的第一个参数 |\n| apply | method.apply(ctx) | apply 的第一个参数 |\n\n**call apply bind 区别**\n\n- call | apply 传参不同， 参数依次传入 | 作为数组传入\n- bind 返回值不同","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":186,"to":201}}}}],["ea39e474-d0cc-4d45-a05e-444508894088",{"pageContent":"**call apply bind 区别**\n\n- call | apply 传参不同， 参数依次传入 | 作为数组传入\n- bind 返回值不同\n\n**手写apply**\n```javascript\nFunction.prototype.myApply = function(context){\n  context = context || window; // 参数兜底\n  if(typeof context !== 'object'){\n    if(typeof context == 'number') context = new Number(context);\n    if(typeof context == 'boolean') context = new Boolean(context);\n    if(typeof context == 'string') context = new String(context);\n  }","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":198,"to":211}}}}],["194f57c3-789e-4a1b-8d2f-95cc5b24aa59",{"pageContent":"let fn = Symbol();\n  context.fn = this;\n  // arguments 就是传进去的参数集合，通过 arguments[1] 得到传进来的数组参数\n  let result;\n  result = arguments[1] ? context.fn(...args) : context.fn();\n\n  delete context.fn;\n  return result;\n}\n```\n\n**手写 bind**\n```javascript\nFunction.prototype.myBind = function() {\n  // 1.1 bind 原理\n  const _this = this;\n  const args = Array.prototype.slice.call(arguments); // 类数组\n  const newThis = args.shift();","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":213,"to":230}}}}],["8613c31a-c16b-46b0-a600-95b2b5dc79bd",{"pageContent":"// 1.2 返回值不执行 => 返回函数\n  return function() {\n    // 执行核心\n    return _this.myApply(newThis, args);\n  }\n}\n```\n\n### 闭包\n闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量。\n\n**特性**\n\n- 函数嵌套函数\n- 函数内部可以引用函数外部的参数和变量\n- 参数和变量不会被垃圾回收机制回收\n\n**闭包的主要形式**\n\n- **函数作为返回值**\n\n示例\n```javascript\nfunction fn() {\n  var a = 100;\n  return function() {\n    var b = 0;\n    console.log(++a);\n    console.log(++b);\n  }\n}\n\nvar fn1 = fn();\nfn1(); // 101  1\nfn1(); // 102  1\n```\n\n- **闭包作为参数传递**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":232,"to":269}}}}],["31c73be8-7dc5-4fea-bea6-47bab4248cbb",{"pageContent":"var fn1 = fn();\nfn1(); // 101  1\nfn1(); // 102  1\n```\n\n- **闭包作为参数传递**\n\n示例\n```javascript\nvar a = 1;\nvar fn = function (x) {\n  if(x > a) {\n    console.log(x);\n  }\n};\n\n(function (fn1) {\n  var a = 100;\n  fn1(10);\n})(fn);// 将 fn 当做参数传入\n```\n**闭包优缺点**\n\n优点\n\n- 保护函数内的变量安全 ，实现封装，防止变量流入其他环境发生命名冲突\n- 在内存中维持一个变量，可以做缓存（但使用多了同时也是一项缺点，消耗内存）\n- 匿名自执行函数可以减少内存消耗\n\n缺点\n\n- 被引用的私有变量不能被销毁，增大了内存消耗，造成内存泄漏，解决方法是可以在使用完变量后手动为它赋值为null；\n- 由于闭包涉及跨域访问，所以会导致性能损失，可以通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响\n  \n## 原型、原型链\n### 原型","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":264,"to":299}}}}],["b5f66f1a-3580-4f3b-b954-d097def16063",{"pageContent":"每个**函数**都会创建一个**prototype属性**，这个属性是一个**对象**，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。\n\n使用原型对象的好处是，在它上面定义的属性和方法都可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型。\n\n**原型是一个对象，为其他对象提供共享属性的对象，又称原型对象**。\n\n不同对象原型存放方式也不同\n\n- **函数**(function) \n  \n  函数是一种特殊的对象，函数的原型存放在**prototype**属性上\n  \n- **对象**(Object) \n  \n  普通对象的原型是存放到内置属性**[[Prototype]]**上，可以通过对象的**__proto__**来访问对象的原型\n\n- **数组**(Array) \n  \n  数组也是一种特殊的对象，但与函数不同的是它的原型和普通对象一样，也是存放到内置属性[[Prototype]]上，可以通过数组的__proto__来访问数组的原型\n\n**构造函数，原型对象和函数实例三者间的关系**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":301,"to":321}}}}],["e4d1ae2a-c0b6-4512-9ae6-270a3ef31318",{"pageContent":"**构造函数，原型对象和函数实例三者间的关系**\n\n![](https://cdn.nlark.com/yuque/0/2024/png/253721/1712025165435-812a3324-f3c9-485f-9780-3f044cd996b3.png#averageHue=%23f7f5ec&clientId=uaeb6cdfd-6227-4&from=paste&id=uaae4c32c&originHeight=628&originWidth=868&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u33f597ec-33ac-49a9-9328-0b028d958b8&title=)\n\n示例\n```javascript\n// 创建一个构造函数\nconst Person = function(){};\n// 创建一个函数实例\nlet user = new Person();","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":321,"to":330}}}}],["7892eafc-b654-4dcd-83b5-66368cf928ee",{"pageContent":"示例\n```javascript\n// 创建一个构造函数\nconst Person = function(){};\n// 创建一个函数实例\nlet user = new Person();\n\nconsole.log(Person.prototype === user.__proto__);  // true\nconsole.log(Person.prototype.constructor === Person);  // true\n```\n\n**总结**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":325,"to":336}}}}],["cd4588a8-4d7e-409e-a744-afd055adf166",{"pageContent":"**总结**\n\n- 函数对象的 prototype 指向的对象便是原型对象，该原型对象的 constructor 属性又指向该函数\n- 只有函数对象和Object才有原型，实例化后的对象都是没有原型对象的\n- 所有的对象实例都有一个私有属性 __proto__\n- 由函数对象生成的实例的 __proto__ 属性指向函数对象的原型对象\n- 由Object对象生成的实例的 __proto__ 属性指向父对象\n- 最终所有的对象 __proto__ 属性都指向 Object.prototype\n- Object.prototype.__proto__ = null\n\n**constructor作用**\n\n- 判断类型\n```javascript\n// 简写方式，最初写法 let arr = new Array(10,20,30);\nlet arr = [10, 20, 30];\nconsole.log(arr.constructor === Array); // true\n```\n\n### 原型链","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":336,"to":355}}}}],["e77c932d-0b53-49bb-9163-24d44f6ea674",{"pageContent":"### 原型链\n\n原型链是通过对象特有的**原型**构成的一种链式结构，主要用来继承多个引用类型的属性和方法。默认情况下，所有引用类型都继承自Object。\n\n**完整的原型链**\n\n![](https://cdn.nlark.com/yuque/0/2024/png/253721/1712025165550-515c62b9-9a7f-452e-bf29-8140a2e3fb70.png#averageHue=%23f7f6f1&clientId=uaeb6cdfd-6227-4&from=paste&id=uf212d05e&originHeight=623&originWidth=1024&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u95daf4f5-65a8-4c95-898e-fcb4e981554&title=)\n\n### new 关键字\n\n**new 关键字做了什么**？","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":355,"to":365}}}}],["57f33a58-dbcb-45e2-a855-be81f98e73ca",{"pageContent":"### new 关键字\n\n**new 关键字做了什么**？\n\n- 首先创建了一个空对象\n- 这个对象的原型 __proto__，指向了这个 函数对象 的prototype\n- 该对象实现了 函数对象 的方法(执行了函数对象的构造函数)；\n- 根据一些特定情况返回对象\n   - 如果这个构造函数没有返回值，或者返回一个非对象类型，则new 最后返回创建的这个对象(this 指向这个新的对象)；\n   - 如果这个构造函数明确返回了一个对象，则返回这个对象(this指向第一步创建的空对象)；\n\nnew 的实现\n```javascript\nfunction newFunc(Fun, ...rest) {\n  if(typeof Fun !== \"function\") {\n    throw new Error('new operator function the frist param must be a function');\n  }","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":363,"to":379}}}}],["480d328c-4f0d-446d-aabb-1b10c1d2223f",{"pageContent":"var obj = Object.create(Fun.prototype);\n  var result = Fun.apply(obj, rest);\n  return result && typeof result === 'object' ? result : obj;\n}\n```\n\n## 面相对象\n### 创建对象的方法\n\n- let obj = {} 直接使用{}\n- let p = new Person() 使用构造函数\n- let obj = new Object({}) 使用new Object\n- let obj = Object.create() 使用Object.create","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":381,"to":393}}}}],["8cd86ced-357e-4324-9a60-d9419e63795d",{"pageContent":"**{} 与 Object.create({}) 对比**\n![](https://cdn.nlark.com/yuque/0/2024/png/253721/1712025165435-763766db-57a4-4258-8b80-a486cc474862.png#averageHue=%23f9f9f9&clientId=uaeb6cdfd-6227-4&from=paste&id=u7a86abb3&originHeight=533&originWidth=1024&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u993f6000-d439-42bf-b7bc-c23e265e8f6&title=)","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":395,"to":396}}}}],["5f12754a-0150-4ced-94ce-0e98b6ec8ef4",{"pageContent":"实现 Object.create\n```javascript\nfunction inherit(p) {\n  if(p === null) throw TypeError();\n  if(Object.create) {\n    return Object.create(p)\n  };\n\n  if( typeof p !== \"object\" && typeof p !== \"function\") throw TypeError();\n\n  function f() {};\n  f.prototype = p;\n  return new f();\n}\n```\n\n### 枚举对象属性的方式\n\n- **for…in**\n  \n  用来遍历对象及其原型链上的所有可枚举属性\n- **Object.keys** \n  \n  用来遍历对象上所有可枚举的属性，但**不包含**原型链上的属性\n- **Object.getOwnProperityNames** \n  \n  返回对象自身包含的所有属性（包含不可枚举的）名称数组，但**不包含**原型链上的\n\n### 继承\n\n继承，是描述类和类之间的关系","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":398,"to":428}}}}],["5ec1d104-e707-4f90-91dc-a57597acec9c",{"pageContent":"### 继承\n\n继承，是描述类和类之间的关系\n\n**继承的分类**\n\n- **原型继承**\n\n重写子对象的原型对象，将其指向父对象实例，缺点是子对象实例修改原型链方法时会影响所有子对象\n\n```javascript\nfunction Parent(name) {\n  this.name = name;\n  this.c = \"parent\"\n}\n\nParent.prototype.getName = function() {\n  console.log(this.name);\n};\n\nfunction Child() {};\n\nChild.prototype = new Parent();\nChild.prototype.constructor = Child;\n```\n\n- **构造函数继承**\n\n在子对象的构造函数中调用父对象的构造函数，并将this传入父对象，缺点是无法继承父对象原型上的属性和方法\n\n```javascript\nfunction Parent(name) {\n  this.name = name;\n}","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":426,"to":459}}}}],["7e504552-59ff-435e-877c-6e3c32a51d7d",{"pageContent":"```javascript\nfunction Parent(name) {\n  this.name = name;\n}\n\nParent.prototype.getName = function() {\n  console.log(this.name);\n};\n\nfunction Child(name) {\n  Parent.call(this, name);\n}\n```\n\n- **组合继承**\n\n使用原型链去继承父对象原型上的属性方法，构造函数继承父对象自己的属性和方法，本质上是在原型链继承的基础上将父对象属性方法复制了一份到子对象实例中\n\n```javascript\nfunction Parent(name) {\n  this.name = name;\n}\n\nParent.prototype.getName = function() {\n  console.log(this.name);\n};\n\nfunction Child(name) {\n  Parent.call(this, name);\n}","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":456,"to":485}}}}],["e4d99aa3-c269-4f98-94ac-ac7f738ea7c8",{"pageContent":"function Child(name) {\n  Parent.call(this, name);\n}\n\n// 问题：我只想构建一个 原型链的关系。\nChild.prototype = new Parent();\n\nChild.prototype.constructor = Child;\n```\n\n- 组合寄生式继承\n  \n```javascript\nfunction Parent(name) {\n  this.name = name;\n}\n\nParent.prototype.getName = function() {\n  console.log(this.name);\n};\n\nfunction Child(name) {\n  Parent.call(this, name);\n}\n\n// 问题：我只想构建一个 原型链的关系。\nChild.prototype = Object.create(Parent.prototype);\nChild.prototype.constructor = Child;\n```\n\n- **extends 继承**\n\nes6 新增的 Class 继承方式","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":483,"to":515}}}}],["86e9ca90-4991-4e2b-8a9c-f8de97bc2b3d",{"pageContent":"- **extends 继承**\n\nes6 新增的 Class 继承方式\n\n**组合寄生和 class 的区别**\n\nLoose 模式应该差不多，主要是这两个区别\n(_loose 模式，babel 进行降级编译的时候，考虑到体积等，只实现核心功能_)\n\n- Class 继承，会继承静态属性\n- 子类中，必须在 constructor中调用 super, 因为子类的 this 对象，必须先通过父类的构造函数完成\n  \n## 事件循环\n\n### 浏览器 JS 异步执行的原理\n\nJS 是单线程的，浏览器是多线程的。当 JS 需要执行异步任务时，浏览器会另外启动一个线程去执行该任务。也就是说，“JS 是单线程的”指的是执行 JS 代码的线程只有一个，是浏览器提供的 **JS 引擎线程**（**主线程**）。浏览器中还有定时器线程和 HTTP 请求线程等，这些线程主要不是来跑 JS 代码的。\n\n浏览器不仅有多个线程，还有多个进程，如渲染进程、GPU 进程和插件进程等。\n\n**渲染进程**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":513,"to":533}}}}],["3042079d-463c-444f-8d7d-3160508f1272",{"pageContent":"浏览器不仅有多个线程，还有多个进程，如渲染进程、GPU 进程和插件进程等。\n\n**渲染进程**\n\n渲染进程下包含了 **JS 引擎线程**、**HTTP 请求线程**、**定时器线程**、**事件触发线程**和**GUI线程**等，这些线程为 JS 在浏览器中完成异步任务提供了基础。\n\n**事件驱动**\n\n浏览器异步任务的执行原理背后其实是一套事件驱动的机制。事件触发、任务选择和任务执行都是由事件驱动机制来完成的。**事件循环其实就是在事件驱动模式中来管理和执行事件的一套流程**。\n\n**浏览器中的事件循环**\n\n**执行栈与任务队列**\n\nJS 解析代码时，会将同步代码按顺序排在某个地方，即**执行栈**，然后依次执行里面的函数。当遇到异步任务时交给其他线程处理，待当前执行栈所有同步代码执行完成后，会从**任务队列**中取出已完成异步任务的回调加入执行栈继续执行，遇到异步任务时又交给其他线程，…..，如此循环往复。而其他异步任务完成后，**将回调放入任务队列中待执行栈来取出执行**。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":531,"to":545}}}}],["685991af-6c60-4c15-a950-ba4ff8061a30",{"pageContent":"![](https://cdn.nlark.com/yuque/0/2024/png/253721/1712025165447-33fb7669-d4ba-4130-90d6-80f93d0f9a02.png#averageHue=%23ede6d7&clientId=uaeb6cdfd-6227-4&from=paste&id=u7dfcf329&originHeight=288&originWidth=720&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u1962f95d-a611-4ad7-9e93-18851fc96ea&title=)\n\n在事件驱动的模式下，至少包含了一个执行循环来检测任务队列是否有新的任务。通过不断循环去取出异步回调来执行，这个过程就是**事件循环**，**而每一次循环就是一个事件周期或称为一次 tick**。\n\n**宏任务和微任务**\n\n任务队列不只一个，根据任务的种类不同，可以分为**微任务**队列和**宏任务**队列。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":547,"to":553}}}}],["88eac97b-65fb-44a9-8cf5-a031204b8170",{"pageContent":"**宏任务和微任务**\n\n任务队列不只一个，根据任务的种类不同，可以分为**微任务**队列和**宏任务**队列。\n\n事件循环的过程中，执行栈执行完成后，优先检查微任务队列是否有任务需要执行，如果没有，再去宏任务队列检查是否有任务执行。微任务一般在当前循环就会优先执行，而宏任务会等到下一次循环，**因此，微任务一般比宏任务先执行，并且微任务队列只有一个，宏任务队列可能有多个**。\n\n**常见宏任务**\n\n- setTimeout()\n- setInterval()\n- setImmediate()\n\n**常见微任务**\n\n- promise.then()、promise.catch()\n- new MutaionObserver()\n- process.nextTick()\n\n_**在浏览器中 setTimeout 的延时设置为 0 的话，会默认为 4ms，NodeJS 为 1ms。具体值可能不固定，但不是为 0**_。\n\n**_浏览器的渲染视图是在微任务执行完成之后，宏任务执行之前_**\n\n代码执行动画过程","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":551,"to":573}}}}],["b7f57aac-6444-4026-90d3-6e273af2bd51",{"pageContent":"**_浏览器的渲染视图是在微任务执行完成之后，宏任务执行之前_**\n\n代码执行动画过程\n\n![](https://cdn.nlark.com/yuque/0/2024/gif/253721/1712025165296-ad3a0687-db65-48b3-a77c-2d1f220fd54e.gif#averageHue=%235a5959&clientId=uaeb6cdfd-6227-4&from=paste&id=ue02f5e4d&originHeight=450&originWidth=783&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u308ffb67-8f57-4233-87a5-98b93b11276&title=)\n\n- **宏任务特征**：有明确的异步任务需要执行和回调；需要其他异步线程支持\n- **微任务特征**：没有明确的异步任务需要执行，只有回调；不需要其他异步线程支持\n  \n### NodeJS 中的事件循环\n\n**异步方法**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":571,"to":582}}}}],["599802d5-6005-4ff1-b10d-912a7a570b54",{"pageContent":"**异步方法**\n\n- 文件 I/O 异步加载本地文件\n- setImmediate() 与 setTimeout 设置 0ms 类似，在某些同步任务完成后立马执行\n- process.nextTick() 在某些同步任务完成后立马执行\n- server.close、socket.on(‘close’,…）等 关闭回调\n\n**事件循环模型**\n\n**NodeJS 的事件循环主要是在 Libuv 中完成的**。\n\n**事件循环各阶段**\n\n- **timers 阶段**\n  \n  执行所有 setTimeout() 和 setInterval() 的回调\n\n- **pending callbacks 阶段**\n  \n  某些系统操作的回调，如 TCP 链接错误。除了 timers、close、setImmediate 的其他大部分回调在此阶段执行","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":582,"to":601}}}}],["a4864998-dcc0-4e8a-9d9b-88ee187c738b",{"pageContent":"- **pending callbacks 阶段**\n  \n  某些系统操作的回调，如 TCP 链接错误。除了 timers、close、setImmediate 的其他大部分回调在此阶段执行\n\n- **poll 阶段**\n  \n  轮询等待新的链接和请求等事件，执行 I/O 回调等。V8 引擎将 JS 代码解析并传入 Libuv 引擎后首先进入此阶段。如果此阶段任务队列已经执行完了，则进入 check 阶段执行 setImmediate 回调（如果有 setImmediate），或等待新的任务进来（如果没有 setImmediate）。在等待新的任务时，如果有 timers 计时到期，则会直接进入 timers 阶段。此阶段可能会阻塞等待\n\n- **check 阶段**\n  \n  setImmediate 回调函数执行\n\n- **close callbacks 阶段**\n  \n  关闭回调执行，如 socket.on(‘close’, …)","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":599,"to":613}}}}],["c6904bcd-7dce-4b93-968c-303862dd593d",{"pageContent":"- **close callbacks 阶段**\n  \n  关闭回调执行，如 socket.on(‘close’, …)\n\n![](https://cdn.nlark.com/yuque/0/2024/png/253721/1712025166499-4e1fa855-6b2a-4581-b812-e349a21c2752.png#averageHue=%23a5b2c1&clientId=uaeb6cdfd-6227-4&from=paste&id=ub6dae04b&originHeight=347&originWidth=720&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u8d1ac411-ad28-4abf-a86b-c345f2e5234&title=)\n\n上面每个阶段都会去执行完当前阶段的任务队列，然后继续执行当前阶段的微任务队列，只有当前阶段所有微任务都执行完了，才会进入下个阶段。\n\n## 垃圾回收GC\n\n### 堆和栈\n\n**数据的存储方式**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":611,"to":623}}}}],["7e979159-a7ff-4c8e-8962-2c069f0a2c26",{"pageContent":"上面每个阶段都会去执行完当前阶段的任务队列，然后继续执行当前阶段的微任务队列，只有当前阶段所有微任务都执行完了，才会进入下个阶段。\n\n## 垃圾回收GC\n\n### 堆和栈\n\n**数据的存储方式**\n\n- 栈内存 线性有序存储，容量小，系统分配效率高。（存放原始类型）\n- 堆内存 首先要在堆内存新分配存储区域，之后又要把指针存储到栈内存中，效率相对低一些（存放引用类型的值）\n  \n### 垃圾回收分类\n\n因为数据是存储在栈和堆两种内存空间中的，所以浏览器的垃圾回收机制根据数据的存储方式分为 “**栈垃圾回收**” 和 “**堆垃圾回收**”。\n\n**栈垃圾回收**\n\n当一个函数执行结束之后，JS引擎通过向下移动ESP指针（记录调用栈当前执行状态的指针），来销毁该函数保存在栈中的执行上下文（变量环境、词法环境、this、outer），遵循先进后出的原则。\n\n**堆垃圾回收**\n\n当函数执行结束，栈空间处理完成了，但是堆空间的数据虽然没有被引用，但还是存储在堆空间中，需要垃圾回收器将堆空间中的垃圾数据回收。\n\n### 垃圾回收的方法\n\n- **标记清除法** \n- **引用计数法**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":617,"to":643}}}}],["0f013c54-4ba6-4167-8add-6d41a541865a",{"pageContent":"### 垃圾回收的方法\n\n- **标记清除法** \n- **引用计数法**\n\n**标记清除法**\n\n- 垃圾收集器在运行时会给内存中的所有变量都加上一个标记\n- 然后从各个根对象开始遍历，把还在被上下文变量引用的变量标记去掉标记\n- 清理所有带有标记的变量，销毁并回收它们所占用的内存空间\n- 最后垃圾回收程序做一次内存清理\n\n标记整理\n\n标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存。\n\n**引用计数法**\n\n跟踪记录每个值被引用的次数，每次引用加一，被释放时减一，当这个值的引用次数变成0时，就可以将其内存空间回收。**但是当出现循环引用的时候，会导致内存泄露**。\n\n**注意**\n\n使用 let 和 const 可以将变量限制在较小的块级作用域中，有利于垃圾回收。\n\n**检查内存泄露的方式**\n\n- 查看任务管理器\n- 使用开发者工具中的 Performance 模块","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/JavaScript基础.mdx","loc":{"lines":{"from":640,"to":667}}}}],["6e38e796-c102-4f69-84eb-c86b433f1cea",{"pageContent":"---\ntitle: WEB安全基础\ndate: '2024-05-01'\ntags: ['WEB安全']\ndraft: false\nsummary: WEB安全需掌握的基础知识\n---\n\n## 同源策略\n### 同源概念\n\n同源策略是一个重要的安全策略，它用于限制一个**origin**的文档或它加载的脚本如何能与另一个源的资源进行交互。能够减少恶意文档，减少可能被攻击的媒介。\n\n**如果两个URL的协议、域名、端口号都相同，就称这两个URL同源。**\n\n默认情况下，浏览器支持跨域写和跨域资源嵌入，但**不支持跨域读**。\n\n**script 、img、iframe、link、a** 等标签不受同源策略限制，**带src属性的标签每次加载的时候,实际上都是浏览器发起一次GET请求**。\n\n### 跨域解决方案\n#### document.domain + iframe (只有在主域相同的时候才可以使用)","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/WEB安全基础.mdx","loc":{"lines":{"from":1,"to":21}}}}],["ff51628b-be55-4b95-89c4-cc91291d3f9a",{"pageContent":"### 跨域解决方案\n#### document.domain + iframe (只有在主域相同的时候才可以使用)\n\n在 a.com/a.html 中\n```javascript\ndocument.domain = 'a.com';\nvar ifr = document.createElement('iframe');\nifr.src = 'http://www.script.a.com/b.html';\nifr.display = none;\ndocument.body.appendChild(ifr);\nifr.onload = function(){\n  var doc = ifr.contentDocument || ifr.contentWindow.document;\n  //在这里操作doc，也就是b.html\n  ifr.onload = null;\n};\n```\n\n在 script.a.com/b.html 中\n```javascript\ndocument.domain = 'a.com';\n```\n\n#### 动态创建script","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/WEB安全基础.mdx","loc":{"lines":{"from":20,"to":42}}}}],["35461804-be70-4659-b8ee-17b7df42c455",{"pageContent":"在 script.a.com/b.html 中\n```javascript\ndocument.domain = 'a.com';\n```\n\n#### 动态创建script\n\n```javascript\nfunction loadScript(url, func) {\n  var head = document.head || document.getElementByTagName('head')[0];\n  var script = document.createElement('script');\n  script.src = url;","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/WEB安全基础.mdx","loc":{"lines":{"from":37,"to":48}}}}],["082b98fc-f9c9-4614-ba1a-d5fdd064a22a",{"pageContent":"script.onload = script.onreadystatechange = function(){\n    if(!this.readyState || this.readyState=='loaded' || this.readyState=='complete'){\n      func();\n      script.onload = script.onreadystatechange = null;\n    }\n  };\n\n  head.insertBefore(script, 0);\n}\nwindow.baidu = {\n  sug: function(data){\n    console.log(data);\n  }\n}\nloadScript('http://suggestion.baidu.com/su?wd=w',function(){console.log('loaded')});\n//我们请求的内容在哪里？\n//我们可以在chorme调试面板的source中看到script引入的内容\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/WEB安全基础.mdx","loc":{"lines":{"from":50,"to":67}}}}],["ed2d5547-3c65-49dd-84df-72151902fd07",{"pageContent":"#### location.hash + iframe\n\n原理是利用location.hash来进行传值。\n\n假设域名** a.com** 下的文件 **a1.html** 要和 **blog.com** 域名下的 **blog2.html** 传递信息。\n\n- a1.html首先创建一个隐藏的 iframe，iframe 的 src 指向 blog.com 域名下的 blog2.html 页面\n- blog2.html 响应请求后再将通过修改 a1.html 的 **hash** 值来传递数据\n- 同时在 a1.html 上加一个定时器，隔一段时间来判断 location.hash 的值有没有变化，一旦有变化则获取获取 hash 值","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/WEB安全基础.mdx","loc":{"lines":{"from":69,"to":77}}}}],["0ce6490a-37f7-405c-abc7-b8c764823de4",{"pageContent":"**a1.html**\n```javascript\nfunction startRequest(){\n  var ifr = document.createElement('iframe');\n  ifr.style.display = 'none';\n  ifr.src = 'http://www.blog.com/blog2.html#paramdo';\n  document.body.appendChild(ifr);\n}\n\nfunction checkHash() {\n  try {\n    var data = location.hash ? location.hash.substring(1) : '';\n    if (console.log) {\n      console.log('Now the data is '+data);\n    }\n  } catch(e) {};\n}\nsetInterval(checkHash, 2000);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/WEB安全基础.mdx","loc":{"lines":{"from":79,"to":97}}}}],["c6d36054-2f87-47fd-98b0-edc08f5a85b0",{"pageContent":"**blog2.html**\n```javascript\n//模拟一个简单的参数处理操作\nswitch(location.hash){\n  case '#paramdo':\n    callBack();\n    break;\n  case '#paramset':\n    //do something……\n    break;\n}","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/WEB安全基础.mdx","loc":{"lines":{"from":99,"to":109}}}}],["8c1c0c35-962a-4c78-8a72-a518f2c279d4",{"pageContent":"function callBack(){\n  try {\n    parent.location.hash = 'somedata';\n  } catch (e) {\n    // ie、chrome的安全机制无法修改parent.location.hash，\n    // 所以要利用一个中间的cnblogs域下的代理iframe\n    var ifrproxy = document.createElement('iframe');\n    ifrproxy.style.display = 'none';\n    ifrproxy.src = 'http://www.a.com/a3.html#somedata';    // 注意该文件在\"a.com\"域下\n    document.body.appendChild(ifrproxy);\n  }\n}\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/WEB安全基础.mdx","loc":{"lines":{"from":111,"to":123}}}}],["8a3e5dd8-27d5-4be9-a08d-45cc5b8145f5",{"pageContent":"**a.com 域名下的 a3.html**\n```javascript\n//因为parent.parent和自身属于同一个域，所以可以改变其location.hash的值\nparent.parent.location.hash = self.location.hash.substring(1);\n```\n\n#### window.name + iframe\n\nwindow.name 的优点：\n\nname 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。\n\n1) 创建a1.html\n2) 创建 proxy.html ，并加入如下代码","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/WEB安全基础.mdx","loc":{"lines":{"from":125,"to":138}}}}],["5079a73c-3abc-4420-96ca-07502775e9f0",{"pageContent":"```html\n<head>\n  <script>\n    function proxy(url, func){\n      var isFirst = true,\n        ifr = document.createElement('iframe'),\n        loadFunc = function(){\n          if(isFirst){\n            ifr.contentWindow.location = 'http://a.com/a1.html';\n            isFirst = false;\n          }else{\n            func(ifr.contentWindow.name);\n            ifr.contentWindow.close();\n            document.body.removeChild(ifr);\n            ifr.src = '';\n            ifr = null;\n          }\n        };","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/WEB安全基础.mdx","loc":{"lines":{"from":140,"to":157}}}}],["0d658cac-2394-4a73-8056-cbf88c93518b",{"pageContent":"ifr.src = url;\n      ifr.style.display = 'none';\n      if(ifr.attachEvent) ifr.attachEvent('onload', loadFunc);\n      else ifr.onload = loadFunc;\n\n      document.body.appendChild(iframe);\n    }\n  </script>\n</head>\n<body>\n  <script>\n    proxy('http://www.baidu.com/', function(data){\n      console.log(data);\n    });\n  </script>\n</body>\n```\n\n在 b.com/b1.html 中包含：\n```html\n<script>\n  window.name = '要传送的内容';\n</script>\n```\n\n#### postMessage","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/WEB安全基础.mdx","loc":{"lines":{"from":159,"to":184}}}}],["2ebc185a-2d47-4fb7-9fce-037afaa59c38",{"pageContent":"在 b.com/b1.html 中包含：\n```html\n<script>\n  window.name = '要传送的内容';\n</script>\n```\n\n#### postMessage\n\na.com/index.html\n```html\n<iframe id=\"ifr\" src=\"b.com/index.html\"></iframe>\n<script type=\"text/javascript\">\n  window.onload = function() {\n    var ifr = document.getElementById('ifr');\n    var targetOrigin = 'http://b.com';  \n    // 若写成'http://b.com/c/proxy.html'效果一样\n    // 若写成'http://c.com'就不会执行postMessage了\n    ifr.contentWindow.postMessage('I was there!', targetOrigin);\n  };\n</script>\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/WEB安全基础.mdx","loc":{"lines":{"from":177,"to":198}}}}],["8473ffa0-53a4-405f-af35-6d489c63d132",{"pageContent":"b.com/index.html\n```html\n<script type=\"text/javascript\">\n  window.addEventListener('message', function(event){\n    // 通过origin属性判断消息来源地址\n    if (event.origin == 'http://a.com') {\n      alert(event.data);    // 弹出\"I was there!\"\n      alert(event.source);  \n      // 对a.com、index.html中window对象的引用, 但由于同源策略，这里event.source不可以访问window对象\n    }\n  }, false);\n</script>\n```\n\n#### CORS\n\nCORS是一个 **W3C标准** ，全称是”跨域资源共享”。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/WEB安全基础.mdx","loc":{"lines":{"from":200,"to":216}}}}],["ebb2190b-4ab3-4ee5-b085-18bc796a71f9",{"pageContent":"#### CORS\n\nCORS是一个 **W3C标准** ，全称是”跨域资源共享”。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。\n\n实现CORS通信的关键是服务器，只要服务器实现了CORS接口，就可以跨源通信。\n\n**a.简单请求**\n\n对于简单请求，浏览器直接发出CORS请求，在头信息之中，增加一个**Origin**字段。服务器判断 **origin** 是否在许可范围内。\n\n**在许可范围内**，响应头会添加如下信息返回：\n\n- Access-Control-Allow-Origin(必须)：表明接受什么域名\n- Access-Control-Allow-Credentials:是否允许发送cookie\n- Access-Control-Expose-Headers：是否暴露其他headers值\n\n**Origin 不在许可范围内，返回跨域报错信息**\n\n**b.非简单请求**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/WEB安全基础.mdx","loc":{"lines":{"from":214,"to":232}}}}],["e2c3552d-68d8-42b9-8410-08dec67956e8",{"pageContent":"**Origin 不在许可范围内，返回跨域报错信息**\n\n**b.非简单请求**\n\n非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是 **application/json**。\n\n对于非简单请求，浏览器会先发送一次预检请求，请求方式为 OPTIONS，头信息会携带 Origin 字段，及以下信息：\n\n- Access-Control-Request-Method 列出CORS会用到哪些方法\n- Access-Control-Request-Headers 额外的头信息字段\n\n预检请求通过后，后续处理与简单请求一致。\n\n#### JSONP\n\nJSONP利用 script 标签的同源策略，突破浏览器的同源策略限制，实现跨域请求。\nJSONP包含两部分：","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/WEB安全基础.mdx","loc":{"lines":{"from":230,"to":246}}}}],["1868c2ae-3025-4d03-b5a5-cf78111b871a",{"pageContent":"预检请求通过后，后续处理与简单请求一致。\n\n#### JSONP\n\nJSONP利用 script 标签的同源策略，突破浏览器的同源策略限制，实现跨域请求。\nJSONP包含两部分：\n\n- 回调函数 当响应到来时要放在当前页面被调用的函数\n- 数据 传入回调函数中的json数据，也就是回调函数的参数\n  \n```javascript\nfunction handleResponse(response){\n  console.log('The responsed data is: '+response.data);\n}\nvar script = document.createElement('script');\nscript.src = 'http://www.baidu.com/json/?callback=handleResponse';\ndocument.body.insertBefore(script, document.body.firstChild);\n/*handleResonse({\"data\": \"zhe\"})*/","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/WEB安全基础.mdx","loc":{"lines":{"from":241,"to":258}}}}],["3510a998-aaf8-4067-9f8e-d3f1d5e1d89c",{"pageContent":"// 原理如下：\n// 当通过 script 标签请求时，后台就会根据相应的参数(json, handleResponse)来生成相应的json 数据(handleResponse({\"data\": \"zhe\"}))\n// 最后这个返回的json数据(代码)就会被放在当前js文件中被执行，至此跨域通信完成\n```\n\n缺点\n\n- 只能发送 GET 一种请求\n- 安全性 返回的数据是明文的，没有经过任何的加密或编码，容易被恶意攻击者获取并利用\n- 要确定 jsonp 请求是否失败并不容易\n  \n#### Web Sockets\n\nWeb Sockets 是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用)。\n\n**原理**\n\n在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用 HTTP 升级 从HTTP 协议转换为 web sockt 协议。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/WEB安全基础.mdx","loc":{"lines":{"from":260,"to":277}}}}],["18d9c37c-c2b5-47b1-9abf-b78127770c2a",{"pageContent":"在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用 HTTP 升级 从HTTP 协议转换为 web sockt 协议。\n\n**只有在支持web socket协议的服务器上才能正常工作**。\n```javascript\nvar socket = new WebSockt('ws://www.baidu.com');//http->ws; https->wss\nsocket.send('hello WebSockt');\nsocket.onmessage = function(event){\n  var data = event.data;\n}\n```\n\n## XSS\nXSS是一种常见的安全漏洞，它允许攻击者在受害者浏览器上执行恶意脚本。攻击者通过在网页中注入恶意代码，使得用户浏览该页面时，恶意代码会被执行。\n\n**XSS的分类**\n\n- **存储型 XSS** \n  \n  攻击者将恶意代码存储到目标网站的数据库中，当其他用户浏览相关页面时，恶意代码会从服务器上返回并在用户的浏览器中执行","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/WEB安全基础.mdx","loc":{"lines":{"from":277,"to":295}}}}],["355d1d84-fdad-4742-bac9-8c864e3f4a15",{"pageContent":"**XSS的分类**\n\n- **存储型 XSS** \n  \n  攻击者将恶意代码存储到目标网站的数据库中，当其他用户浏览相关页面时，恶意代码会从服务器上返回并在用户的浏览器中执行\n\n- **反射型 XSS**\n  \n  攻击者通过构造带有恶意代码的URL，并诱导用户点击该链接，服务器接收到请求后，将恶意代码反射回用户的浏览器并执行\n\n- **DOM 型 XSS**\n  \n  攻击者利用网页的 DOM（文档对象模型）结构漏洞，修改了网页的内容，使得恶意代码被执行\n\n**常见的防御策略**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/WEB安全基础.mdx","loc":{"lines":{"from":291,"to":305}}}}],["5e850736-3539-40a9-9dac-8b5d91a2e019",{"pageContent":"- **DOM 型 XSS**\n  \n  攻击者利用网页的 DOM（文档对象模型）结构漏洞，修改了网页的内容，使得恶意代码被执行\n\n**常见的防御策略**\n\n- 对用户输入做好过滤和转义处理，避免被直接执行作为脚本代码。开发者可以使用一些现成的库和框架来实现数据过滤和转义，例如OWASP ESAPI、JQuery等\n- 在请求中包含 **HTTPOnly** 标记的cookie，避免 JavaScript 脚本获取 Cookie 值\n- 配置 **CSP** 头部，限制页面资源的加载和执行，减少 XSS 攻击的可能性\n- 使用**低特权账号**和**权限分离策略**，避免敏感操作的恶意执行和篡改页面内容\n- 对于发生XSS攻击的网站，及时清除和恢复受影响的数据，同时加强监控和日志审计，快速发现异常情况并进行处理\n\n**CSP 内容安全策略**\n\nCSP（内容安全策略）是一种额外的安全层，可以帮助检测和减轻某些类型的攻击，如跨站脚本攻击（XSS）和数据注入攻击。\n\nCSP允许网站管理员定义哪些动态资源允许执行和加载，有助于防止恶意脚本执行以及非授权内容的加载。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/WEB安全基础.mdx","loc":{"lines":{"from":301,"to":317}}}}],["6c45e1b7-b763-4149-aa1d-150d0b59450f",{"pageContent":"CSP允许网站管理员定义哪些动态资源允许执行和加载，有助于防止恶意脚本执行以及非授权内容的加载。\n\n通过HTTP头部设置 **Content-Security-Policy** 或者 设置 **meta**，网站可以控制用户代理如何执行页面的特定部分，这可以显著减少XSS攻击的风险。\n\n**常见指令**\n\n- **default-src** \n  \n  设置默认加载资源的策略（比如 自身的源、任何地方的源、或不加载任何外部资源）\n\n- **script-src**\n  \n  定义哪些脚本可以执行, 例如script标签, a标签的JavaScript:location.href=”” 等.\n\n- **style-src**\n  \n  定义哪些样式表可以加载。\n\n- **img-src**\n  \n  定义哪些图片资源可以加载。\n\n- **connect-src** \n  \n  限制可以通过脚本接口进行连接的URL（例如，AJAX 请求、WebSocket）。\n\n- **font-src**\n  \n  定义哪些字体资源可以加载。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/WEB安全基础.mdx","loc":{"lines":{"from":317,"to":345}}}}],["27b5c667-6701-4636-9c8c-d381a33a8c95",{"pageContent":"- **font-src**\n  \n  定义哪些字体资源可以加载。\n\n- **object-src**\n  \n  限制可以加载哪些插件。\n\n- **media-src**\n  \n  定义哪些媒体资源（音频和视频）可以加载。\n\n- **frame-src**\n  \n  定义哪些iframe可以加载。\n\n## CSRF\n\nCSRF(**跨站请求伪造**)，是一种对网站的恶意利用，通过伪装来自受信任用户的请求来利用受信任的网站。\n\n原理是攻击者构造网站后台某个功能接口的请求地址，诱导用户去点击或者用特殊方法让该请求地址自动加载。用户在登录状态下这个请求被服务端接收后会被误以为是用户合法的操作。对于 GET 形式的接口地址可轻易被攻击，对于 POST 形式的接口地址也不是百分百安全，攻击者可诱导用户进入带 Form 表单可用POST方式提交参数的页面。\n\n**攻击方式**\n\n主要包含：img标签等src属性、form标签的action、a标签的href\n\n**防范措施**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/WEB安全基础.mdx","loc":{"lines":{"from":343,"to":369}}}}],["3b07a482-b8a2-4a39-a1ad-df5be56ee97f",{"pageContent":"**攻击方式**\n\n主要包含：img标签等src属性、form标签的action、a标签的href\n\n**防范措施**\n\n- **随机令牌** \n  \n  每次向目标网站发送请求时，都要携带一个随机生成的令牌（Token），目标网站在处理请求时会校验该令牌的有效性，如果无效则拒绝请求\n\n- **Referer 校验**\n  \n  在处理请求时，校验请求的 Referer 头部信息，确保请求来源是合法的\n\n- **SameSite Cookie** \n  \n  在设置 Cookie 时，指定 Cookie 的 SameSite 属性为 Strict 或 Lax，以限制 Cookie 的跨站访问\n\nSameSite Cookie 设置值含义\n\n- **Strict**\n  \n  仅允许同站点访问，禁止任何跨站访问\n\n- **Lax**\n  \n  允许一定程度的跨站访问，例如链接跳转等，但禁止一些敏感操作的跨站访问\n\n## SQL注入","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/WEB安全基础.mdx","loc":{"lines":{"from":365,"to":393}}}}],["98dbcca0-3130-44cd-9308-4daaeb16934b",{"pageContent":"- **Strict**\n  \n  仅允许同站点访问，禁止任何跨站访问\n\n- **Lax**\n  \n  允许一定程度的跨站访问，例如链接跳转等，但禁止一些敏感操作的跨站访问\n\n## SQL注入\n\nSQL注入漏洞主要形成的原因是在数据交互中，**前端的数据传入到后台处理时，没有做严格的判断，导致其传入的“数据”拼接到SQL语句中后，被当作SQL语句的一部分执行， 从而导致数据库受损（被脱裤、被删除、甚至整个服务器权限沦陷）**。\n\nSQL注入的防范\n\n- 对传进SQL语句里面的变量进行过滤，不允许危险字符传入\n- 使用参数化（Parameterized Query 或 Parameterized Statement）\n\n注意事项","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/WEB安全基础.mdx","loc":{"lines":{"from":385,"to":402}}}}],["517fc8a7-1b9f-46bb-8b6f-79f772a81984",{"pageContent":"- 对传进SQL语句里面的变量进行过滤，不允许危险字符传入\n- 使用参数化（Parameterized Query 或 Parameterized Statement）\n\n注意事项\n\n- 永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和双”-“进行转换等。\n- 永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。\n- 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。\n- 不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。\n- 应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装\n  \n## SSO单点登录\n\n单点登录，简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有**相互信任**的应用系统（例如淘宝、天猫之间的关系）。**简而言之，多个系统，统一登陆。**\n\n### **CAS**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/WEB安全基础.mdx","loc":{"lines":{"from":399,"to":414}}}}],["f30df21e-6860-4436-ace1-fcb0c482d97e",{"pageContent":"### **CAS**\n\nCAS 是 Yale 大学发起的一个企业级的、开源的项目，旨在为 Web 应用系统提供一种可靠的单点登录解决方法（SSO的一种框架）。\n\nCAS 包括两部分：CAS Server 和 CAS Client。\n\n- CAS Server 负责完成对用户的认证工作 , 需要独立部署\n- CAS Client 负责处理对客户端受保护资源的访问请求，需要对请求方进行身份认证时，重定向到 CAS Server 进行认证\n  \n### 实现方式\n\n**1、同域SSO**\n没有设置独立的 SSO 服务器，因为业务后台服务器本身就足以承担 SSO 的职能\n\n**2、同父域SSO**\n和同域SSO不同在于，服务器在返回 cookie 的时候，要把cookie 的 domain 设置为其父域\n\n**3、跨域SSO（CAS）**\n设置专门SSO服务器，当两个产品不同域时，cookie 无法共享，因此就需要搭建SSO服务器\n\n### CAS票据\n\n**1. TGT (Ticket Grangting Ticket) :**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/WEB安全基础.mdx","loc":{"lines":{"from":414,"to":436}}}}],["8b101e71-9b05-4e17-9b6b-0d1daea13e5f",{"pageContent":"### CAS票据\n\n**1. TGT (Ticket Grangting Ticket) :**\n\nTGT 是 CAS 为用户签发的登录票据，拥有了 TGT，用户就可以证明自己在 CAS 成功登录过。TGT 封装了 Cookie 值以及此 Cookie 值对应的用户信息。\n\n**2.TGC(Ticket Granting Cookie) :**\n\nCAS Server 生成TGT放入自己的 Session 中，而 TGC 就是这个 Session 的唯一标识（SessionId），以 Cookie 形式放到浏览器端。\n\n**3.ST(Service Ticket) :**\n\nST 是 CAS 为用户签发的访问某一 service 的票据。用户访问 service 时，service 发现用户没有 ST，则要求用户去 CAS 获取 ST。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/WEB安全基础.mdx","loc":{"lines":{"from":434,"to":446}}}}],["4c7c20ae-420e-4c66-839b-3a0865b0beb2",{"pageContent":"---\ntitle: Agent 基础\ndate: '2024-06-02'\ntags: ['AI大模型', 'Agent', 'Node.js']\ndraft: false\nsummary: 了解 Agents 基础知识，及 Function calling 调用外部 API 的相关能力。\n---\n\n## Function calling\n\nFunction calling 本质上就是给 LLM 了解和调用外界函数的能力，LLM 会根据他的理解，在合适的时间返回对函数的调用和参数，然后根据函数调用的结果进行回答。\n\n获取天气是非常经典的使用案例，需要实时获取外部 API 的返回结果，LLM 无法独立回答。这里使用 OpenAI 官方库来实现访问 DashScope 服务上的千问模型：\n\n```js\n  import OpenAI from \"openai\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":1,"to":16}}}}],["bf985ca5-68e7-47dd-9c4c-01d09c37d6f7",{"pageContent":"```js\n  import OpenAI from \"openai\";\n\n  const openai = new OpenAI({\n    apiKey: env[\"ALIBABA_API_KEY\"],\n    baseURL: `https://dashscope.aliyuncs.com/compatible-mode/v1`,\n  });\n```\n\n创建一个假的获取天气的函数：\n```js\n  function getCurrentWeather({ location, unit=\"fahrenheit\"}){\n    const  weather_info = {\n      \"location\": location,\n      \"temperature\": \"72\",\n      \"unit\": unit,\n      \"forecast\": [\"sunny\", \"windy\"],\n    }\n    return JSON.stringify(weather_info);\n  }\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":15,"to":35}}}}],["73f0a023-67c8-49a7-b37a-a2bf12cf914c",{"pageContent":"创建函数的描述信息 tools：\n```js\n  // OpenAI 官方 API 指定的格式\n  const tools = [\n    {\n      type: \"function\",\n      function: {\n        name: \"getCurrentWeather\",\n        description: \"获取指定地点的天气信息\",\n        parameters: {\n          type: \"object\",\n          properties: {\n            location: {\n              type: \"string\",\n              description: \"城市和地点\",\n            },\n            unit: { type: \"string\", enum: [\"celsius\", \"fahrenheit\"] },\n          },\n          required: [\"location\"],\n        },","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":37,"to":56}}}}],["932c7262-f5f7-4784-9906-080f3d54277f",{"pageContent":"},\n          required: [\"location\"],\n        },\n      },\n    }\n  ]\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":54,"to":60}}}}],["a51e999e-9bea-475d-80bb-8fbab12d5161",{"pageContent":"上面是 OpenAI 官方 API 指定的格式：\n- type： \"function\" 目前只支持值为 function，必须指定\n- function： 对具体函数的描述\n- name：函数名, 需要跟函数的名称一致，方便后续实现对函数名的调用\n- descirption： 函数的描述，可以理解成对 LLM 决定是否调用该函数的唯一信息，这部分清晰的表达函数的效果\n- parameters： 函数的参数，OpenAI 使用的是通用的 JSON Schema 去描述函数的各个参数，这里使用了数组作为参数的输入，其中有两个 key \n  - location： string 值表示位置 \n  - unit： 表示请求的单位\n- required： 通过这个 key 告知 LLM 该参数是必须的\n\n调用 LLM 的 tools 功能：\n```js\n  const messages = [\n    {\n      \"role\": \"user\",\n      \"content\": \"上海的天气怎么样\"\n    }\n  ];","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":62,"to":79}}}}],["7f47bab2-65d5-4614-b331-358f1dbe5251",{"pageContent":"const result = await openai.chat.completions.create({\n    model: 'qwen-plus',\n    messages,\n    tools,\n  });\n\n  console.log(result.choices[0]);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":81,"to":88}}}}],["e82911f6-5f55-4edf-97fc-71271c308b38",{"pageContent":"输出内容如下：\n```js\n  {\n    message: {\n      role: \"assistant\",\n      tool_calls: [\n        {\n          function: {\n            name: \"getCurrentWeather\",\n            arguments: '{\"properties\": {\"location\": {\"description\": \"上海\", \"type\": \"string\"}, \"unit\": {\"enum\": [\"celsius\", \"f'... 76 more characters\n          },\n          id: \"\",\n          type: \"function\"\n        }\n      ],\n      content: \"\"\n    },\n    finish_reason: \"tool_calls\",\n    index: 0,\n    logprobs: null\n  }\n```\n\n### 控制 LLM 调用函数的行为","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":90,"to":113}}}}],["50629b65-4b87-4776-a81e-d9cb3e447822",{"pageContent":"### 控制 LLM 调用函数的行为\n\ntools 另一个可选的参数是 tool_choice，可选值如下：\n\n- none： 表示禁止 LLM 使用任何函数, 也就是无论用户输入什么, LLM 都不会调用函数\n- auto： 表示让 LLM 自己决定是否使用函数，也就是 LLM 的返回值可能是函数调用, 也可能正常的信息，而最后一种, 就是指定一个函数, 让 LLM 强制使用该函数, 其类型是一个 object, 有两个属性\n- type： 目前只能指定为 function\n- function：其值是一个对象, 有且仅有一个 key name 为函数名称 例如\n\n```js\n  {\n    \"type\": \"function\", \n    \"function\": {\n      \"name\": \"my_function\"\n    }\n  }\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":113,"to":129}}}}],["d5d98e59-d310-40c8-b00f-1f4f1b967f37",{"pageContent":"```js\n  {\n    \"type\": \"function\", \n    \"function\": {\n      \"name\": \"my_function\"\n    }\n  }\n```\n\n配置示例，禁止 LLM 去调用函数：\n```js\n  const result = await openai.chat.completions.create({\n    model: '',\n    messages,\n    tools,\n    tool_choice: \"none\"\n  });\n```\n\n强制调用某个函数：\n```js\n  const result = await openai.chat.completions.create({\n    model: '',\n    messages,\n    tools,\n    tool_choice: {\n      type: \"function\",\n      function: {\n        name: \"getCurrentWeather\"\n      }\n    }\n  });\n```\n\n### 并发调用函数","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":122,"to":156}}}}],["91331e8b-e7d4-4b40-a15f-70b75183fe8d",{"pageContent":"### 并发调用函数\n\n在新版的 tools 中引入了并发调用函数的特性，可以简单的理解成之前的 function calling 每次 LLM 只会返回对一个函数的调用请求，而 tools 可以一次返回一系列的函数调用，来获取更多信息，并且函数之间可以并行的调用来节约调用外部 API 所占用的时间。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":156,"to":158}}}}],["c2265291-c69c-43e7-93f2-51c8e9b93f12",{"pageContent":"定义获取当前时间的 API：\n```js\n  function getCurrentTime({ format = \"iso\" } = {}) {\n    let currentTime;\n    switch (format) {\n      case \"iso\":\n        currentTime = new Date().toISOString();\n        break;\n      case \"locale\":\n        currentTime = new Date().toLocaleString();\n        break;\n      default:\n        currentTime = new Date().toString();\n        break;\n    }\n    return currentTime;\n  }\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":160,"to":177}}}}],["9c452c60-c907-4296-81fc-05c10500ebb5",{"pageContent":"将其添加到 tools 中：\n```js \n  const tools = [\n    {\n      type: \"function\",\n      function: {\n        name: \"getCurrentTime\",\n        description: \"Get the current time in a given format\",\n        parameters: {\n          type: \"object\",\n          properties: {\n            format: {\n              type: \"string\",\n              enum: [\"iso\", \"locale\", \"string\"],\n              description: \"The format of the time, e.g. iso, locale, string\",\n            },\n          },\n          required: [\"format\"],","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":179,"to":196}}}}],["c52f0e20-6a8f-4df4-81c2-c67b017bfce3",{"pageContent":"},\n          },\n          required: [\"format\"],\n        },\n      },\n    },\n    {\n      type: \"function\",\n      function: {\n        name: \"getCurrentWeather\",\n        description: \"Get the current weather in a given location\",\n        parameters: {\n          type: \"object\",\n          properties: {\n            location: {\n              type: \"string\",\n              description: \"The city and state, e.g. San Francisco, CA\",\n            },","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":194,"to":211}}}}],["f347d254-9f6b-414a-a4e8-297307650f54",{"pageContent":"description: \"The city and state, e.g. San Francisco, CA\",\n            },\n            unit: { type: \"string\", enum: [\"celsius\", \"fahrenheit\"] },\n          },\n          required: [\"location\", \"unit\"],\n        },\n      },\n    },\n  ]\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":210,"to":219}}}}],["3330727d-78c1-4f7f-b267-2832378ef38c",{"pageContent":"测试：\n```js\n  const messages = [\n    {\n      \"role\": \"user\",\n      \"content\": \"请同时告诉我当前的时间，上海的天气\"\n    }\n  ]\n\n  const result = await openai.chat.completions.create({\n    model: 'qwen-plus',\n    messages,\n    tools,\n  });\n\n  console.log(result.choices[0]);\n```\n\n目前并发调用还不稳定，不容易输出正确结果。\n\n### 根据函数结果进行回答\n\n函数运行结果输入给 LLM，让 LLM 参考此进行回答。\n```js\n  const messages = [\n    {\n      \"role\": \"user\",\n      \"content\": \"上海的天气怎么样\"\n    }\n  ];","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":221,"to":250}}}}],["cf910a8d-3243-4866-bfbd-bd01ad63c602",{"pageContent":"const result = await openai.chat.completions.create({\n    model: 'qwen-plus',\n    messages,\n    tools,\n  });\n```\n\n提取结果中的函数内容，并进行添加到 messages 中：\n```js\n  messages.push(result.choices[0].message)\n\n  const functions = {\n    \"getCurrentWeather\": getCurrentWeather\n  }","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":252,"to":265}}}}],["eaac91b2-de36-4bb6-a3de-2afdedac28ba",{"pageContent":"const functions = {\n    \"getCurrentWeather\": getCurrentWeather\n  }\n\n  const cell = result.choices[0].message.tool_calls[0]\n  const functionInfo = cell.function\n  const functionName = functionInfo.name;\n  const functionParams = functionInfo.arguments\n  const functionResult = functions[functionName](functionParams);\n\n  messages.push({\n    tool_call_id: cell.id,\n    role: \"tool\",\n    name: functionName,\n    content: functionResult,\n  }); \n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":263,"to":279}}}}],["bf33b124-194d-4738-bc2e-098e0f933ca7",{"pageContent":"然后把最新的 message 传递给 LLM：\n```js\n  const response = await openai.chat.completions.create({\n    model: 'qwen-plus',\n    messages,\n  });\n\n  console.log(response.choices[0].message);\n```\n\n输出内容如下：\n```json\n  { role: \"assistant\", content: \": 上海现在的天气是晴朗并有风，温度约为22℃。\" }\n```\n\n## 使用 LLM 进行数据标注和信息提取\n\n### 在 langchain 中使用 tools\n\n在 langchain 中，一般会使用 zod 来定义 tool 函数的 JSON schema，我们可以专注在参数的描述上，参数的类型定义和是否 required 都可以由 zod 来生成。 并且在定义 Agent tool 时，zod 也能进行辅助的参数类型检测。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":281,"to":300}}}}],["0ecda16e-40d1-4313-aa51-505431207bef",{"pageContent":"使用 zod 修改天气函数参数的 schem：\n```js\n  import { z } from \"zod\";\n\n  const getCurrentWeatherSchema = z.object({\n    location: z.string().describe(\"The city and state, e.g. San Francisco, CA\"), // string 类型\n    unit: z.enum([\"celsius\", \"fahrenheit\"]).describe(\"The unit of temperature\"), // 枚举类型\n  });\n```\n\n使用 zod-to-json-schema 去将 zod 定义的 schema 转换成 JSON schema：\n```js\n  import { zodToJsonSchema } from \"zod-to-json-schema\";\n\n  const paramSchema = zodToJsonSchema(getCurrentWeatherSchema);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":302,"to":317}}}}],["4cbe76d4-d81e-43fa-a7f9-d0c98688d2ba",{"pageContent":"const paramSchema = zodToJsonSchema(getCurrentWeatherSchema);\n```\n\n在 model 去使用这个 tool ：\n```js\n  import { ChatAlibabaTongyi } from \"@langchain/community/chat_models/alibaba_tongyi\";\n\n  const model = new ChatAlibabaTongyi({\n    model: \"qwen-turbo\",\n    temperature: 0,\n  });","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":316,"to":326}}}}],["4f82b75c-190a-46d5-9acd-c16181b98ce9",{"pageContent":"const model = new ChatAlibabaTongyi({\n    model: \"qwen-turbo\",\n    temperature: 0,\n  });\n\n  const modelWithTools = model.bind({\n    tools: [\n      {\n        type: \"function\",\n        function: {\n          name: \"getCurrentWeather\",\n          description: \"Get the current weather in a given location\",\n          parameters: paramSchema,\n        }\n      }\n    ]\n  });\n\n  await modelWithTools.invoke(\"上海的天气怎么样\");\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":323,"to":342}}}}],["590cdec7-3688-4521-8829-6861df96ead4",{"pageContent":"await modelWithTools.invoke(\"上海的天气怎么样\");\n```\n\n参考自 [langchain.js](https://js.langchain.com/v0.2/docs/how_to/tool_calling/#passing-tools-to-llms)\n\n因为绑定 tools 后的 model 依旧是 Runnable 对象，所以我们可以很方便的把它加入到 LCEL 链中：\n```js\n  import { ChatPromptTemplate } from \"@langchain/core/prompts\";\n\n  const prompt = ChatPromptTemplate.fromMessages([\n    [\"system\", \"You are a helpful assistant\"],\n    [\"human\", \"{input}\"]\n  ])\n\n  const chain = prompt.pipe(modelWithTools)","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":341,"to":355}}}}],["cb124469-fbc5-4b0a-bfd7-7a7b2614fda1",{"pageContent":"const chain = prompt.pipe(modelWithTools)\n\n  const res1 = await chain.invoke({\n    input: \"上海的天气怎么样\",\n  });\n\n  console.log(res);\n\n```\n\n### 多 tools model\n\n改写获取时间的 tool：\n```js\n  const getCurrentTimeSchema = z.object({\n    format: z\n      .enum([\"iso\", \"locale\", \"string\"])\n      .optional()\n      .describe(\"The format of the time, e.g. iso, locale, string\"),\n  });\n\n  zodToJsonSchema(getCurrentTimeSchema);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":355,"to":377}}}}],["52b695de-4eab-42ae-9def-0beea3762a7e",{"pageContent":"zodToJsonSchema(getCurrentTimeSchema);\n```\n\nmodelWithMultiTools 就会根据用户的输入和上下文去调用合适的 function\n```js\n  const model = new ChatOpenAI({\n    temperature: 0 \n  });","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":376,"to":383}}}}],["2291e964-9bcd-436b-95f9-d0dcb4543054",{"pageContent":"const modelWithMultiTools = model.bind({\n    tools: [\n      {\n        type: \"function\",\n        function: {\n          name: \"getCurrentWeather\",\n          description: \"Get the current weather in a given location\",\n          parameters: zodToJsonSchema(getCurrentWeatherSchema),\n        }\n      },\n      {\n        type: \"function\",\n        function: {\n          name: \"getCurrentTime\",\n          description: \"Get the current time in a given format\",","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":385,"to":399}}}}],["7a340e9f-64c5-4e5c-b13a-ecbfd078a149",{"pageContent":"name: \"getCurrentTime\",\n          description: \"Get the current time in a given format\",\n          parameters: zodToJsonSchema(getCurrentTimeSchema),\n        }\n      }\n    ],\n  });","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":398,"to":404}}}}],["fb8e378a-6a98-443b-a358-dd3dbeb0faab",{"pageContent":"```\n\n控制 model 对 tools 的调用，强制调用某个函数：\n```js\n  const modelWithForce = model.bind({\n    tools: [\n        ...\n    ],\n    tool_choice: {\n      type: \"function\",\n      function: {\n        name: \"getCurrentWeather\"\n      }\n    }\n  });\n```\n\n### 使用 tools 给数据打标签\n\n首先定义提取信息的函数 scheme ：\n```js\n  const taggingSchema = z.object({\n    emotion:z.enum([\"pos\", \"neg\", \"neutral\"]).describe(\"文本的情感\"),\n    language: z.string().describe(\"文本的核心语言（应为ISO 639-1代码）\"),\n  });\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":406,"to":431}}}}],["aede7c0d-72b0-4c96-8cb7-fd07de449639",{"pageContent":"为 model 绑定 tool， 模型需要使用 ChatOpenAI：\n```js \n  // const model = new ChatOpenAI({\n  //   temperature: 0 \n  // });\n\n  const modelTagging = model.bind({\n    tools: [\n      {\n        type: \"function\",\n        function: {\n          name: \"tagging\",\n          description: \"为特定的文本片段打上标签\",\n          parameters: zodToJsonSchema(taggingSchema)\n        }\n      }\n    ],\n    tool_choice: {\n      type: \"function\",\n      function: {\n        name: \"tagging\"\n      }\n    }\n  });\n\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":433,"to":458}}}}],["8810f0ed-7183-4740-88f2-b3204e46efdc",{"pageContent":"```\n\n组合成 chain：\n```js\n  import { JsonOutputToolsParser } from \"@langchain/core/output_parsers/openai_tools\";\n\n  const prompt = ChatPromptTemplate.fromMessages([\n    [\"system\", \"仔细思考，你有充足的时间进行严谨的思考，然后按照指示对文本进行标记\"],\n    [\"human\", \"{input}\"]\n  ])\n\n  const chain = prompt.pipe(modelTagging).pipe(new JsonOutputToolsParser());\n```\n\n测试：\n```js\n  const res = await chain.invoke({\n    input: \"hello world\",\n  });\n\n  console.log(res);\n```\n\n### 使用 tools 进行信息提取","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":458,"to":481}}}}],["43211874-88df-45d7-b374-4b1f9c769a5d",{"pageContent":"console.log(res);\n```\n\n### 使用 tools 进行信息提取\n\n定义描述一个人的信息 scheme：\n```js\n  const personExtractionSchema = z.object({\n    name: z.string().describe(\"人的名字\"),\n    age: z.number().optional().describe(\"人的年龄\")\n  }).describe(\"提取关于一个人的信息\");\n\n```\n\n构造更上层的 scheme，从信息中提取更复杂信息：","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":478,"to":492}}}}],["f02f0c06-b256-4e90-aa93-9cfe3e811936",{"pageContent":"```\n\n构造更上层的 scheme，从信息中提取更复杂信息：\n\n复用 personExtractionSchema 去构建数组的 scheme，去提取信息中多人的信息，并且提取文本中人物之间的关系\n```js\n  const relationExtractSchema = z.object({\n    people: z.array(personExtractionSchema).describe(\"提取所有人\"),\n    relation: z.string().describe(\"人之间的关系, 尽量简洁\")\n  });\n\n```\n\n构建成 chain ：\n```js\n  const model = new ChatOpenAI({\n    temperature: 0 \n  });","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":490,"to":507}}}}],["d2925972-6343-4312-b1ea-b24d120b5105",{"pageContent":"```\n\n构建成 chain ：\n```js\n  const model = new ChatOpenAI({\n    temperature: 0 \n  });\n\n  const modelExtract = model.bind({\n    tools: [\n      {\n        type: \"function\",\n        function: {\n            name: \"relationExtract\",\n            description: \"提取数据中人的信息和人的关系\",\n            parameters: zodToJsonSchema(relationExtractSchema)\n        }\n      }\n    ],\n    tool_choice: {\n      type: \"function\",\n      function: {\n        name: \"relationExtract\"\n      }\n    }\n  });","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":501,"to":526}}}}],["0277bec8-2b6d-49d8-8c3f-8fdd6aea15ae",{"pageContent":"const prompt = ChatPromptTemplate.fromMessages([\n    [\"system\", \"仔细思考，你有充足的时间进行严谨的思考，然后提取文中的相关信息，如果没有明确提供，请不要猜测，可以仅提取部分信息\"],\n    [\"human\", \"{input}\"]\n  ]);\n\n  const chain = prompt.pipe(modelExtract).pipe(new JsonOutputToolsParser());\n\n```\n\n测试简单的任务：\n```js\n  await chain.invoke({\n    input: \"小明现在 18 岁了，她妈妈是小丽\"\n  });\n```\n\n测试复杂任务：\n```js\n  await chain.invoke({\n    input: \"我是小明现在 18 岁，我和小华、小美是好朋友，我们都一样大\"\n  });\n```\n\n查看输出结果。\n\n\n## Agent","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":528,"to":554}}}}],["e85e3b6a-0175-4807-be61-b26ef324c23f",{"pageContent":"查看输出结果。\n\n\n## Agent\n\nAgents 是一个自主的决策和执行过程，其核心是将 llm 作为推理引擎，根据 llm 对任务和环境的理解，并根据提供的各种工具，自主决策一系列的行动。\n\n### RunnableBranch\nRunnableBranch 可以对任务进行分类，路由到擅长不同任务的 chain 中，然后对 chain 的结果进行处理、格式化等操作。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":551,"to":559}}}}],["8c84555a-48bd-4d19-9ac2-4e37d862d888",{"pageContent":"示例：参考文档 [tool_calls](https://js.langchain.com/v0.2/docs/how_to/tool_calling/)\n```js \nimport { z } from \"zod\";\nimport { ChatOpenAI } from \"@langchain/openai\";\nimport { ChatAlibabaTongyi } from \"@langchain/community/chat_models/alibaba_tongyi\";\nimport { JsonOutputToolsParser } from \"@langchain/core/output_parsers/openai_tools\";\nimport { RunnableSequence, RunnableBranch, RunnablePassthrough } from \"@langchain/core/runnables\";\nimport { zodToJsonSchema } from \"zod-to-json-schema\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":561,"to":568}}}}],["376d1311-f452-4386-a914-0bf8d55d6aa2",{"pageContent":"import { zodToJsonSchema } from \"zod-to-json-schema\";\nimport { ChatPromptTemplate, PromptTemplate } from \"@langchain/core/prompts\";\nimport { DynamicStructuredTool } from \"@langchain/core/tools\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":568,"to":570}}}}],["01f07f77-e163-4e93-a272-3d464372c943",{"pageContent":"const classifySchema = z.object({\n  type: z.enum([\"科普\", \"编程\", \"一般问题\"]).describe(\"用户提问的分类\")\n});\n\nconst model = new ChatOpenAI({\n  temperature: 0 \n})\n\n// const model = new ChatAlibabaTongyi({\n//     model: \"qwen-turbo\",\n//     temperature: 0,\n// });\n\n// const tool = new DynamicStructuredTool({\n//     name: \"classifyQuestion\",\n//     description: \"对用户的提问进行分类\",\n//     parameters: zodToJsonSchema(classifySchema),\n// });\n// const modelWithTools = model.bindTools([tool]);","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":572,"to":590}}}}],["50cb5233-6245-44e3-840b-21586a3c85b9",{"pageContent":"const modelWithTools = model.bind({\n  tools: [\n    {\n      type: \"function\",\n      function: {\n        name: \"classifyQuestion\",\n        description: \"对用户的提问进行分类\",\n        parameters: zodToJsonSchema(classifySchema),\n      }\n    }\n  ],\n  tool_choice: {\n    type: \"function\",\n    function: {\n      name: \"classifyQuestion\"\n    }\n  }\n});\n\nconst prompt = ChatPromptTemplate.fromMessages([\n  [\"system\", `仔细思考，你有充足的时间进行严谨的思考，然后对用户的问题进行分类，\n  当你无法分类到特定分类时，可以分类到 \"一般问题\"`],\n  [\"human\", \"{input}\"]\n]);","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":592,"to":615}}}}],["74cb436e-b777-490b-ade3-f341de412a0f",{"pageContent":"const classifyChain = RunnableSequence.from([\n  prompt,\n  modelWithTools,\n  new JsonOutputToolsParser(),\n  (input) => {\n      const type = input[0]?.args?.type\n      return type ? type : \"一般问题\"\n  }\n]);\n```\n\n为了构建面向工业使用、稳定的 llm，这里做了多层兜底：\n- classifySchema 中将 type 指定为必选\n- 在 prompt 中，添加了 “当你无法分类到特定分类时，可以分类到 \"一般问题\"”\n- 在输出时，也用函数确保 type 如果没有定义，那就是为 “一般问题”\n- 更进一步，也可以在这个函数中进行检测，判断 type 是否是几个目标分类之一，如果不是则返回 “一般问题”\n\n测试：\n```js\n  await classifyChain.invoke({\n    \"input\": \"鲸鱼是哺乳动物么？\"\n  });\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":617,"to":639}}}}],["76f5ad5a-b64f-4655-89a2-085cb974a848",{"pageContent":"测试：\n```js\n  await classifyChain.invoke({\n    \"input\": \"鲸鱼是哺乳动物么？\"\n  });\n```\n\n构造三个简单的对应的专家 chain：\n```js\nimport { StringOutputParser } from \"@langchain/core/output_parsers\";\n\nconst answeringModel = new ChatOpenAI({\n  temperature: 0.7,\n});\n\nconst sciencePrompt = PromptTemplate.fromTemplate(\n  `作为一位科普专家，你需要解答以下问题，尽可能提供详细、准确和易于理解的答案：\n\n  问题：{input}\n  答案：`\n);\n    \nconst programmingPrompt = PromptTemplate.fromTemplate(\n  `作为一位编程专家，你需要解答以下编程相关的问题，尽可能提供详细、准确和实用的答案：\n\n  问题：{input}\n  答案：`\n);","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":634,"to":661}}}}],["956fb0f6-d0b3-4b5a-983a-e7486da09256",{"pageContent":"问题：{input}\n  答案：`\n);\n\nconst generalPrompt = PromptTemplate.fromTemplate(\n  `请回答以下一般性问题，尽可能提供全面和有深度的答案：\n\n  问题：{input}\n  答案：`\n);\n\nconst scienceChain = RunnableSequence.from([\n  sciencePrompt,\n  answeringModel,\n  new StringOutputParser(),\n  {\n    output: input => input,\n    role: () => \"科普专家\"\n  }\n]);\n\nconst programmingChain = RunnableSequence.from([\n  programmingPrompt,\n  answeringModel,\n  new StringOutputParser(),\n  {\n    output: input => input,\n    role: () => \"编程大师\"\n  }\n]);","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":659,"to":688}}}}],["02378f94-e84a-4457-b16a-b514bd8ff4f4",{"pageContent":"const generalChain = RunnableSequence.from([\n  generalPrompt,\n  answeringModel,\n  new StringOutputParser(),\n  {\n    output: input => input,\n    role: () => \"通识专家\"\n  }\n]);\n\n```\n\n构建 RunnableBranch 来根据用户的输入进行路由：\n```js\n  const branch = RunnableBranch.from([\n    [\n      (input => input.type.includes(\"科普\")),\n      scienceChain,\n    ],\n    [\n      (input => input.type.includes(\"编程\")),\n      programmingChain,\n    ],\n    generalChain\n  ]);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":690,"to":715}}}}],["b867ba34-4a5d-47dc-9d73-24eca37afb7f",{"pageContent":"RunnableBranch 传入的是二维数组，每个数组的第一个参数是该分支的条件。它通过向每个条件传递调用它的输入来选择哪个分支，当数组中的第一个参数返回 True 时，就会返回对应的 Runnable 对象。如果没有传入条件，这就是默认执行这个 Runnable。\n\nRunnableBranch 只会选择一个 Runnable 对象，如果有多个返回为 True，只会选择第一个。\n\n实际上，因为任何函数都是一个 RunnableBranch 对象，所以可以不使用 RunnableBranch，直接使用函数来实现路由，这样会有更大的自由度。\n\n用函数实现一个等价路由功能：\n```js\n  const route = ({ type }) => {\n    if(type.includes(\"科普\")){\n      return scienceChain\n    }else if(type.includes(\"编程\")){\n      return programmingChain;\n    }\n\n    return generalChain;\n  };\n\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":717,"to":735}}}}],["731f7b3c-c658-41cb-b5fb-a98bfa748d5f",{"pageContent":"return generalChain;\n  };\n\n```\n\n组合成一个完整的 chain：\n```js\n  const outputTemplate = PromptTemplate.fromTemplate(\n    `感谢您的提问，这是来自 {role} 的专业回答：\n\n    {output}\n    `\n  )\n\n\n  const finalChain = RunnableSequence.from([\n    {\n      type: classifyChain,\n      input: input => input.input\n    },\n    branch,\n    (input) => outputTemplate.format(input),\n  ]);\n\n```\n\n利用 prompt 模版简单渲染了一下不同 chain 返回的 role 数据，在工程中可以根据需求对返回值进行更复杂的处理。\n\n### Lang Smith\nlangchain 官方和社区都推荐的可视化的追踪和分析 agents/llm-app 的内部处理流程。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":732,"to":761}}}}],["a79aed80-af35-462b-a720-5530fbac3971",{"pageContent":"### Lang Smith\nlangchain 官方和社区都推荐的可视化的追踪和分析 agents/llm-app 的内部处理流程。\n\n在[官网注册](https://docs.smith.langchain.com/) 获取 API_KEY\n\n申请成功后，配置环境变量 \n```js\n  LANGCHAIN_TRACING_V2=true  \n  LANGCHAIN_API_KEY=xxx\n```\n\n### ReAct 框架\n\nagent 框架结合了推理（reasoning）和行动（acting），其流程大概是让 llm 推理完成任务需要的步骤，然后根据环境和提供的工具进行调用，观察工具的结果，推理下一步任务。\n\nReAct 的意义是在于，这个框架将 llm 的推理能力、调用工具能力、观察能力结合在一起，让 llm 能适应更多的任务和动态的环境，并且强化了推理和行动的协同作用。因为 agents 在执行过程中，会把思考和推理过程记录下来，所以具有很好的透明度和可解释性，提高了用户对输出结果的可信度。\n\n示例：","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":760,"to":777}}}}],["683e2d18-ce3f-4ae8-8941-b46a76d68bd2",{"pageContent":"示例：\n\n首先定义提供给 agents 的工具集：\n```js\n  const tools = [new SerpAPI(process.env.SERP_KEY), new Calculator()];\n```\n\n然后从 langchain hub 拉取 reAct 的 prompt，前者是由 langchain 提供的用于共享、管理和使用 prompt 的站点：\n```js\n  const prompt = await pull<PromptTemplate>(\"hwchase17/react\");\n```\n\n可以在 [smith](https://smith.langchain.com/hub/hwchase17/react) 查看其中的 prompt。\n\n```js\n  Answer the following questions as best you can. You have access to the following tools:\n\n  {tools}\n\n  Use the following format:","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":777,"to":796}}}}],["982325b7-2fdd-419e-8177-b00052bcd453",{"pageContent":"{tools}\n\n  Use the following format:\n\n  Question: the input question you must answer\n  Thought: you should always think about what to do\n  Action: the action to take, should be one of [{tool_names}]\n  Action Input: the input to the action\n  Observation: the result of the action\n  ... (this Thought/Action/Action Input/Observation can repeat N times)\n  Thought: I now know the final answer\n  Final Answer: the final answer to the original input question\n\n  Begin!","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":794,"to":807}}}}],["b8be3eb9-9f6a-41f5-bb1d-7345bdc03f54",{"pageContent":"Begin!\n\n  Question: {input}\n  Thought:{agent_scratchpad}\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":807,"to":811}}}}],["853d9c6d-db33-4ea0-9ea5-98a605242954",{"pageContent":"解析这个 prompt:\n- 首先第一部分定义了任务，因为这是一个通用领域的 agents，所以内容是 尽可能的回答用户的问题，这也是给模型设定了一个明确的出发点。\n- 然后确定了模型有哪些工具可以用，如果使用 langchain 的内置工具（tool），langchain 已经给每个工具提供了完整的描述\n- 然后就是 reAct 的核心部分，定义了固定的格式和思考的路线，这部分也是记录了 llm 整个的思考过程，也会作为 prompt 在每次调用 llm 时传入，让其知道之前的思考流程和信息\n  - Question：定义用户的问题，也是整个推理的最终目标，也是模型推理的起点\n  - Thought：引导模型进行思考，考虑下一步采取的行动，构建解决问题的策略和步骤，也就是推理阶段。这部分也会记录在 prompt 中，方便去理解 llm 推理和思考的过程\n  - Action：定义模型需要采取的行动，这里需要是 tools 中提供的 tool，这就是模型需要采取的行动\n  - Action Input：调用工具的参数，参数是连接用户的问题、模型的思考和实际行动的关键环节","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":813,"to":820}}}}],["9ab0108b-bebd-43e9-8ea9-d352d679b679",{"pageContent":"- Action Input：调用工具的参数，参数是连接用户的问题、模型的思考和实际行动的关键环节\n  - Observation：是 Action 的调用结果，给模型提供反馈，帮助模型根据前一 Action 的行动结果，决定后续的推理和行动步骤\n  - Final Answer：上面的步骤会重复多次，直到模型认为现有的推理、思考和观察已经能够得出答案，就根据信息总结出最终答案","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":820,"to":822}}}}],["2c7cb656-3abf-4631-afd5-5a84632803ed",{"pageContent":"完整代码如下：\n```js\nimport { ChatOpenAI } from \"@langchain/openai\";\nimport { SerpAPI } from \"@langchain/community/tools/serpapi\";\nimport \"dotenv/config\";\nimport { AgentExecutor, createReactAgent } from \"langchain/agents\";\nimport { pull } from \"langchain/hub\";\nimport type { PromptTemplate } from \"@langchain/core/prompts\";\nimport { Calculator } from \"@langchain/community/tools/calculator\";\n\nasync function main() {\n  const tools = [new SerpAPI(process.env.SERP_KEY), new Calculator()];","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":824,"to":835}}}}],["7cbcd254-e412-4499-97aa-d398ce5233f7",{"pageContent":"async function main() {\n  const tools = [new SerpAPI(process.env.SERP_KEY), new Calculator()];\n\n  const prompt = await pull<PromptTemplate>(\"hwchase17/react\");\n  const llm = new ChatOpenAI({\n    temperature: 0,\n  });\n\n  const agent = await createReactAgent({\n    llm,\n    tools,\n    prompt,\n  });\n\n  const agentExecutor = new AgentExecutor({\n    agent,\n    tools,\n  });\n\n  const result = await agentExecutor.invoke({\n    input: \"我有 15 美元，现在相当于多少人民币？\",\n  });\n\n  console.log(result);\n}\n\nmain();\n\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":834,"to":862}}}}],["86a5293a-a634-4eb9-a0a4-c1bede737ece",{"pageContent":"console.log(result);\n}\n\nmain();\n\n```\n\n执行该文件，即可在[控制台](https://smith.langchain.com/) 查看推理记录\n\nreAct 框架的一些问题：\n- 复杂性和开销\n\n  最终结果的正确性依赖于每一步的精准操作，而每一步的操作是我们很难控制的。从 prompt 来看，其实只定义了基本的思考方式，后续都是 llm 根据自己理解进行推理。\n- 对外部数据源准确性的依赖\n  \n  reAct 假设外部信息源都是真实而确定的，并不会引导模型对外部数据源进行辩证的思考，所以如果数据源出现问题，推理结果就会出问题。\n- 错误传播和幻觉问题\n\n  推理初期的错误会在后续推理中放大，特别是外部数据源有噪声或者数据不完整时。在缺乏足够量数据支持时，模型在推理和调用阶段可能会出现幻觉。\n- 速度问题\n\n  reAct 会让模型 “慢下来” 一步步的去思考来得出结论，所以即使是简单的问题也会涉及到多次 llm 调用，很难应用在实时的 chat 场景中。\n\n\n### OpenAI tools Agents","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":857,"to":881}}}}],["77769cf5-f74b-48f4-965d-7241028cf261",{"pageContent":"### OpenAI tools Agents\n\n目前，满足稳定可使用的 agents 其实是直接使用 openAI 的 tools 功能。 Agents 所做的事情就是自我规划任务、调用外部函数和输出答案。而 openAI 的 tools 功能恰好如此，其提供了 tools 接口，并且由 llm 决定何时以及如何调用 tools，并根据 tools 的运行结果生成给用户的输出。\n\n由于 openAI 对 gpt3.5t 和 gpt4 针对 tools 进行了微调，使其能够针对 tools 场景稳定地生成合法的调用参数。不会出现 reAct 中使用低性能的 llm 导致的 parse 报错而运行出错的问题。\n\n*示例*\n\n使用 SerpAPI 和 Calculator 作为 llm 的工具，然后拉去相应的 prompt：\n```js\n  const tools = [new SerpAPI(process.env.SERP_KEY), new Calculator()];","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":881,"to":891}}}}],["dbd1ac21-6b42-4971-85fc-2b3843540884",{"pageContent":"const prompt = await pull<ChatPromptTemplate>(\"hwchase17/openai-tools-agent\");\n```\n\n查看 prompt 的内容 [openai-tools-agent](https://smith.langchain.com/hub/hwchase17/openai-tools-agent?organizationId=9454050f-397a-543d-899f-ac54537c39dd)：\n\n```js \n  SYSTEM\n\n  You are a helpful assistant\n\n  PLACEHOLDER\n\n  chat_history\n  HUMAN\n\n  {input}\n\n  PLACEHOLDER\n\n  agent_scratchpad\n```\n其中 chat_history 和 agent_scratchpad 是 MessagePlaceHolder。因为 openAI 模型本身的强大，已经具有自主决策 tool 调用的能力，从 prompt 上并不需要提供额外的信息和规则。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":893,"to":914}}}}],["ee8eb2c0-6851-4a1f-be1e-21a63ea244bf",{"pageContent":"完整代码如下：\n```js\n  // import { ChatOpenAI } from \"@langchain/openai\";\n  import { ChatAlibabaTongyi } from \"@langchain/community/chat_models/alibaba_tongyi\";\n  import { SerpAPI } from \"@langchain/community/tools/serpapi\";\n  import \"dotenv/config\";\n  import { AgentExecutor } from \"langchain/agents\";\n  import { pull } from \"langchain/hub\";\n  import { createOpenAIToolsAgent } from \"langchain/agents\";\n  import { ChatPromptTemplate } from \"@langchain/core/prompts\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":916,"to":925}}}}],["57f6dc60-15e6-4145-9efe-9b8ca902621e",{"pageContent":"import { ChatPromptTemplate } from \"@langchain/core/prompts\";\n  import { Calculator } from \"@langchain/community/tools/calculator\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":925,"to":926}}}}],["2639242b-fe38-4903-928c-7210ed328c68",{"pageContent":"process.env.LANGCHAIN_TRACING_V2 = \"true\";\n\n  async function main() {\n    const tools = [new SerpAPI(process.env.SERP_KEY), new Calculator()];\n\n    const prompt = await pull<ChatPromptTemplate>(\"hwchase17/openai-tools-agent\");\n\n    const llm = new ChatAlibabaTongyi({\n      model: \"qwen-turbo\",\n      temperature: 0,\n    });\n\n    const agent = await createOpenAIToolsAgent({\n      llm,\n      tools,\n      prompt,\n    });","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":928,"to":944}}}}],["07e8c267-c713-40b9-abcd-aee74e3b5034",{"pageContent":"const agent = await createOpenAIToolsAgent({\n      llm,\n      tools,\n      prompt,\n    });\n\n    const agentExecutor = new AgentExecutor({\n      agent,\n      tools,\n    });\n\n    const result = await agentExecutor.invoke({\n      input:\n        \"我有 10000 人民币，可以购买多少微软股票，注意微软股票一般是以美元计价，需要考虑汇率问题\",\n    });\n\n    console.log(result);\n  }\n\n  main();\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":940,"to":960}}}}],["4224ee6e-0762-44cf-95be-c5413babfaec",{"pageContent":"执行代码，输出以下内容：\n```js\n  {\n    input: '我有 10000 人民币，可以购买多少微软股票，注意微软股票一般是以美元计价，需要考虑汇率问题',\n    output: '首先，我们需要知道当前的汇率。由于汇率是实时变动的，我会提供一个假设的汇率来计算，但实际购买时请以当天的实时汇率为准。\\n' +\n      '\\n' +\n      '假设当前汇率是1美元=6.5人民币（这是一个平均汇率，实际汇率可能会有所不同）。那么，10000人民币可以换算成：\\n' +\n      '\\n' +\n      '10000人民币 / 6.5 ≈ 1535.54美元\\n' +\n      '\\n' +\n      '接下来，我们查看微软（Microsoft）的股价。微软的股价也会随市场波动，这里我们假设一个价格，例如微软的股价是200美元/股。那么，你可以购买的股票数量为：\\n' +\n      '\\n' +\n      '1535.54美元 / 200美元/股 ≈ 7.68股\\n' +\n      '\\n' +","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":962,"to":975}}}}],["68861643-18f0-40d7-a3f6-11879293e91c",{"pageContent":"'\\n' +\n      '1535.54美元 / 200美元/股 ≈ 7.68股\\n' +\n      '\\n' +\n      '由于你不能购买部分股票，所以实际能购买的是7股，因为股票通常是以整数交易的。剩下的钱将不足以再买一股。\\n' +\n      '\\n' +\n      '请注意，这只是一个估算，实际购买时请参考实时汇率和股票价格。同时，投资股市有风险，建议在投资前做好充分的研究和咨询专业人士。'\n  }\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":973,"to":980}}}}],["acf0a061-91f0-44dd-9ed8-8661fdf3c6aa",{"pageContent":"同时也可以在 [smith langchain控制台](https://smith.langchain.com/) 查看推理流程。\n\n### 自定义 Tool\n\n无论是 reAct 还是 OpenAI tools 亦或是其他的 agents 框架，提供给 agents 的 tool 都影响着 agents 应用范围和效果。 除了使用 langchain 内部提供的一系列 tools 外，还可以自定义 tool 让 agents 去使用。\n\n目前由两种可以自定义的 tool，需要的参数都是工具的名称、描述和真实调用的函数，注意这里名称和描述将影响 llm 何时调用，所以一定是有语意的。 在函数的实现上，不要抛出错误，而是返回包含错误信息的字符串，llm 可以据此决定下一步行动。\n\n两种自定义的 tool 也有细微的区别：\n- DynamicTool：只支持单一的字符串作为函数输入。因为 reAct 框架，并不支持多输入的 tool\n- DynamicStructuredTool：支持使用 zod schema 定义复杂的输入格式，适合在 openAI tools 中使用","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":982,"to":992}}}}],["9cae7cf5-79bd-4dc8-a2a4-f9f08c4b6e66",{"pageContent":"使用 DynamicTool 创建只有一个输入的 tool：\n```js\n  const stringReverseTool = new DynamicTool({\n    name: \"string-reverser\",\n    description: \"reverses a string. input should be the string you want to reverse.\",\n    func: async (input: string) => input.split(\"\").reverse().join(\"\"),\n  });\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":994,"to":1001}}}}],["89fe1f46-7606-4f44-be04-257f294c8a34",{"pageContent":"可以将前面做的 RAG chain 作为工具提供给 agents，让其由更大范围调用知识和信息的能力。首先创建一个 retriever chain：\n```js\n  async function loadVectorStore() {\n    const directory = path.join(__dirname, \"../db/qiu\");\n    const embeddings = new AlibabaTongyiEmbeddings();\n    const vectorStore = await FaissStore.load(directory, embeddings);\n\n    return vectorStore;\n  }\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":1003,"to":1012}}}}],["f1dc8266-2011-4054-b7c8-ee5e01b718c8",{"pageContent":"return vectorStore;\n  }\n```\n\n```js \n  import { createStuffDocumentsChain } from \"langchain/chains/combine_documents\"; \n  import { createRetrievalChain } from \"langchain/chains/retrieval\";\n  \n  const prompt = ChatPromptTemplate.fromTemplate(`将以下问题仅基于提供的上下文进行回答：\n    上下文：\n    {context}\n\n    问题：{input}`);\n  const llm = new ChatAlibabaTongyi({\n    model: \"qwen-turbo\",\n  });\n\n  const documentChain = await createStuffDocumentsChain({\n    llm,\n    prompt,\n  });","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":1010,"to":1030}}}}],["a9519fe5-2127-456c-b9bb-c210912320f1",{"pageContent":"const documentChain = await createStuffDocumentsChain({\n    llm,\n    prompt,\n  });\n\n  const vectorStore = await loadVectorStore();\n  const retriever = vectorStore.asRetriever();\n\n  const retrievalChain = await createRetrievalChain({\n    combineDocsChain: documentChain,\n    retriever,\n  });\n\n  return retrievalChain;\n```\n\n这里利用了 langchain 内置的两个创建 chain 的工具，createStuffDocumentsChain 和 createRetrievalChain。 前者内置了对 Document 的处理和对 llm 的调用，后者内置了对 retriver 的调用和将结果传入到 combineDocsChain 中。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":1027,"to":1043}}}}],["77273b48-5723-429b-9d11-f5b52239167c",{"pageContent":"创建 DynamicTool：\n```js \n  const retrieverTool = new DynamicTool({\n    name: \"get-qiu-answer\",\n    func: async (input: string) => {\n      const res = await retrieverChain.invoke({ input });\n      return res.answer;\n    },\n    description: \"获取小说 《球状闪电》相关问题的答案\",\n  });\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":1045,"to":1055}}}}],["fa66a929-c183-49a6-ad1b-fb65f4cf9d1c",{"pageContent":"使用 DynamicStructuredTool 创建一个复杂输入的 tool：\n```js\n  const dateDiffTool = new DynamicStructuredTool({\n    name: \"date-difference-calculator\",\n    description: \"计算两个日期之间的天数差\",\n    schema: z.object({\n      date1: z.string().describe(\"第一个日期，以YYYY-MM-DD格式表示\"),\n      date2: z.string().describe(\"第二个日期，以YYYY-MM-DD格式表示\"),\n    }),\n    func: async ({ date1, date2 }) => {\n      const d1 = new Date(date1);\n      const d2 = new Date(date2);\n      const difference = Math.abs(d2.getTime() - d1.getTime());","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":1057,"to":1069}}}}],["62d48e3d-bdd0-4f38-8410-1853654f6462",{"pageContent":"const d2 = new Date(date2);\n      const difference = Math.abs(d2.getTime() - d1.getTime());\n      const days = Math.ceil(difference / (1000 * 60 * 60 * 24));\n      return days.toString();\n    },\n  });\n```\n这里使用 zod 来定义函数输入的格式，并且 agents 在调用 tool 时，参数会经过 zod 进行校验，如果出错会直接将校验的错误信息返回给 llm，其会根据报错信息调整输入格式。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":1068,"to":1075}}}}],["1197f36d-5f17-42c3-9a8a-6e04fb73072c",{"pageContent":"用 reAct agent 去测试:\n```js\n  const tools = [retrieverTool, new Calculator()];\n  // 创建 agents 的代码省略\n  const res = await agents.invoke({\n      input: \"小说球状闪电中量子玫瑰的情节\",\n  });\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":1077,"to":1084}}}}],["92b2454c-bcc0-4dde-a65f-1791cdf6524b",{"pageContent":"输出内容如下：\n```js\n  {\n    input: '小说球状闪电中量子玫瑰的情节',\n    output: '在刘慈欣的科幻小说《球状闪电》中，\"量子玫瑰\"是一个非常重要的情节元素。它是一种虚构的高科技武器，也是故事中的关键线索之一。\\n' +\n      '\\n' +\n      '\"量子玫瑰\"是基于量子物理理论的一种高科技产物，它利用了微观粒子的奇特性质，如量子纠缠和超导现象，制造出一种能量密度极高、威力无比的武器。这种武器的形态像一朵盛开的玫瑰，因此得名。它的存在打破了常规物理学的认知，挑战了人类对能量的理解。\\n' +\n      '\\n' +\n      '在小说中，\"量子玫瑰\"被描绘为一种几乎无法防御的武器，其破坏力巨大，足以改变战争的格局。主角叶文洁在小说中扮演了与之相关的重要角色，她不仅揭示了\"量子玫瑰\"的秘密，还因为这个秘密而卷入了一系列的政治和军事冲突。\\n' +\n      '\\n' +\n      '整个情节围绕着\"量子玫瑰\"的开发、使用以及对抗展开，展现了科技发展带来的伦理和道德困境，同时也探讨了人性、权力和命运等深层次的主题。'\n  }\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":1086,"to":1098}}}}],["6cf708ae-4bd0-401e-815b-2b62b31cfe8b",{"pageContent":"对于复杂的问题 agents 会逐步推理和应用不同的 tools 来得出最终的结果。所以 tools 的种类、能力很大程度上决定了 agents 的上限，但对于 reAct 这种框架，tools 是作为 prompt 嵌入到 llm 上下文中，所以过多的 tools 会影响用于其他内容的 prompt。 同样的，openAI tools 的描述和输入的 schema 也是算在上下文中，也受窗口大小的限制。所以并不是 tools 越多越好，而是根据需求去设计。\n\n跟 chain 一样，复杂 agents 可以同样采用路由的设计，由一个入口 agents 通过 tools 链接多个垂直领域的专业 agents，根据用户的问题进行分类，然后导向到对应的专业 agents 进行回答。\n\n在这种实现时，每个子 agents 通过 DynamicTool 进行定义，并且传入 returnDirect: true，这样会直接将该 tool 调用的结果作为结果返回给用户，而不是将 tool 的结果再次传给 llm 并生成输出。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":1100,"to":1104}}}}],["422dd42b-385f-4579-b9c6-1817d958662b",{"pageContent":"使用 retriever 例子演示：\n```js \n  const retrieverChain = await getRetrieverChain();\n  const retrieverTool = new DynamicTool({\n    name: \"get-qiu-answer\",\n    func: async (input: string) => {\n      const res = await retrieverChain.invoke({ input });\n      return res.answer;\n    },\n    description: \"获取小说 《球状闪电》相关问题的答案\",\n    returnDirect: true,\n  });\n\n  const tools = [retrieverTool, new Calculator()];\n  const agents = await createReactAgentWithTool(tools);","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":1106,"to":1120}}}}],["61d2aeb7-c788-4266-b5a3-e1df5af46d00",{"pageContent":"const res = await agents.invoke({\n    input: \"用一句话，介绍小说球状闪电中，跟量子玫瑰有关的情节\"\n  });\n\n  console.log(res);\n```\n\n从 langSmith 的数据可以看到，当调用 get-qiu-answer 这个 tool 后，直接把 tool 的结果当做整个 agents 运行的最终结果返回了，而不是像前面一样再经过一次 llm 节点生成答案。因此就可以利用 returnDirect feature，将入口的 agent 作为 route，去导向到不同领域的专业 agent，这也是多 agents 协同的一种方式。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Agent.mdx","loc":{"lines":{"from":1122,"to":1129}}}}],["8ca53406-b32c-4721-8feb-9c2d6327d09a",{"pageContent":"---\ntitle: Chat Bot 实战\ndate: '2024-06-06'\ntags: ['AI大模型', 'LLM']\ndraft: false\nsummary: 用 LLM_UI 实现 MBTI chat bot，基于 node 实现。\n---\n\n## 实现步骤\n1. 首先定义一个简单的，根据 MBTI 类型和问题回答用户的 chain：\n\n```js\n  const prompt = ChatPromptTemplate.fromMessages([\n    [\n      \"system\",\n      \"你是一个共情能力非常强的心理医生，并且很了解MBTI（迈尔斯-布里格斯性格类型指标)的各种人格类型，你的任务是根据来访者的 MBTI 和问题，给出针对性的情感支持，你的回答要富有感情、有深度和充足的情感支持，引导来访者乐观积极面对问题\",\n    ],\n    [\"human\", \"用户的 MBTI 类型是{type}, 这个类型的特点是{info}, 他的问题是{question}\"],\n  ]);","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Chat bot.mdx","loc":{"lines":{"from":1,"to":19}}}}],["557f8cf1-fdfa-45cf-9cc6-256f35c19b6b",{"pageContent":"const llm = new ChatAlibabaTongyi({\n    model: \"qwen-max\",\n  });\n  const mbtiChain = RunnableSequence.from([prompt, model, new StringOutputParser()]);\n```\n这是非常简单的 chat chain，除了告诉 llm MBTI 相关的信息外，还给 llm 设定了 “引导来访者乐观积极面对问题” 这样有倾向性的 prompt，引导 prompt 的回答风格。\n\n需要的参数：\n- type： 用户的 MBTI 类型\n- info： 对应 MBTI 的类型的特点描述。对于这种由固定答案的信息，不要让 llm 自己生成，而且由我们提供确定性的信息。\n- question： 用户的问题","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Chat bot.mdx","loc":{"lines":{"from":21,"to":31}}}}],["d697f858-3553-4730-bbb8-e1f3ec125145",{"pageContent":"2. 据此定义一个自定义的 tool：\n```js\n  const mbtiTool = new DynamicStructuredTool({\n    name: \"get-mbti-chat\",\n    schema: z.object({\n      type: z.enum(mbtiList).describe(\"用户的 MBTI 类型\"),\n      question: z.string().describe(\"用户的问题\"),\n    }),\n    func: async ({ type, question }) => {\n      const info = mbtiInfo[type];","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Chat bot.mdx","loc":{"lines":{"from":33,"to":42}}}}],["904d1857-64db-42ff-9707-3ec41d683365",{"pageContent":"const res = await mbtiChain.invoke({ type, question, info });\n      return res;\n    },\n    description: \"根据用户的问题和 MBTI 类型，回答用户的问题\",\n  });\n```\n其中，mbtiList 是穷举所有 MBTI 的类型。 mbtiInfo 是从外部 json 中加载出来的，以 mbti 类型为 key 对性格描述的 object。\n这里把 type 和 question 定义为我们函数 schema 的必填的参数，方便 llm 对函数的理解。\n\n3. 据此创建一个 agents：\n```js\n  const tools = [mbtiTool];","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Chat bot.mdx","loc":{"lines":{"from":44,"to":55}}}}],["1d6289b7-5381-40fa-8d95-7b9c5a80aa9f",{"pageContent":"3. 据此创建一个 agents：\n```js\n  const tools = [mbtiTool];\n\n  const agentPrompt = await ChatPromptTemplate.fromMessages([\n    [\n      \"system\",\n      \"你是一个用户接待的 agent，通过自然语言询问用户的 MBTI 类型和问题，直到你有足够的信息调用 get-mbti-chat 来回答用户的问题\",\n    ],\n    new MessagesPlaceholder(\"history_message\"),\n    [\"human\", \"{input}\"],\n    new MessagesPlaceholder(\"agent_scratchpad\"),\n  ]);\n\n  const llm = new ChatAlibabaTongyi({\n    model: \"qwen-max\",\n    temperature: 0.4,\n  });","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Chat bot.mdx","loc":{"lines":{"from":53,"to":70}}}}],["49337718-bdf7-41b5-9767-6413ac989495",{"pageContent":"const llm = new ChatAlibabaTongyi({\n    model: \"qwen-max\",\n    temperature: 0.4,\n  });\n\n  const agent = await createOpenAIToolsAgent({\n    llm,\n    tools,\n    prompt: agentPrompt,\n  });\n\n  const agentExecutor = new AgentExecutor({\n    agent,\n    tools,\n  });\n```\n为了演示，只给 agents 添加了这一个 tool，并且在 system prompt 中强化了对 get-mbti-chat 的调用的指示。如果是在工程中，也不要加太多的 tool，可以采用 Route/RunnableBranch 等方案，由路由去引导用户到对应的专业 agents 去处理。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Chat bot.mdx","loc":{"lines":{"from":67,"to":83}}}}],["c467bd3d-0b98-4ec4-9f37-9520316ecda3",{"pageContent":"4. 给 agents 添加 history：(也可以使用持久化在文件中的 chat history 解决方案)\n```js\n  const messageHistory = new ChatMessageHistory();\n\n  const agentWithChatHistory = new RunnableWithMessageHistory({\n    runnable: agentExecutor,\n    getMessageHistory: () => messageHistory,\n    inputMessagesKey: \"input\",\n    historyMessagesKey: \"history_message\",\n  });\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Chat bot.mdx","loc":{"lines":{"from":85,"to":95}}}}],["749c3113-4556-45a6-b8d2-748089d7b68c",{"pageContent":"5. 使用 nodejs 的 readline 内置库，迅速构建一个可以在 cli 中使用的 chat bot，方便进行测试：\n```js\n  const rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n  });\n\n  function chat() {\n    rl.question(\"User: \", async (input) => {\n      if (input.toLowerCase() === \"exit\") {\n        rl.close();\n        return;\n      }","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Chat bot.mdx","loc":{"lines":{"from":97,"to":109}}}}],["01dd0c41-b6a3-41dc-ace5-7c0505d36b7f",{"pageContent":"const response = await agentWithChatHistory.invoke(\n        {\n          input,\n        },\n        {\n          configurable: {\n            sessionId: \"no-used\",\n          },\n        }\n      );\n\n      console.log(\"Agent: \", response.output);\n\n      chat();\n    });\n  }\n\n  console.log(\"请输入问题。 输入 exit 退出聊天。\");\n  chat();\n```\n\n6.运行脚本，测试 chat bot。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Chat bot.mdx","loc":{"lines":{"from":111,"to":132}}}}],["7660e41e-4442-458c-919b-0eaf457c8ac8",{"pageContent":"---\ntitle: RAG检索增强生成(二)\ndate: '2024-05-23'\ntags: ['AI大模型', 'javaScript', 'Deno']\ndraft: false\nsummary: 大规模数据预处理及向量数据库的构建\n---\n\n## 大规模数据预处理\n受限于常见 llm 的上下文大小，例如 gpt3.5 是 16k、gpt4 是 128k，不能把完整的数据整个塞到对话的上下文中，而且，即使数据源接近于 llm 的上下文窗口大小，llm 在读取数据时也很容易忽略其中的细节。所以需要对加载进来的数据切分，切分成较小的语块，然后根据对话的内容，将关联性比较强的数据塞到 llm 的上下文中，来强化 llm 输出的质量。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":1,"to":10}}}}],["333370c6-4d0f-4c0a-8a7b-79964408cb38",{"pageContent":"langchain 目前提供的切分工具：\n| 名称 | 说明 |\n| --- | --- |\n| Recursive\t| 根据给定的切分字符（例如 \\n\\n、\\n等），递归的切分 |\n| HTML | 根据 html 特定字符进行切分 |\n| Markdown | 根据 md 的特定字符进行切分 |\n| Code | 根据不同编程语言的特定字符进行切分 |\n| Token | 根据文本块的 token 数据进行切分 |\n| Character | 根据用户给定的字符进行切割 |\n\n### RecursiveCharacterTextSplitter\n\n  RecursiveCharacterTextSplitter，最常用的切分工具，根据内置的一些字符对原始文本进行递归的切分，来保持相关的文本片段相邻，保持切分结果内部的语意相关性。默认的分隔符列表是 [\"\\n\\n\", \"\\n\", \" \", \"\"]。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":12,"to":24}}}}],["350d9849-2401-4ee5-a883-3a6654f3ea97",{"pageContent":"影响切分质量的两个参数:\n  - chunkSize: 默认是 1000，切分后的文本块的大小，如果文本块太大，llm 的上下文窗口会不够，如果文本块太小，llm 的上下文窗口会太小，导致 llm 输出的结果不够准确。\n  - chunkOverlap: 默认是 200，切分后的文本块之间的重叠长度，如果文本块重叠的长度太长，llm 的上下文窗口会太小，导致llm 输出的结果不够准确。\n\n```js\n  import { RecursiveCharacterTextSplitter } from \"langchain/text_splitter\";\n  import { TextLoader } from \"langchain/document_loaders/fs/text\";\n\n  const loader = new TextLoader(\"./data/2.txt\");\n  const docs = await loader.load();","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":26,"to":35}}}}],["5c5bd7de-af43-493a-9383-b6aae40901d9",{"pageContent":"const loader = new TextLoader(\"./data/2.txt\");\n  const docs = await loader.load();\n\n  const splitter = new RecursiveCharacterTextSplitter({\n      chunkSize: 64,\n      chunkOverlap: 0,\n    });\n\n  const splitDocs = await splitter.splitDocuments(docs);\n  console.log(splitDocs);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":34,"to":44}}}}],["6cb415f2-32ed-446a-82f9-6d60063a2181",{"pageContent":"输出内容如下：\n```json\n  [\n    Document {\n      pageContent: \"鲁镇的酒店的格局，是和别处不同的：都是当街一个曲尺形的大柜台，柜里面预备着热水，可以随时温酒。做工的人，傍午傍晚散了工，每每花四\",\n      metadata: { source: \"./data/2.txt\", loc: { lines: { from: 1, to: 1 } } }\n    },\n    Document {\n      pageContent: \"文铜钱，买一碗酒，——这是二十多年前的事，现在每碗要涨到十文，——靠柜外站着，热热的喝了休息；倘肯多花一文，便可以买一碟盐煮笋，\",\n      metadata: { source: \"./data/2.txt\", loc: { lines: { from: 1, to: 1 } } }\n    },\n    Document {\n      pageContent: \"或者茴香豆，做下酒物了，如果出到十几文，那就能买一样荤菜，但这些顾客，多是短衣帮，大抵没有这样阔绰。只有穿长衫的，才踱进店面隔壁\",","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":46,"to":58}}}}],["543aba35-f180-4836-a775-7565be75903b",{"pageContent":"pageContent: \"或者茴香豆，做下酒物了，如果出到十几文，那就能买一样荤菜，但这些顾客，多是短衣帮，大抵没有这样阔绰。只有穿长衫的，才踱进店面隔壁\",\n      metadata: { source: \"./data/2.txt\", loc: { lines: { from: 1, to: 1 } } }\n    },\n    ...\n  ]\n```\n可以在 [ChunkViz](https://chunkviz.up.railway.app/) 查看文本切分效果。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":58,"to":64}}}}],["33dc17f3-88db-4b00-a6f7-9f3235ec0222",{"pageContent":"### Code\n\nlangchain 所支持的语言是一直在变动的，可以通过这个函数查询目前支持的语言：\n```js\n  import { SupportedTextSplitterLanguages } from \"langchain/text_splitter\";\n\n  console.log(SupportedTextSplitterLanguages); \n```\n\n切分 js 代码案例：\n```js\n  import { RecursiveCharacterTextSplitter } from \"langchain/text_splitter\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":66,"to":77}}}}],["40ea9310-2c29-4f86-8291-2f273de8548b",{"pageContent":"切分 js 代码案例：\n```js\n  import { RecursiveCharacterTextSplitter } from \"langchain/text_splitter\";\n\n  const js = `\n    function myFunction(name, job){\n      console.log(\"Welcome \" + name + \", the \" + job);\n    }\n    \n    myFunction('小明','司机');\n    \n    function forFunction(){\n      for (let i = 0; i < 5; i++){\n            console.log(\"当前数字是\" + i)\n      }\n    }\n    \n    forFunction();\n    `;","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":75,"to":93}}}}],["b00bc8a8-00ad-4403-b0b6-c5d0e5067b2d",{"pageContent":"const splitter = RecursiveCharacterTextSplitter.fromLanguage(\"js\", {\n    chunkSize: 64,\n    chunkOverlap: 0,\n  });\n\n  const jsOutput = await splitter.createDocuments([js]);\n  console.log(jsOutput);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":95,"to":102}}}}],["d32c5895-ece9-4b5f-8b30-b0d4c3b81d33",{"pageContent":"输出内容如下：\n```json\n  [\n    Document {\n      pageContent: \"function myFunction(name, job){\",\n      metadata: { loc: { lines: { from: 2, to: 2 } } }\n    },\n    Document {\n      pageContent: 'console.log(\"Welcome \" + name + \", the \" + job);\\n    }',\n      metadata: { loc: { lines: { from: 3, to: 4 } } }\n    },\n    Document {\n      pageContent: \"myFunction('小明','司机');\",\n      metadata: { loc: { lines: { from: 6, to: 6 } } }\n    },\n    Document {","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":104,"to":119}}}}],["ac33b0cb-2ac9-45e0-b339-e44df80b4d94",{"pageContent":"metadata: { loc: { lines: { from: 6, to: 6 } } }\n    },\n    Document {\n      pageContent: \"function forFunction(){\\n    \\tfor (let i = 0; i < 5; i++){\",\n      metadata: { loc: { lines: { from: 8, to: 9 } } }\n    },\n    Document {\n      pageContent: 'console.log(\"当前数字是\" + i)\\n    \\t}\\n    }',\n      metadata: { loc: { lines: { from: 10, to: 12 } } }\n    },\n    Document {\n      pageContent: \"forFunction();\",\n      metadata: { loc: { lines: { from: 14, to: 14 } } }\n    }\n  ]\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":117,"to":132}}}}],["c69dae18-4182-4f49-b73d-a820b7a2cbde",{"pageContent":"对 js 的分割本质就是将 js 中常见的切分代码的特定字符传给 RecursiveCharacterTextSplitter，然后还是根据 Recursive 的逻辑进行切分。\n\n### Token\n  根据 token 的数量进行切分，仅适合对 token 比较敏感的场景，或者与其他切分函数组合使用。\n\n```js\n  import { TokenTextSplitter } from \"langchain/text_splitter\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":134,"to":140}}}}],["d2be3c38-a15c-4b3c-8d5b-a0009445c282",{"pageContent":"```js\n  import { TokenTextSplitter } from \"langchain/text_splitter\";\n\n  const text = \"From then on, I stood at the counter all day, focusing on my duties. Although I didn't fail to do my job, I always felt a little monotonous and bored. The shopkeeper had a fierce face, and the customers were not in a good mood, which made people feel depressed. Only when Kong Yiji came to the store could I laugh a few times, so I still remember it.\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":139,"to":142}}}}],["dc0da0f0-3e33-4403-a167-ead45e6c7371",{"pageContent":"const splitter = new TokenTextSplitter({\n    chunkSize: 20,\n    chunkOverlap: 0,\n  });\n\n  const docs = await splitter.createDocuments([text]);\n  console.log(docs);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":144,"to":151}}}}],["3eeb2a62-7cc0-4761-b91c-bee5f9272798",{"pageContent":"输出内容如下：\n```json\n  [\n    Document {\n      pageContent: \"From then on, I stood at the counter all day, focusing on my duties. Although I didn\",\n      metadata: { loc: { lines: { from: 1, to: 1 } } }\n    },\n    Document {\n      pageContent: \"'t fail to do my job, I always felt a little monotonous and bored. The shop\",\n      metadata: { loc: { lines: { from: 1, to: 1 } } }\n    },\n    Document {","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":153,"to":164}}}}],["328886c4-d6bd-402f-b807-ba776f4cd892",{"pageContent":"metadata: { loc: { lines: { from: 1, to: 1 } } }\n    },\n    Document {\n      pageContent: \"keeper had a fierce face, and the customers were not in a good mood, which made people feel\",\n      metadata: { loc: { lines: { from: 1, to: 1 } } }\n    },\n    Document {\n      pageContent: \" depressed. Only when Kong Yiji came to the store could I laugh a few times, so I\",\n      metadata: { loc: { lines: { from: 1, to: 1 } } }\n    },\n    Document {\n      pageContent: \" still remember it.\",","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":162,"to":173}}}}],["fc79642b-7159-48b9-a65a-0f748fef1053",{"pageContent":"},\n    Document {\n      pageContent: \" still remember it.\",\n      metadata: { loc: { lines: { from: 1, to: 1 } } }\n    }\n  ]\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":171,"to":177}}}}],["ad34f656-194a-474a-ab24-347ec2f0ecf8",{"pageContent":"## 构建向量数据库\n\n### Embedding\n  Embedding 是将文本转换为向量表示的过程，向量表示可以进行相似性搜索。\n\n  langchain 提供了多种 Embedding 模型，包括 OpenAI Embedding、AlibabaTongyiEmbeddings、BaiduQianfanEmbeddings 等。\n\n  首先将小说切分成块：\n```js\n  import { TextLoader } from \"langchain/document_loaders/fs/text\";\n  import { RecursiveCharacterTextSplitter } from \"langchain/text_splitter\";\n\n  const loader = new TextLoader(\"./data/2.txt\");\n  const docs = await loader.load();","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":179,"to":192}}}}],["41d3eb42-c688-4371-b69b-04f3c270d402",{"pageContent":"const loader = new TextLoader(\"./data/2.txt\");\n  const docs = await loader.load();\n\n  const splitter = new RecursiveCharacterTextSplitter({\n    chunkSize: 100,\n    chunkOverlap: 20,\n  });\n\n  const splitDocs = await splitter.splitDocuments(docs);\n  console.log(splitDocs[0].pageContent);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":191,"to":201}}}}],["22322cb6-5e71-438b-8279-9b03bf9a0964",{"pageContent":"这样切分出来的块较小，也会节约 embedding 时的花费。参考自[langchain.js](https://v02.api.js.langchain.com/interfaces/langchain_community_embeddings_baidu_qianfan.BaiduQianfanEmbeddingsParams.html)\n```js\n  import { AlibabaTongyiEmbeddings } from \"@langchain/community/embeddings/alibaba_tongyi\";\n  // import { BaiduQianfanEmbeddings } from \"@langchain/community/embeddings/baidu_qianfan\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":203,"to":206}}}}],["7fe73108-ba08-475e-9961-ab7160e879d9",{"pageContent":"const model = new AlibabaTongyiEmbeddings({\n    modelName: \"text-embedding-v2\", // text-embedding-v1, text-embedding-async-v1, text-embedding-async-v2\n  });\n\n  // const modal = new BaiduQianfanEmbeddings({\n  //   modelName: \"embedding-v1\", // \"embedding-v1\" | \"bge_large_zh\" | \"bge-large-en\" | \"tao-8k\";\n  // })\n\n  const res = await model.embedQuery(splitDocs[0].pageContent);\n  console.log({ res });\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":208,"to":218}}}}],["b06d8e81-a0b0-49c6-bb0c-5c85b9a37df4",{"pageContent":"输出内容如下：\n```json\n  [\n    0.0059506547612028894,    0.006405104322379424,    0.04041307981709012,\n    -0.01886294990158835,   -0.039227559222716556,   0.011387583931510565,\n    0.014779490076523833,      0.0457084051386254, -0.0027415163744888794,\n    0.010537960838876172,   -0.002453369007800859,   0.017795981366652138,\n    -0.00467951323501345,   -0.008693817692072843,   -0.04162494531356088,\n    0.011611515599336684,    -0.00843036867110094,  -0.032009056048086376,","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":220,"to":228}}}}],["60b8668a-41b5-434d-9a1a-e520cd0b6c75",{"pageContent":"0.011611515599336684,    -0.00843036867110094,  -0.032009056048086376,\n    0.03506506469136047,   -0.013119761244400835,   0.021220818639286893,\n    0.033826854292792516,    0.025844348957343815,   0.005384239366113295,\n    0.05226828576082582,    0.010202063337136994,  -0.006125189737596776,\n    -0.017875016072943707,    0.033326301152945895,   0.030718155845324044,\n    0.011888137071357182,    0.014384316545065976,    0.00448851269480882,\n    0.023670894534325602,\n    ... 1436 more items","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":228,"to":235}}}}],["c0add16a-f465-41a1-ac7c-9f50a3b7c722",{"pageContent":"0.023670894534325602,\n    ... 1436 more items\n]\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":234,"to":237}}}}],["381f4a51-32fa-479c-8efc-7d3e1bf9761f",{"pageContent":"### 创建 MemoryVectorStore\n\n  MemoryVectorStore 是一个内存中的向量数据库，将文档和向量存储在内存中，方便后续查询。\n  embedding 向量是需要有一定花费的，所以仅在学习和测试时使用 MemoryVectorStore，而在真实项目中，搭建其他向量数据库，或者使用云数据库。\n\n  创建 MemoryVectorStore 的实例，传入需要 embeddings 的模型，调用添加文档的函数 addDocuments，langchain 的 MemoryVectorStore 会自动完成对每个文档请求 embeddings 的模型，然后存入数据库。\n\n```js\n  import { MemoryVectorStore } from \"langchain/vectorstores/memory\";\n\n  const vectorstore = new MemoryVectorStore(model);\n  await vectorstore.addDocuments(splitDocs);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":239,"to":251}}}}],["4ad84b0d-02b0-46a5-b78e-5530a8f0c128",{"pageContent":"创建一个 retriever，这也是可以直接从 vector store 的实例中自动生成的，传入参数 2，代表对应每个输入，需要返回相似度最高的两个文本内容。\n```js\n  const retriever = vectorstore.asRetriever(2);\n\n  // 提取文档内容\n  const res = await retriever.invoke(\"茴香豆是做什么用的\");\n  console.log(res);\n```\n  为了提高回答质量，返回更多的数据源是有价值的\n\n### 构建本地 vector store\n\n  因为数据生成 embedding 需要一定的花费，所以把 embedding 的结果持久化，这样就可以在应用中持续复用。\n  推荐使用 facebook 开源的 [faiss](https://github.com/facebookresearch/faiss) 向量数据库，既支持 js，也支持 python。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":253,"to":266}}}}],["2fab9052-29bd-4c63-8185-310fe38695ff",{"pageContent":"示例如下：\n  首先创建 node 项目，安装依赖\n```js\n  yarn add dotenv faiss-node langchain\n```\n\n  将 txt 文件 embeddings，存入 db 文件夹内的文件中\n```js\n  import { TextLoader } from \"langchain/document_loaders/fs/text\";\n  import { RecursiveCharacterTextSplitter } from \"langchain/text_splitter\";\n  import \"dotenv/config\";\n  import { FaissStore } from \"@langchain/community/vectorstores/faiss\";\n  import { AlibabaTongyiEmbeddings } from \"@langchain/community/embeddings/alibaba_tongyi\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":268,"to":280}}}}],["54795368-1b6b-4e7e-b4f6-119b8c42453c",{"pageContent":"const run = async () => {\n    const loader = new TextLoader(\"./data/2.txt\");\n    const docs = await loader.load();\n\n    const splitter = new RecursiveCharacterTextSplitter({\n      chunkSize: 100,\n      chunkOverlap: 20,\n    });\n\n    const splitDocs = await splitter.splitDocuments(docs);\n\n    const embeddings = new AlibabaTongyiEmbeddings({});\n    const vectorStore = await FaissStore.fromDocuments(splitDocs, embeddings);","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":282,"to":294}}}}],["387a29dd-f86c-4a50-b639-eb5d86fa2748",{"pageContent":"const directory = \"./db/2\";\n    await vectorStore.save(directory);\n  };\n\n  run();\n```\n\n  重新新建一个文件来加载存储好的 vector store:\n```js\n  import \"dotenv/config\";\n  import { FaissStore } from \"@langchain/community/vectorstores/faiss\";\n  import { AlibabaTongyiEmbeddings } from \"@langchain/community/embeddings/alibaba_tongyi\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":296,"to":307}}}}],["8d0d7bda-84f7-42f5-b51c-7bae92774ab7",{"pageContent":"const directory = \"./db/2\";\n  const embeddings = new AlibabaTongyiEmbeddings({});\n  const vectorstore = await FaissStore.load(directory, embeddings);\n  const retriever = vectorstore.asRetriever(2); // 根据相似度返回相关内容\n  const res = await retriever.invoke(\"孔乙己是干什么的\");\n  console.log(res);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":309,"to":315}}}}],["0fb899c2-70b0-46f6-89da-3e8c957cfc4b",{"pageContent":"输出内容如下：\n```json\n  [\n    {\n      pageContent: '孔乙己喝过半碗酒，涨红的脸色渐渐复了原，旁人便又问道，“孔乙己，你当真认识字么？”孔乙己看着问他的人，显出不屑置辩的神气。他们便接着说道，“你怎的连半个秀才也捞不到呢？”孔乙己立刻显出颓唐不安模样，',\n      metadata: { source: './data/2.txt', loc: [Object] }\n    },\n    {\n      pageContent: '洗。他对人说话，总是满口之乎者也，叫人半懂不懂的。因为他姓孔，别人便从描红纸上的“上大人孔乙己”这半懂不懂的话里，替他取下一个绰号，叫作孔乙己。孔乙己一到店，所有喝酒的人便都看着他笑，有的叫道，“孔乙',\n      metadata: { source: './data/2.txt', loc: [Object] }\n    }\n  ]\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":317,"to":329}}}}],["de3a5614-b469-468b-baf4-477afc755568",{"pageContent":"[参考自](https://js.langchain.com/v0.2/docs/integrations/vectorstores/faiss/#create-a-new-index-from-texts)\n\n## retriever 常见优化方式\n\n  在 llm 中，如果用户提问的关键词缺少，或者跟原文中的关键词不一致，就容易导致 retriever 返回的文档质量不高，影响 llm 的最终输出效果。\n  因此可以对 retriever 进行优化，来提高返回内容与用户提问的相关性及内容质量。\n\n### MultiQueryRetriever\n  MultiQueryRetriever 是一个 retriever，它将输入的查询拆分成多个查询，然后分别调用基础的 retriever，然后合并结果。\n  MultiQueryRetriever 的构造函数需要传入基础的 retriever，以及拆分查询的函数。\n  MultiQueryRetriever 的 invoke 函数接收一个查询，然后调用基础的 retriever，合并结果。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":331,"to":341}}}}],["2719b02d-95b2-4f3d-8b30-b1d7722efe01",{"pageContent":"```js\n  import { FaissStore } from \"@langchain/community/vectorstores/faiss\";\n  import { AlibabaTongyiEmbeddings } from \"@langchain/community/embeddings/alibaba_tongyi\";\n  import { ChatAlibabaTongyi } from \"@langchain/community/chat_models/alibaba_tongyi\";\n  import { MultiQueryRetriever } from \"langchain/retrievers/multi_query\";\n  import \"faiss-node\";\n  import \"dotenv/config\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":343,"to":349}}}}],["1fc1c0a4-a01d-4d4e-b070-ecdc364c6309",{"pageContent":"async function run() {\n    const directory = \"./db/2\";\n    const embeddings = new AlibabaTongyiEmbeddings({});\n    const vectorstore = await FaissStore.load(directory, embeddings);","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":351,"to":354}}}}],["bd79af06-7fba-4978-9230-70c64f23861e",{"pageContent":"const model = new ChatAlibabaTongyi({\n      model: \"qwen-turbo\", // Available models: qwen-turbo, qwen-plus, qwen-max\n      temperature: 1,\n    });\n    const retriever = MultiQueryRetriever.fromLLM({\n      llm: model,\n      retriever: vectorstore.asRetriever(3), // 每次会检索三条数据，对每个 query\n      queryCount: 3, // 默认值是 3，表示对每条输入，llm 都会改写生成三条不同的写法和措词，表示同样意义的 query\n      verbose: true, // 设置为 true 会打印出 chain 内部的详细执行过程方便 debug\n    });\n    const res = await retriever.invoke(\"茴香豆是做什么用的\");","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":356,"to":366}}}}],["9968fefd-f4bc-4d97-b61a-d22cb624e4c1",{"pageContent":"console.log(res);\n  }\n\n  run();\n```\n\n### Document Compressor\n\n  Retriever 的另一个问题，如果设置 k（每次检索返回的文档数）较小，因为自然语言的特殊性，可能相似度排名较高的并不是答案，就像搜索引擎依靠的也是相似性的度量，但排名最高的并不一定是最高质量的答案。而如果设置的 k 过大，就会导致大量的文档内容，可能会撑爆 llm 上下文窗口。\n\n  ContextualCompressionRetriever  是一个 retriever，它将输入的文档进行压缩，然后调用基础的 retriever。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":368,"to":378}}}}],["8334462f-24d6-4d0f-9174-cb2ad20957c8",{"pageContent":"```js\n  import { FaissStore } from \"@langchain/community/vectorstores/faiss\";\n  import { AlibabaTongyiEmbeddings } from \"@langchain/community/embeddings/alibaba_tongyi\";\n  import { ChatAlibabaTongyi } from \"@langchain/community/chat_models/alibaba_tongyi\";\n  import \"dotenv/config\";\n  import { LLMChainExtractor } from \"langchain/retrievers/document_compressors/chain_extract\";\n  import { ContextualCompressionRetriever } from \"langchain/retrievers/contextual_compression\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":380,"to":386}}}}],["fd9cb0ab-ab99-440e-ad08-d8b0beaf1551",{"pageContent":"// process.env.LANGCHAIN_VERBOSE = \"true\";\n\n  async function run() {\n    const directory = \"./db/2\";\n    const embeddings = new AlibabaTongyiEmbeddings();\n    const vectorstore = await FaissStore.load(directory, embeddings);\n\n    const model = new ChatAlibabaTongyi({\n      model: \"qwen-turbo\", // Available models: qwen-turbo, qwen-plus, qwen-max\n      temperature: 1,\n    });\n    const compressor = LLMChainExtractor.fromLLM(model);","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":388,"to":399}}}}],["97ea3772-e3d4-488d-ba0c-f7688b0884ad",{"pageContent":"const retriever = new ContextualCompressionRetriever({\n      baseCompressor: compressor,\n      baseRetriever: vectorstore.asRetriever(2),\n    });\n    const res = await retriever.invoke(\"茴香豆是做什么用的\");\n    console.log(res);\n  }\n\n  run();\n```\n\n核心参数\n- baseCompressor：    压缩上下文时会调用 chain，接收任何符合 Runnable interface 的对象\n- baseRetriever：     在检索数据时用到的 retriever\n\n\n### ScoreThresholdRetriever\n\n  ScoreThresholdRetriever 是一个 retriever，它将输入的查询和文档进行匹配，然后根据匹配得分进行过滤。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":401,"to":419}}}}],["7f8b9e9a-7295-4019-8456-3525bdae07fd",{"pageContent":"### ScoreThresholdRetriever\n\n  ScoreThresholdRetriever 是一个 retriever，它将输入的查询和文档进行匹配，然后根据匹配得分进行过滤。\n\n```js \n  import { FaissStore } from \"@langchain/community/vectorstores/faiss\";\n  import { AlibabaTongyiEmbeddings } from \"@langchain/community/embeddings/alibaba_tongyi\";\n  import \"dotenv/config\";\n  import { ScoreThresholdRetriever } from \"langchain/retrievers/score_threshold\";\n\n  // process.env.LANGCHAIN_VERBOSE = \"true\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":417,"to":427}}}}],["d9cacc3a-1ef9-4500-93da-7c5434b03a19",{"pageContent":"// process.env.LANGCHAIN_VERBOSE = \"true\";\n\n  async function run() {\n    const directory = \"./db/kongyiji\";\n    const embeddings = new AlibabaTongyiEmbeddings();\n    const vectorstore = await FaissStore.load(directory, embeddings);\n\n    const retriever = ScoreThresholdRetriever.fromVectorStore(vectorstore, {\n      minSimilarityScore: 0.8,\n      maxK: 3,\n      kIncrement: 1,\n    });\n    const res = await retriever.invoke(\"茴香豆是做什么用的\");\n    console.log(res);\n  }\n\n  run();\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":427,"to":444}}}}],["b7371a42-e5fa-4d21-9442-eb3ae3f003eb",{"pageContent":"run();\n```\n\n核心参数：\n- minSimilarityScore：  定义了最小的相似度阈值，即文档向量和 query 向量相似度达到多少，就认为是可以被返回的。这个要根据文档类型设置，一般是 0.8 左右，可以避免返回大量的文档导致消耗过多的 token\n- maxK：  一次最多返回多少条数据，主要是为了避免返回太多的文档造成 token 过度的消耗\n- kIncrement：  定义了算法的布厂，你可以理解成 for 循环中的 i+k 中的 k。其逻辑是每次多获取 kIncrement 个文档，然后看这 kIncrement 个文档的相似度是否满足要求，满足则返回    \n\n## 基于私域数据进行回答\n\n构建一个基于本地 txt 文件，作为私域数据，来回答问题的 RAG bot。\n\n### 加载环境变量\n```js\n  import { load } from \"dotenv\";\n  const env = await load();\n\n  const process = {\n      env\n  };\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":443,"to":463}}}}],["b05e4e3c-6c2f-4991-87d8-5d7a9c2ca41d",{"pageContent":"const process = {\n      env\n  };\n```\n\n### 加载文章数据\n```js\n  import { TextLoader } from \"langchain/document_loaders/fs/text\";\n\n  const loader = new TextLoader(\"./data/qiu.txt\");\n  const docs = await loader.load();\n```\n\n### 切割数据\n```js\n  import { RecursiveCharacterTextSplitter } from \"langchain/text_splitter\";\n\n  const splitter = new RecursiveCharacterTextSplitter({\n      chunkSize: 500,\n      chunkOverlap: 10,\n    });\n\n  const splitDocs = await splitter.splitDocuments(docs);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":460,"to":483}}}}],["065330e8-8485-456f-8a06-d1fe9de91499",{"pageContent":"const splitDocs = await splitter.splitDocuments(docs);\n```\n\n### 构建 vector store 和 retriever\n```js\n  import { AlibabaTongyiEmbeddings } from \"@langchain/community/embeddings/alibaba_tongyi\";\n\n  const embeddings = new AlibabaTongyiEmbeddings({});\n```\n\n```js\n  import { MemoryVectorStore } from \"langchain/vectorstores/memory\";\n\n  const vectorstore = new MemoryVectorStore(embeddings);\n  await vectorstore.addDocuments(splitDocs);\n```\n\n```js\n  const retriever = vectorstore.asRetriever(2);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":482,"to":501}}}}],["45424361-9bb8-4fd1-b00e-61f08bf0825c",{"pageContent":"```js\n  const retriever = vectorstore.asRetriever(2);\n```\n\n**测试提问**\n```js\n  const res = await retriever.invoke(\"原文中，谁提出了宏原子的假设？并详细介绍宏原子假设的理论\");\n  console.log(res);\n```\n\n### 添加处理函数，将回答处理成普通文本\n```js\n  import { RunnableSequence } from \"@langchain/core/runnables\";\n  import { Document } from \"@langchain/core/documents\";\n\n  const convertDocsToString = (list) => {\n    return list.map((document) => document.pageContent).join(\"\\n\")\n  };","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":499,"to":516}}}}],["76967e44-9feb-42ee-9173-748ec1320392",{"pageContent":"const contextRetriverChain = RunnableSequence.from([\n    (input) => input.question,\n    retriever,\n    convertDocsToString\n  ]);\n```\n\nRunnableSequence 构建了一个简单的 chain，传入一个数组，并且把第一个 Runnable 对象返回的结果自动传入给后面的 Runnable 对象。\ncontextRetriverChain，接收一个 input 对象作为输入，获得其 question 属性，传递给 retriever，返回的 Document 对象输入作为参数传递给 convertDocsToString 转换成纯文本。\n\n测试 chain：\n```js\n  const result = await contextRetriverChain.invoke({ question: \"原文中，谁提出了宏原子的假设？并详细介绍宏原子假设的理论\"});\n\n  console.log(result);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":518,"to":533}}}}],["3b6336b5-77f8-4a32-bb86-ebfe63075420",{"pageContent":"console.log(result);\n```\n\n### 构建 Template\n\n```js\n  import { ChatPromptTemplate } from \"@langchain/core/prompts\";\n\n  const TEMPLATE = `\n    你是一个熟读刘慈欣的《球状闪电》的终极原著党，精通根据作品原文详细解释和回答问题，你在回答时会引用作品原文。\n    并且回答时仅根据原文，尽可能回答用户问题，如果原文中没有相关内容，你可以回答“原文中没有相关内容”，\n\n    以下是原文中跟用户回答相关的内容：\n    {context}\n\n    现在，你需要基于原文，回答以下问题：\n    {question}`;\n\n  const prompt = ChatPromptTemplate.fromTemplate(\n    TEMPLATE\n  );\n```\n\n### 定义 LLM 模型","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":532,"to":555}}}}],["2ece56e9-2257-4621-a502-1400d691189a",{"pageContent":"const prompt = ChatPromptTemplate.fromTemplate(\n    TEMPLATE\n  );\n```\n\n### 定义 LLM 模型\n\n```js\n  import { ChatAlibabaTongyi } from \"@langchain/community/chat_models/alibaba_tongyi\";\n  const model = new ChatAlibabaTongyi({\n    model: \"qwen-turbo\", // Available models: qwen-turbo, qwen-plus, qwen-max\n    temperature: 1,\n  });\n```\n\n### 组件完整的 Chain\n```js\n  import { StringOutputParser } from \"@langchain/core/output_parsers\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":550,"to":567}}}}],["6e633cb5-1250-4ebf-af57-0c9203383742",{"pageContent":"### 组件完整的 Chain\n```js\n  import { StringOutputParser } from \"@langchain/core/output_parsers\";\n\n  const ragChain = RunnableSequence.from([\n    {\n        context: contextRetriverChain,\n        question: (input) => input.question,\n    },\n    prompt,\n    model,\n    new StringOutputParser()\n  ]);\n```\n\n### 测试 chain bot\n```js\n  const res = await ragChain.invoke({\n    question: \"什么是球状闪电\"\n  });  \n  console.log(res);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":565,"to":586}}}}],["61ccfbd7-f6e3-4cef-87cb-465cc3a62722",{"pageContent":"输出内容如下:\n```js\n  球状闪电是一种在《球状闪电》这部科幻小说中描述的自然现象，它并非严格意义上的科学术语，而是刘慈欣作品中的虚构概念。在书中，球状闪电被描绘为一种能产生量子态、具有神秘特性的能量体，它可以被技术手段如雷球机枪操控。尽管它的军事应用被提及，但其本质和工作原理并未详尽揭示，仅仅是宏电子技术让人类得以窥探物质微观世界的另一种方式。\n```\n\n```js\n  const res = await ragChain.invoke({\n    question: \"静夜思这首诗是什么\"\n  });  \n  console.log(res);\n```\n\n输出：\n```js\n  原文中并没有提到“静夜思”这首诗，所以无法提供相关的内容。\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api1.mdx","loc":{"lines":{"from":588,"to":603}}}}],["09d7be8c-2d0d-4f7a-83fa-edf96775ec0b",{"pageContent":"---\ntitle: RAG检索增强生成(三)\ndate: '2024-05-26'\ntags: ['AI大模型', 'javaScript', 'Deno']\ndraft: false\nsummary: 大模型 Memory 实现聊天历史\n---\n\n## Chat History\n\n### ChatMessageHistory\n\n  chat history 是一组 Message 子类对象组成的列表，Message 子类可能是 HumanMessage、AIMessages。chat history 负责记录聊天历史。memory\n  模块负责将聊天记录的摘要或者最近几条聊天记录,转换为向量数据库中的向量，存储到向量数据库中。\n\n  创建一个 history 对象：\n```js\n  import { ChatMessageHistory } from \"langchain/stores/message/in_memory\";\n  import { HumanMessage, AIMessage } from \"@langchain/core/messages\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":1,"to":19}}}}],["3e3484d5-bc84-46fa-a281-e18a223687eb",{"pageContent":"const history = new ChatMessageHistory();\n```\n\n  添加消息：\n```js\n  await history.addMessage(new HumanMessage(\"你好\"));\n  await history.addMessage(new AIMessage(\"你好啊！\"));\n```\n\n  获取历史记录\n```js\n  const messages = await history.getMessages();\n\n  console.log(messages);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":21,"to":35}}}}],["084545c7-81c4-4cff-ab4f-3d774b211f41",{"pageContent":"输出内容如下：\n```json\n  [\n    HumanMessage {\n      lc_serializable: true,\n      lc_kwargs: { content: \"你好\", additional_kwargs: {}, response_metadata: {} },\n      lc_namespace: [ \"langchain_core\", \"messages\" ],\n      content: \"你好\",\n      name: undefined,\n      additional_kwargs: {},\n      response_metadata: {}\n    },\n    AIMessage {\n      lc_serializable: true,\n      lc_kwargs: { content: \"你好啊！\", additional_kwargs: {}, response_metadata: {} },\n      lc_namespace: [ \"langchain_core\", \"messages\" ],","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":37,"to":52}}}}],["21add748-59fd-4323-9729-6626816cb4f9",{"pageContent":"lc_namespace: [ \"langchain_core\", \"messages\" ],\n      content: \"你好啊！\",\n      name: undefined,\n      additional_kwargs: {},\n      response_metadata: {}\n    }\n  ]\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":52,"to":59}}}}],["e6e52b8e-7a02-4c88-99b4-da1400741c86",{"pageContent":"### 手动维护 chat history\n\n```js\n  import { ChatPromptTemplate, MessagesPlaceholder } from \"@langchain/core/prompts\";\n  import { ChatAlibabaTongyi } from \"@langchain/community/chat_models/alibaba_tongyi\";\n\n  const chatModel = new ChatAlibabaTongyi({\n    model: \"qwen-turbo\", // Available models: qwen-turbo, qwen-plus, qwen-max\n    temperature: 1,\n  });","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":61,"to":70}}}}],["0603b48e-d982-4dd1-8ca0-18f7664e811d",{"pageContent":"const prompt = ChatPromptTemplate.fromMessages([\n      [\"system\", `你是一个乐于助人的助手，尽你所能地回答所有问题。\n      你很健谈，能从上下文中提供大量具体细节。\n      如果你不知道问题的答案，那就如实地说你不知道。`],\n      new MessagesPlaceholder(\"history_message\"),\n  ]);\n\n  const chain = prompt.pipe(chatModel);\n```\n其中 MessagesPlaceholder 创建一个名为 history_message 的插槽，chain 中对应的参数将会替换这部分。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":72,"to":81}}}}],["d13c8f67-c0c8-4110-b248-a623c53ed9da",{"pageContent":"创建一个 chat history，然后向其中添加一条历史记录：\n```js\n  import { ChatMessageHistory } from \"langchain/stores/message/in_memory\";\n  import { HumanMessage, AIMessage } from \"@langchain/core/messages\";\n\n  const history = new ChatMessageHistory();\n  await history.addMessage(new HumanMessage(\"你好，我是叮当猫\"));\n\n  const res1 = await chain.invoke({\n    history_message: await history.getMessages()\n  });\n\n  console.log(res1);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":83,"to":96}}}}],["280bec7f-b383-450b-ad46-9a28f502baa5",{"pageContent":"返回内容如下：\n```json\n  AIMessage {\n    lc_serializable: true,\n    lc_kwargs: {\n      content: \"你好，叮当猫！很高兴见到你。如果你有任何问题或者需要帮助，请随时告诉我。\",\n      tool_calls: [],\n      invalid_tool_calls: [],\n      additional_kwargs: {},\n      response_metadata: {}\n    },\n    lc_namespace: [ \"langchain_core\", \"messages\" ],\n    content: \"你好，叮当猫！很高兴见到你。如果你有任何问题或者需要帮助，请随时告诉我。\",\n    name: undefined,\n    additional_kwargs: {},\n    response_metadata: {","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":98,"to":113}}}}],["fc4335e9-c57f-4614-8985-7d72baae261c",{"pageContent":"name: undefined,\n    additional_kwargs: {},\n    response_metadata: {\n      tokenUsage: { promptTokens: 64, completionTokens: 20, totalTokens: 84 }\n    },\n    tool_calls: [],\n    invalid_tool_calls: []\n  }\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":111,"to":119}}}}],["1e2a6d20-28fb-43b1-8966-e4e06e3fa9f1",{"pageContent":"添加一条人类新提问：\n\n```js\n  await history.addMessage(res1)\n  await history.addMessage(new HumanMessage(\"我是谁\"));\n```\n\n获取回答，传入history\n```js\n  const res2 = await chain.invoke({\n    history_message: await history.getMessages(),\n  });\n  console.log(res2);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":121,"to":134}}}}],["a852465a-7187-46ce-85da-410f8a541285",{"pageContent":"返回内容如下：\n```json\n  AIMessage {\n    lc_serializable: true,\n    lc_kwargs: {\n      content: \"你自称是叮当猫，这通常指的是卡通角色《蓝皮鼠和大脸猫》中的角色，或者在一些衍生作品中，也可能指代哆啦A梦（Doraemon）系列里的叮当猫（Ding Dong Bell）。如果你在玩某个角色扮演游戏或\"... 20 more characters,\n      tool_calls: [],\n      invalid_tool_calls: [],\n      additional_kwargs: {},\n      response_metadata: {}\n    },\n    lc_namespace: [ \"langchain_core\", \"messages\" ],","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":136,"to":147}}}}],["f6588196-4e7b-4a35-aafd-67f5b59b8e41",{"pageContent":"response_metadata: {}\n    },\n    lc_namespace: [ \"langchain_core\", \"messages\" ],\n    content: \"你自称是叮当猫，这通常指的是卡通角色《蓝皮鼠和大脸猫》中的角色，或者在一些衍生作品中，也可能指代哆啦A梦（Doraemon）系列里的叮当猫（Ding Dong Bell）。如果你在玩某个角色扮演游戏或\"... 20 more characters,\n    name: undefined,\n    additional_kwargs: {},\n    response_metadata: {\n      tokenUsage: { promptTokens: 96, completionTokens: 73, totalTokens: 169 }\n    },\n    tool_calls: [],\n    invalid_tool_calls: []\n  }\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":145,"to":157}}}}],["07df8c3b-6aad-46a8-9cb7-26682cfc52c3",{"pageContent":"### 自动维护 chat history\n\n  使用 RunnableWithMessageHistory 给任意 chain 包裹一层，就能添加聊天记录管理的能力。\n\n```js\n  import { RunnableWithMessageHistory } from \"@langchain/core/runnables\";\n\n  const chatModel = new ChatAlibabaTongyi({\n    model: \"qwen-turbo\", // Available models: qwen-turbo, qwen-plus, qwen-max\n    temperature: 1,\n  });\n\n  const prompt = ChatPromptTemplate.fromMessages([\n    [\"system\", \"你是一个乐于助人的助手，尽你所能地回答所有问题。\"],\n    new MessagesPlaceholder(\"history_message\"),\n    [\"human\",\"{input}\"]\n  ]);","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":159,"to":175}}}}],["35ddf9d9-fd66-4664-9f76-72b03122f582",{"pageContent":"const history = new ChatMessageHistory();\n  const chain = prompt.pipe(chatModel)\n\n  const chainWithHistory = new RunnableWithMessageHistory({\n    runnable: chain,\n    getMessageHistory: (_sessionId) => history,\n    inputMessagesKey: \"input\",\n    historyMessagesKey: \"history_message\",\n  });\n```\n\nRunnableWithMessageHistory 参数含义：","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":177,"to":188}}}}],["c8daf015-5798-4294-9919-e92c3b9a3b10",{"pageContent":"RunnableWithMessageHistory 参数含义：\n\n- runnable： 需要被包裹的 chain，可以是任意 chain\n- getMessageHistory： 接收一个函数，函数需要根据传入的 _sessionId，去获取对应的 ChatMessageHistory 对象\n- inputMessagesKey：用户传入的信息 key 的名称，因为 RunnableWithMessageHistory 要自动记录用户和 llm 发送的信息，所以需要在这里声明用户传入信息的 key\n- historyMessagesKey： 聊天记录在 prompt 中的 key，因为要自动的把聊天记录注入到 prompt 中\n- outputMessagesKey： 只有一个输出就省略，如果有多个输出需要指定哪个是 llm 的回复，也就是需要存储的信息","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":188,"to":194}}}}],["678a22dd-e973-4439-9bb0-97e47f48d506",{"pageContent":"直接调用这个 chain，历史记录会自动保存，这里除了正常 invoke 传入的参数外，还需要指定当前对话的 sessionId。\n```js\n  const res1 = await chainWithHistory.invoke({\n    input: \"你好，我是叮当猫\",\n  },{\n      configurable: { sessionId: \"none\" }\n  });\n  console.log(res1);\n```\n\n再次提问：\n```js\n  const res2 = await chainWithHistory.invoke({\n    input: \"我是谁\",\n  },{\n      configurable: { sessionId: \"none\" }\n  });\n  console.log(res2);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":196,"to":214}}}}],["ed5c46d0-10ae-40ad-9f8c-0c44d15e352a",{"pageContent":"返回内容如下：\n```json\n  AIMessage {\n    lc_serializable: true,\n    lc_kwargs: {\n      content: \"你自称是叮当猫，这通常是指卡通角色《蓝猫淘气三千问》中的主角之一，或者指《哆啦A梦》（Doraemon）中的重要角色，哆啦A梦的神奇小口袋里的道具“叮当”（铜锣）。如果你在玩角色扮演游戏或者有其他特定\"... 36 more characters,\n      tool_calls: [],\n      invalid_tool_calls: [],\n      additional_kwargs: {},\n      response_metadata: {}\n    },\n    lc_namespace: [ \"langchain_core\", \"messages\" ],","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":216,"to":227}}}}],["1ae6a6f0-1ca9-4df3-a1ba-0be680c53fa9",{"pageContent":"response_metadata: {}\n    },\n    lc_namespace: [ \"langchain_core\", \"messages\" ],\n    content: \"你自称是叮当猫，这通常是指卡通角色《蓝猫淘气三千问》中的主角之一，或者指《哆啦A梦》（Doraemon）中的重要角色，哆啦A梦的神奇小口袋里的道具“叮当”（铜锣）。如果你在玩角色扮演游戏或者有其他特定\"... 36 more characters,\n    name: undefined,\n    additional_kwargs: {},\n    response_metadata: {\n      tokenUsage: { promptTokens: 72, completionTokens: 90, totalTokens: 162 }\n    },\n    tool_calls: [],\n    invalid_tool_calls: []\n  }\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":225,"to":237}}}}],["033c1613-4538-49c6-8ea1-11f637f9345b",{"pageContent":"### 自动生成 chat history 摘要\n\n  实现一个自动对当前聊天历史记录进行总结，然后让 llm 根据总结的信息回复用户的 chain。\n\n  首先实现一个总结 chain，这个 chain 接受两个参数：\n  - summary，上一次总结的信息\n  - new_lines，用户和 llm 新的回复","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":239,"to":245}}}}],["11cbb990-e0bd-49d4-8b75-c1e66ba7146e",{"pageContent":"首先实现一个总结 chain，这个 chain 接受两个参数：\n  - summary，上一次总结的信息\n  - new_lines，用户和 llm 新的回复\n\n  返回值是一个纯文本的信息，根据历史的 summary 信息和用户新的对话生成的新 summary。\n```js\n  import { ChatAlibabaTongyi } from \"@langchain/community/chat_models/alibaba_tongyi\";\n  import { ChatPromptTemplate } from \"@langchain/core/prompts\";\n  import { RunnableSequence } from \"@langchain/core/runnables\";\n  import { StringOutputParser } from \"@langchain/core/output_parsers\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":243,"to":252}}}}],["51ad6ab8-0cc0-492b-aa43-a7bdb7a91438",{"pageContent":"const summaryModel = new ChatAlibabaTongyi({\n    model: \"qwen-turbo\", // Available models: qwen-turbo, qwen-plus, qwen-max\n    temperature: 1,\n  });\n\n  const summaryPrompt = ChatPromptTemplate.fromTemplate(`\n  逐步总结所提供的对话内容，在之前的总结基础上添加新的总结\n\n  当前摘要:\n  {summary}\n\n  新的对话方式:\n  {new_lines}\n\n  新摘要:\n  `); \n\n  const summaryChain = RunnableSequence.from([\n    summaryPrompt,\n    summaryModel,\n    new StringOutputParser(),\n  ]);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":254,"to":276}}}}],["5709eff0-81db-4dd1-974c-739ea899af63",{"pageContent":"调用:\n```js\n  const newSummary = await summaryChain.invoke({\n    summary: \"\",\n    new_lines: \"我是叮当猫\"\n  });\n```\n\n再次调用，并传入上次的 summary\n```js\n  await summaryChain.invoke({\n    summary: newSummary,\n    new_lines: \"我会飞\"\n  });\n```\n\n输出内容如下：\n```json\n  '在先前的对话总结中，我们主要探讨了整体情况和可能的话题范围。随着新角色\"我是叮当猫\"的加入，对话可能转向与超自然能力、冒险、童话世界或者科幻元素相关的内容，特别是如果\"我会飞\"的能力成为讨论的核心。然'... 40 more characters\n```\n\n如此就实现了一个渐进式总结历史聊天记录的 chat bot，然后以此为基础构建一个 chat bot，其会自动将聊天记录进行 summary，并且传递给 llm 作为上下文。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":278,"to":299}}}}],["bc9c37df-58f2-4287-a2ea-6330c5aac2d7",{"pageContent":"如此就实现了一个渐进式总结历史聊天记录的 chat bot，然后以此为基础构建一个 chat bot，其会自动将聊天记录进行 summary，并且传递给 llm 作为上下文。\n\n首先创建一个基础的 prompt 模板，和用于存储聊天记录的 ChatMessageHistory，并且创建一个 summary 字符串，用来存储用户之前聊天记录的总结信息。\n```js\n  import { ChatMessageHistory } from \"langchain/stores/message/in_memory\";\n\n  const chatModel = new ChatAlibabaTongyi({\n    model: \"qwen-turbo\", // Available models: qwen-turbo, qwen-plus, qwen-max\n    temperature: 1,\n  });","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":299,"to":308}}}}],["60528c67-a3d3-4a44-80b7-a3ba560d097c",{"pageContent":"const chatPrompt = ChatPromptTemplate.fromMessages([\n      [\"system\", `你是一个乐于助人的助手，尽你所能地回答所有问题。\n\n      以下是聊天记录摘要：\n      {history_summary}\n      `],\n      [\"human\",\"{input}\"]\n  ]);\n\n  let summary = \"\"\n  const history = new ChatMessageHistory();\n```\n\n实现完整的 chain：\n```js\n  import { RunnablePassthrough } from \"@langchain/core/runnables\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":310,"to":325}}}}],["22ccdbba-5697-4ad8-afb3-0886486c51e3",{"pageContent":"const chatChain = RunnableSequence.from([\n    {\n      input: new RunnablePassthrough({\n        func: (input) => history.addUserMessage(input)\n      })\n    },\n    RunnablePassthrough.assign({\n      history_summary: () => summary\n    }),\n    chatPrompt,\n    chatModel,\n    new StringOutputParser(),\n    new RunnablePassthrough({\n      func: async (input) => {\n        history.addAIChatMessage(input);\n        const messages = await history.getMessages();","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":327,"to":342}}}}],["111eb825-76b3-458e-9859-1446c22ea6f6",{"pageContent":"history.addAIChatMessage(input);\n        const messages = await history.getMessages();\n        const new_lines = getBufferString(messages);\n        const newSummary = await summaryChain.invoke({\n            summary,\n            new_lines\n        });\n        history.clear();\n        summary = newSummary;   \n      }\n    })\n]);","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":341,"to":352}}}}],["58aa560f-5674-4beb-a22c-bee6c93790af",{"pageContent":"```\n\nRunnableMap 并行的执行多个 runnable 对象，然后返回结果对象。\n```js\n  import { RunnableMap } from \"@langchain/core/runnables\"\n\n  const mapChain = RunnableMap.from({\n      a: () => \"a\",\n      b: () => \"b\"\n  })\n\n  const res = await mapChain.invoke()\n  // { a: \"a\", b: \"b\" }\n```\n\n函数也是一种 runnable 对象，这两个函数是并行执行的。这两个函数换成任意 runnable 对象，例如两个 chain 即会并行执行这两个 chain，并且返回相应的结果。\n\n在 RunnableSequence 的数组中，如果有 object 类型的值，会被自动转换成 RunnableMap，也就是 chain 中第一个 object 对象本质上是新建了一个 RunnableMap。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":354,"to":371}}}}],["fc79ddac-5f33-4679-b34a-02b277932872",{"pageContent":"RunnablePassthrough 是一个特殊的 runnable，它不会执行任何操作，而是直接返回输入。可以理解是 runnable chain 中的特殊节点。\n\n使用代码①\n```js\n  new RunnablePassthrough({func: (input)=> void})\n```\n的目的：\n\n- 如果只写 new RunnablePassthrough()，就是把用户输入的 input 再传递到下一个 runnable 节点中，不做任何操作。因为 RunnableMap 返回值是对其中每个 chain 的执行，然后将返回值作为结果传递给下一个 runnable 节点，如果不对 input 使用 RunnablePassthrough 则下个节点就拿不到 input 的值\n- ① 中的 func 函数是在传递 input 的过程中，执行一个函数，这个函数返回值是 void，即无论其内容是什么，都不会对 input 造成影响。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":373,"to":382}}}}],["c7ebcfca-3dd1-47b6-a24d-9b15d7f9466e",{"pageContent":"测试 chain：\n```js\n  const res1 = await chatChain.invoke(\"我现在饿了\");\n  console.log(res1);\n```\n\n输出内容如下：\n```json\n  如果你饿了，可以考虑吃点东西。你可以选择制作简单的三明治、热汤或者是一碗方便面，如果你在家；外出的话，可以去附近的餐馆、便利店或者点外卖。别忘了喝点水哦。\n```\n\n继续交流：\n```js\n  const res2 = await chatChain.invoke(\"我今天想吃方便面\");\n  console.log(res2);\n```\n\n返回内容如下：\n```json\n  当然可以！如果你想要吃方便面，这里有一些建议：","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":384,"to":403}}}}],["31efe5ff-82cf-48cb-9a6c-a9b687b655b1",{"pageContent":"返回内容如下：\n```json\n  当然可以！如果你想要吃方便面，这里有一些建议：\n\n  1. **选择口味**：确保挑选你喜欢的口味，比如经典的红烧牛肉、豚骨、泡椒凤爪或者蔬菜味等。\n  2. **准备材料**：根据包装上的指示，准备好所需的配料，如调料包、蔬菜、鸡蛋（如果需要）等。\n  3. **烧水煮面**：烧一锅开水，按照方便面包装上的时间煮面，通常大约3-5分钟。\n  4. **添加配料**：煮好面后，把调料包、蔬菜或其他喜欢的配料加入，搅拌均匀。\n  5. **享受美食**：你的快速方便面就完成了，记得配一碗热水或茶，补充一下水分。\n  6. **健康小贴士**：虽然方便面快捷，但为了均衡营养，偶尔可以搭配一些蔬菜、水果或低脂酸奶来提升饱腹感和营养。\n\n  享用你的方便面时，别忘了适时休息，补充能量哦！\n```\n\n## Memory\n\n### 内置 Memory 的机制\n\n***BufferWindowMemory***","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":401,"to":419}}}}],["945e0c66-1bab-427f-8bf7-4e0d649731c3",{"pageContent":"享用你的方便面时，别忘了适时休息，补充能量哦！\n```\n\n## Memory\n\n### 内置 Memory 的机制\n\n***BufferWindowMemory***\n\n对聊天记录加了一个滑动窗口，只会记忆 k 个对话\n```js\n  import { BufferWindowMemory } from \"langchain/memory\";\n  import { ConversationChain } from \"langchain/chains\";\n  import { ChatOpenAI } from \"@/langchain/openai\";\n\n  const model = new ChatOpenAI();\n  const memory = new BufferWindowMemory({ k: 1 });\n  const chain = new ConversationChain({ llm: model, memory: memory });\n```\n\n***ConversationSummaryMemory***","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":412,"to":432}}}}],["9b3e6e56-5074-455d-bf2d-26d890d5c653",{"pageContent":"***ConversationSummaryMemory***\n\n对聊天记录进行 summary，并保存在 memory 中，每次调用 chain 时，都会将 summary 作为 prompt 的一部分，即随着聊天不断生成和更新聊天记录摘要。\n\n```js\n  import { ConversationSummaryMemory } from \"langchain/memory\";\n  import { PromptTemplate } from \"@langchain/core/prompts\";\n\n  const memory = new ConversationSummaryMemory({\n      memoryKey: \"summary\",\n      llm: new ChatOpenAI({\n        verbose: true, // 开启 verbose 模式查看内部执行\n      }),\n    });","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":432,"to":445}}}}],["b7f49035-4ccb-4a62-98cc-ac402f157ec3",{"pageContent":"const model = new ChatOpenAI();\n  const prompt = PromptTemplate.fromTemplate(`\n    你是一个乐于助人的助手，尽你所能回答所有问题。\n\n    这是聊天记录的摘要:\n    {summary}\n    Human: {input}\n    AI:`);\n  const chain = new ConversationChain({ llm: model, prompt, memory, verbose: true });\n\n  const res1 = await chain.call({ input: \"我是小明\" });\n```\n\n```js\n  const res2 = await chain.call({ input: \"我叫什么？\" });\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":447,"to":462}}}}],["30c4b4c1-a578-4add-afd4-3fe3f79728c5",{"pageContent":"```js\n  const res2 = await chain.call({ input: \"我叫什么？\" });\n```\n\n将 BufferWindowMemory 和 ConversationSummaryMemory 结合起来，根据 token 数量，如果上下文历史过大时就切换到 summary，如果上下文比较小时就使用原始的聊天记录，也就成了 ConversationSummaryBufferMemory。\n\n```js\n  import { ChatOpenAI } from \"@langchain/openai\";\n  import { ConversationSummaryBufferMemory } from \"langchain/memory\";\n  import { ConversationChain } from \"langchain/chains\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":460,"to":469}}}}],["aa74c91f-3148-44f5-abde-2791b633e4a7",{"pageContent":"const model = new ChatOpenAI();\n  const memory = new ConversationSummaryBufferMemory({\n    llm: new ChatOpenAI(),\n    maxTokenLimit: 200\n  });\n\n  const chain = new ConversationChain({ llm: model, memory: memory, verbose: true });\n```\n原理跟前面的两个 memory 的机制类似，会计算当前完整聊天记录的 token 数，判断是否超过设置的 maxTokenLimit，如果超过则对聊天记录总结成 summary 输入进去。\n\nConversationSummaryBufferMemory 的思想，短聊天使用 BufferWindowMemory、长聊天就成为 ConversationSummaryMemory。\n\n***EntityMemory***","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":471,"to":483}}}}],["374bc3ae-874e-43ad-aeb3-0cefe089eb3c",{"pageContent":"***EntityMemory***\n\nEntityMemory 是一个特殊的 Memory，它将实体（实体是任何类型的对象）存储在 memory 中，并使用 LLM 生成实体的描述。EntityMemory 希望模拟的是在聊天中去生成和更新不同的实体的描述。\n\n```js\n  import { ChatOpenAI } from \"@langchain/openai\";\n  import { EntityMemory, ENTITY_MEMORY_CONVERSATION_TEMPLATE } from \"langchain/memory\";\n  import { ConversationChain } from \"langchain/chains\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":483,"to":490}}}}],["6d5ab896-f0a1-4c3e-9cc2-1c3fc5e005ae",{"pageContent":"const model = new ChatOpenAI();\n  const memory = new EntityMemory({\n      llm: new ChatOpenAI({\n          verbose: true, // 开启 verbose 模式查看内部执行\n      }),\n      chatHistoryKey: \"history\",\n      entitiesKey: \"entities\"\n  });\n\n  const chain = new ConversationChain({ \n      llm: model, \n      prompt: ENTITY_MEMORY_CONVERSATION_TEMPLATE,\n      memory: memory, \n      verbose: true \n  });\n\n```\nENTITY_MEMORY_CONVERSATION_TEMPLATE 是 langchain 提供的用于 EntityMemory chat 的 默认的 prompt。也可以自定义 prompt。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":492,"to":509}}}}],["ba1e220b-6b59-4ea6-85e2-9eccb73ab34a",{"pageContent":"进行对话：\n```js\n  const res1 = await chain.call({ input: \"Hello, 我是小明！\" });\n  const res2 = await chain.call({ input: \"Dcat 是叮当猫，会跑会飞。\" });\n```\n\n### 在 LCEL 中集成 memory\n\nBaseMemory 是一个抽象类，不能直接使用，需要使用它的子类。所有 memory 都需要继承该接口。核心就是就是两个方法：\n\n- loadMemoryVariables： 返回当前记忆的内容，如果有些记忆是依赖于输入的，例如 EntityMemory，就需要传入一些输入，让 memory 返回对应输入的记忆。 在 EntityMemory 的场景下，就是 memory 需要根据传入的信息提取输入中的实体，并且返回实体中相关的记忆\n- saveContext： 保存当前上下文，包括输入和输出，以便下次调用。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":511,"to":522}}}}],["53e547ec-d9da-4def-b917-707a496b0093",{"pageContent":"以 BufferMemory 在 LCEL 中使用 memory。\n```js\n  import { BufferMemory } from \"langchain/memory\";\n  import { ChatAlibabaTongyi } from \"@langchain/community/chat_models/alibaba_tongyi\";\n\n  const chatModel = new ChatAlibabaTongyi({\n      model: \"qwen-turbo\", // Available models: qwen-turbo, qwen-plus, qwen-max\n      temperature: 1,\n      verbose:true\n  });\n\n  const memory = new BufferMemory();\n\n  const TEMPLATE = `\n  你是一个乐于助人的 ai 助手，尽你所能回答所有问题。\n\n  这是跟人类沟通的聊天历史:\n  {history}","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":524,"to":541}}}}],["ebfb20c2-4a60-4d69-b99f-cfccec6c17b3",{"pageContent":"const TEMPLATE = `\n  你是一个乐于助人的 ai 助手，尽你所能回答所有问题。\n\n  这是跟人类沟通的聊天历史:\n  {history}\n\n  据此回答人类的问题:\n  {input}\n  `\n  const prompt = ChatPromptTemplate.fromTemplate(TEMPLATE);\n```\n\n构建 chain：\n```js\n  import { RunnableSequence, RunnablePassthrough } from \"@langchain/core/runnables\";\n  import { StringOutputParser } from \"@langchain/core/output_parsers\";\n\n  let tempInput = \"\"","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":537,"to":554}}}}],["73cbae8e-952a-4ddc-b82d-2ca5d41deb5a",{"pageContent":"let tempInput = \"\"\n\n  const chain =  RunnableSequence.from([\n    {\n      input: new RunnablePassthrough(),\n      memoryObject: async (input) => {\n        const history = await memory.loadMemoryVariables({\n          input,\n        });\n        tempInput = input;\n        return history;\n      }\n    },\n\n    RunnablePassthrough.assign({\n      history: (input) => input.memoryObject.history\n    }),\n\n    prompt,\n    chatModel,\n    new StringOutputParser(),","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":554,"to":574}}}}],["ab5edd8d-e3c4-4cc5-be6b-9856761e803f",{"pageContent":"prompt,\n    chatModel,\n    new StringOutputParser(),\n\n    new RunnablePassthrough({\n      func: async (output) => {\n        await memory.saveContext({\n          input: tempInput,\n        }, {\n          output,\n        })\n      }\n    }),\n  ]);\n```\n\ntempInput 用于临时存储用户的 input 输入。\n\n首先使用 new RunnablePassthrough() 对 input 进行透传，然后创建一个函数（Runnable 对象），以用户的 input 作为输入，使用 loadMemoryVariables 去加载 memory 中的数据，并将用户的输入保存到 tempInput。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":572,"to":590}}}}],["2dd11539-2e4d-4182-9cdc-b95421bbb7f3",{"pageContent":"加载出来的 history 对象是一个 object，其是 memory 根据用户这次 input 返回的数据，如果是 BufferMemory，则里面只有一个 history key。其他的 memory 根据不同的类型，返回的数据也是不一样的，例如 EntityMemory 就会有 history 和 entities 两个 key。\n\n在 chain 的第二个节点，使用 RunnablePassthrough.assign() 提取出 memoryObject 中的 history 值。 assign 会在上一个节点输入的基础上，再添加新的数据。 这样后面的 prompt 就接收到了 history 和 input 两个输入值。\n\nprompt、chatModel、new StringOutputParser() 就是基础的使用 prompt 激发 llm 输出内容，然后使用 StringOutputParser 去提取出纯文本的内容。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":592,"to":596}}}}],["25a6b405-0dcf-4f74-bfe0-cc11a6d767f3",{"pageContent":"最后一个节点，使用 RunnablePassthrough 去执行一个函数，将用户的输入和输出使用 saveContext 存储到 memory 中。\n\n使用下面这个技巧去打印 chain 中间传递的内容，了解数据在 chain 中是如何流动的：\n```js\n  [\n    ...\n    prompt,\n    new RunnablePassthrough({\n      func: (input) => console.log(input)\n    }),\n    chatModel,\n    ...\n  ]\n```\n\n### 实现自定义 chat history","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":598,"to":613}}}}],["0834ebb3-f089-443f-b1e0-6fb63372094a",{"pageContent":"### 实现自定义 chat history\n\n通过查看 BaseListChatMessageHistory [源码](https://github.com/langchain-ai/langchainjs/blob/d26233d89148c123540ed93af63ab3fb1f0ac1ac/langchain-core/src/chat_history.ts) 可知真正需要实现的就是addUserMessage、addAIChatMessage、addAIMessage、clear 几个方法：\n\n- getMessages：获取存储在 history 中所有聊天记录\n- addMessage：添加单条 message\n- addMessages：添加 message 数组\n- clear：清空聊天记录","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":613,"to":620}}}}],["a6a768c2-cbf5-430d-be5f-8f987be95520",{"pageContent":"完整代码如下：\n```js \n  import { BaseListChatMessageHistory } from \"@langchain/core/chat_history\";\n  import {\n    BaseMessage,\n    StoredMessage,\n    mapChatMessagesToStoredMessages,\n    mapStoredMessagesToChatMessages,\n  } from \"@langchain/core/messages\";\n  import fs from \"node:fs\";\n  import path from \"node:path\";\n\n  export interface JSONChatHistoryInput {\n    sessionId: string; // sessionId 是区别于不同对话的 id，在工程中一般使用 uuid\n    dir: string; // dir 是存储聊天记录 json 文件的目录\n  }","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":622,"to":637}}}}],["142605dd-8248-4433-889b-45c52408af3a",{"pageContent":"export class JSONChatHistory extends BaseListChatMessageHistory {\n\n    /**\n     * BaseListChatMessageHistory 继承了 Serializable，声明 lc_namespace 是方便 \n     * langchain 在序列化和反序列化时，找到 json 中对象对应的内置类。例如当把 message 序列化，\n     * 再反序列化后，打印出来依旧是对应 langchain 内部的类的实例化对象，依靠的就是这个。\n     */\n    lc_namespace = [\"langchain\", \"stores\", \"message\"];\n\n    sessionId: string;\n    dir: string;","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":639,"to":649}}}}],["db2b5157-3fa6-46cd-82a8-0acd83a21279",{"pageContent":"sessionId: string;\n    dir: string;\n\n    constructor(fields: JSONChatHistoryInput) {\n      super(fields);\n      this.sessionId = fields.sessionId;\n      this.dir = fields.dir;\n    }\n\n    /**\n     * 从对应的文件中读取 json 内容，然后使用 mapStoredMessagesToChatMessages 序列化成对应的 message 对象\n     */\n    async getMessages(): Promise<BaseMessage[]> {\n      const filePath = path.join(this.dir, `${this.sessionId}.json`);","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":648,"to":661}}}}],["2d913edf-2186-4f1a-85a7-71ed6e2b9f1e",{"pageContent":"try {\n        if (!fs.existsSync(filePath)) {\n          this.saveMessagesToFile([]);\n          return [];\n        }\n\n        const data = fs.readFileSync(filePath, { encoding: \"utf-8\" });\n        const storedMessages = JSON.parse(data) as StoredMessage[];\n\n        return mapStoredMessagesToChatMessages(storedMessages);\n      } catch (error) {\n        console.error(`Failed to read chat history from ${filePath}`, error);\n        return [];\n      }\n    }","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":663,"to":677}}}}],["92a2f034-500a-4023-86c3-30b3eb996670",{"pageContent":"async addMessage(message: BaseMessage): Promise<void> {\n      const messages = await this.getMessages();\n      messages.push(message);\n      await this.saveMessagesToFile(messages);\n    }\n\n    async addMessages(messages: BaseMessage[]): Promise<void> {\n      const existingMessages = await this.getMessages();\n      const allMessages = existingMessages.concat(messages);\n      await this.saveMessagesToFile(allMessages);\n    }","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":679,"to":689}}}}],["04e7e51b-0365-421c-ba06-c06c8e558d60",{"pageContent":"async clear(): Promise<void> {\n      const filePath = path.join(this.dir, `${this.sessionId}.json`);\n      try {\n        fs.unlinkSync(filePath);\n      } catch (error) {\n        console.error(`Failed to clear chat history from ${filePath}`, error);\n      }\n    }","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":691,"to":698}}}}],["584a932f-5fd4-4952-a2dd-803e4fca3385",{"pageContent":"/**\n     * 使用 mapChatMessagesToStoredMessages 去对 messages 进行序列化，然后写文件到 json 文件中\n     * @param messages \n     */\n    private async saveMessagesToFile(messages: BaseMessage[]): Promise<void> {\n      const filePath = path.join(this.dir, `${this.sessionId}.json`);\n      const serializedMessages = mapChatMessagesToStoredMessages(messages);","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":700,"to":706}}}}],["1193c52e-d704-451e-92e8-879e63d7316f",{"pageContent":"try {\n        fs.writeFileSync(filePath, JSON.stringify(serializedMessages, null, 2), {\n          encoding: \"utf-8\",\n        });\n      } catch (error) {\n        console.error(`Failed to save chat history to ${filePath}`, error);\n      }\n    }\n  }\n\n```\n\n测试：\n```js\n  import { JSONChatHistory } from \"./JSONChatHistory/index.ts\"\n  import { AIMessage, HumanMessage } from \"@langchain/core/messages\";\n\n  const history = new JSONChatHistory({\n    dir: \"chat_data\",\n    sessionId: \"test\"\n  })","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":708,"to":728}}}}],["639185de-c71b-4d95-81a8-f2e51435f661",{"pageContent":"const history = new JSONChatHistory({\n    dir: \"chat_data\",\n    sessionId: \"test\"\n  })\n\n  await history.addMessages([\n    new HumanMessage(\"你好，我是叮当猫\"),\n    new AIMessage(\"你好\"),\n  ]);\n\n  const messages = await history.getMessages();\n  console.log(messages);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":725,"to":737}}}}],["3f154713-6a71-44aa-a15b-9112a76961eb",{"pageContent":"输出内容如下：\n```js\n  [\n    HumanMessage {\n      lc_serializable: true,\n      lc_kwargs: {\n        content: \"你好，我是叮当猫\",\n        additional_kwargs: {},\n        response_metadata: {}\n      },\n      lc_namespace: [ \"langchain_core\", \"messages\" ],\n      content: \"你好，我是叮当猫\",\n      name: undefined,\n      additional_kwargs: {},\n      response_metadata: {}\n    },\n    AIMessage {\n      lc_serializable: true,\n      lc_kwargs: { content: \"你好\", additional_kwargs: {}, response_metadata: {} },","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":739,"to":757}}}}],["c7433ffa-fff0-4bc8-b001-1ea77338456e",{"pageContent":"lc_kwargs: { content: \"你好\", additional_kwargs: {}, response_metadata: {} },\n      lc_namespace: [ \"langchain_core\", \"messages\" ],\n      content: \"你好\",\n      name: undefined,\n      additional_kwargs: {},\n      response_metadata: {}\n    }\n  ]\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":757,"to":765}}}}],["6a2119db-8236-4808-b0ae-dd54ffca8609",{"pageContent":"应用在 memory 中：\n```js\n  import { ChatAlibabaTongyi } from \"@langchain/community/chat_models/alibaba_tongyi\";\n  import { BufferMemory } from \"langchain/memory\";\n  import { ConversationChain } from \"langchain/chains\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":767,"to":771}}}}],["814080b4-e8fd-478b-8f63-d4c17983f2ec",{"pageContent":"const chatModel = new ChatAlibabaTongyi({\n    model: \"qwen-turbo\", // Available models: qwen-turbo, qwen-plus, qwen-max\n    temperature: 1,\n  });\n  const memory = new BufferMemory({\n    chatHistory: history\n  });\n  const chain = new ConversationChain({ llm: chatModel, memory: memory });\n  const res1 = await chain.call({ input: \"我是谁？\" });\n  console.log(res1);\n```\n\n输出内容如下：\n```json\n  {\n    response: \"你是在说中文的“叮当猫”，这通常是中国动画《哆啦A梦》中的主角，一个来自22世纪的机器猫，以你的名字“Ding Dang”进行交流。\"\n  }\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":774,"to":791}}}}],["2a50b5da-249e-4166-ad5a-9234c398aa8e",{"pageContent":"查看 chat_data 目录下的文件，可以发现，保存了聊天记录。记录如下：\n```json\n  [\n    {\n      \"type\": \"human\",\n      \"data\": {\n        \"content\": \"你好，我是叮当猫\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {}\n      }\n    },\n    {\n      \"type\": \"ai\",\n      \"data\": {\n        \"content\": \"你好\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {}\n      }\n    },\n    {\n      \"type\": \"human\",\n      \"data\": {\n        \"content\": \"我是谁？\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {}\n      }","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":793,"to":818}}}}],["8dd393ca-fe09-4d28-b235-b13b98a9d2df",{"pageContent":"\"content\": \"我是谁？\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {}\n      }\n    },\n    {\n      \"type\": \"ai\",\n      \"data\": {\n        \"content\": \"你是在说中文的“叮当猫”，这通常是中国动画《哆啦A梦》中的主角，一个来自22世纪的机器猫，以你的名字“Ding Dang”进行交流。\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {}\n      }\n    }\n  ]\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":815,"to":829}}}}],["a854f4d1-dcbb-4fe0-992f-54c67502892d",{"pageContent":"至此，通过自定义 chat history 实现把历史记录存储到本地文件和从本地文件中读取到 chat history 中，并且将自定义的 chat history 作为 memory 内置使用的 chatHistory 成功的将 memory 接入了存储中。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api2.mdx","loc":{"lines":{"from":831,"to":831}}}}],["400ffad3-9c65-4674-8716-35d129494dfa",{"pageContent":"---\ntitle: RAG检索增强生成(四)\ndate: '2024-05-28'\ntags: ['AI大模型', 'javaScript', 'Node.js']\ndraft: false\nsummary: 增强 RAG 的能力，构建完整的 chain并部署成 API\n---\n\n## 增强 RAG 能力\n\n### 改写 LLM 提问\n\n为了提高检索的质量，需要对用户的提问进行改写，让其成为一个独立的问题，包含检索的所有关键词。LLM app 遇到问题时，通常会尝试加入更多的 LLM 来解决问题。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api3.mdx","loc":{"lines":{"from":1,"to":13}}}}],["2fe2d8c9-508b-453b-85b6-16ec4c808fd1",{"pageContent":"首先定义 prompt，通过 system prompt 去给 llm 确定任务，根据聊天记录去把对话重新描述成一个独立的问题，并强调重述问题的目标：\n```js\n  import { ChatPromptTemplate, MessagesPlaceholder } from \"@langchain/core/prompts\";\n  \n  const rephraseChainPrompt = ChatPromptTemplate.fromMessages([\n    [\n      \"system\",\n      \"给定以下对话和一个后续问题，请将后续问题重述为一个独立的问题。请注意，重述的问题应该包含足够的信息，使得没有看过对话历史的人也能理解。\",\n    ],\n    new MessagesPlaceholder(\"history\"),\n    [\"human\", \"将以下问题重述为一个独立的问题：\\n{question}\"],\n  ]);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api3.mdx","loc":{"lines":{"from":15,"to":27}}}}],["3ab533e7-a92f-4d4c-8eb4-cc1cdf5af44f",{"pageContent":"据此构成一个 chain：\n```js\n  import { ChatAlibabaTongyi } from \"@langchain/community/chat_models/alibaba_tongyi\";\n  import { RunnableSequence } from \"@langchain/core/runnables\";\n  import { StringOutputParser } from \"@langchain/core/output_parsers\";\n\n  const rephraseChain = RunnableSequence.from([\n    rephraseChainPrompt,\n    new ChatAlibabaTongyi({\n      model: \"qwen-turbo\",\n      temperature: 0.2,\n    }),\n    new StringOutputParser(),\n  ]);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api3.mdx","loc":{"lines":{"from":29,"to":43}}}}],["e709c278-c700-447e-8d55-a4aafd691c2f",{"pageContent":"测试效果：\n```js\n  import { HumanMessage, AIMessage } from \"@langchain/core/messages\";\n\n  const historyMessages = [new HumanMessage(\"你好，我是叮当猫\"), new AIMessage(\"你好，叮当猫\")];\n  \n  const question = \"你觉得我的名字怎么样？\";\n  const standaloneQuestion = await rephraseChain.invoke({ history: historyMessages, question });\n\n  console.log(standaloneQuestion);\n  // 你觉得“叮当猫”这个名字如何？\n```\n可以看到，这里使用了 “我的名字” 这个代词，在 llm 的重述下，将这个替换成了 “叮当猫”。这个处理除了可以解决代词的问题，也能解决一些自然语言灵活性带来的问题，保证进行 retriver 时的问题是高质量的。\n\n### 构建完整的 RAG chain","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api3.mdx","loc":{"lines":{"from":45,"to":59}}}}],["b0b6b2a1-82b3-4089-9681-875224da94d2",{"pageContent":"### 构建完整的 RAG chain\n\n使用了 Faiss 作为本地的数据库，将 RAG 相关知识点串联起来，构建一个完整的 RAG chain，代码需要运行在 node 环境。\n\n切割文本，并保存在本地的数据库：prepare.ts\n```js\nimport { TextLoader } from \"langchain/document_loaders/fs/text\";\nimport { RecursiveCharacterTextSplitter } from \"langchain/text_splitter\";\nimport \"dotenv/config\";\nimport { FaissStore } from \"@langchain/community/vectorstores/faiss\";\nimport { AlibabaTongyiEmbeddings } from \"@langchain/community/embeddings/alibaba_tongyi\";\nimport path from \"path\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api3.mdx","loc":{"lines":{"from":59,"to":70}}}}],["02b745cf-4110-400f-9a73-1c67936dbac2",{"pageContent":"const run = async () => {\n  const baseDir = __dirname;\n\n  const loader = new TextLoader(path.join(baseDir, \"../../data/qiu.txt\"));\n  const docs = await loader.load();\n\n  const splitter = new RecursiveCharacterTextSplitter({\n    chunkSize: 500,\n    chunkOverlap: 100,\n  });\n\n  const splitDocs = await splitter.splitDocuments(docs);\n\n  const embeddings = new AlibabaTongyiEmbeddings();\n  const vectorStore = await FaissStore.fromDocuments(splitDocs, embeddings);","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api3.mdx","loc":{"lines":{"from":72,"to":86}}}}],["5d677a24-c591-4078-bffd-da53ddbdb3f6",{"pageContent":"await vectorStore.save(path.join(baseDir, \"../../db/qiu\"));\n};\n\nrun();\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api3.mdx","loc":{"lines":{"from":88,"to":92}}}}],["908b60de-a23b-400b-98e6-89e32bbfb363",{"pageContent":"核心代码 index.ts:\n```js\nimport { FaissStore } from \"@langchain/community/vectorstores/faiss\";\nimport { AlibabaTongyiEmbeddings } from \"@langchain/community/embeddings/alibaba_tongyi\";\nimport { ChatAlibabaTongyi } from \"@langchain/community/chat_models/alibaba_tongyi\";\nimport \"dotenv/config\";\nimport path from \"path\";\nimport { JSONChatHistory } from \"../../JSONChatHistory/index\";\nimport {\n  ChatPromptTemplate,\n  MessagesPlaceholder,\n} from \"@langchain/core/prompts\";\nimport {\n  RunnableSequence,","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api3.mdx","loc":{"lines":{"from":94,"to":107}}}}],["8632a3a8-b60f-4b2a-8ea0-6abe86131a5e",{"pageContent":"MessagesPlaceholder,\n} from \"@langchain/core/prompts\";\nimport {\n  RunnableSequence,\n  RunnablePassthrough,\n  RunnableWithMessageHistory,\n  Runnable,\n} from \"@langchain/core/runnables\";\nimport { StringOutputParser } from \"@langchain/core/output_parsers\";\nimport { HumanMessage, AIMessage } from \"@langchain/core/messages\";\nimport { Document } from \"@langchain/core/documents\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api3.mdx","loc":{"lines":{"from":104,"to":114}}}}],["5e2fa31c-7107-44d5-997e-7a287ee467aa",{"pageContent":"/**\n * 根据重写后的独立问题去读取数据库的中相关文档\n */\nasync function loadVectorStore() {\n  const directory = path.join(__dirname, \"../../db/qiu\");\n  const embeddings = new AlibabaTongyiEmbeddings();\n  const vectorStore = await FaissStore.load(directory, embeddings);\n\n  return vectorStore;\n}","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api3.mdx","loc":{"lines":{"from":116,"to":125}}}}],["7ebe5ef6-2cc0-4b4f-8b1b-c3a71ff5765c",{"pageContent":"return vectorStore;\n}\n\nasync function getRephraseChain() {\n  const rephraseChainPrompt = ChatPromptTemplate.fromMessages([\n    [\n      \"system\",\n      \"给定以下对话和一个后续问题，请将后续问题重述为一个独立的问题。请注意，重述的问题应该包含足够的信息，使得没有看过对话历史的人也能理解。\",\n    ],\n    new MessagesPlaceholder(\"history\"),\n    [\"human\", \"将以下问题重述为一个独立的问题：\\n{question}\"],\n  ]);","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api3.mdx","loc":{"lines":{"from":124,"to":135}}}}],["89d7137a-95da-40e6-9878-ee4ce4c880e3",{"pageContent":"const rephraseChain = RunnableSequence.from([\n    rephraseChainPrompt,\n    new ChatAlibabaTongyi({\n      model: \"qwen-turbo\",\n      temperature: 0.4,\n    }),\n    new StringOutputParser(),\n  ]);\n\n  return rephraseChain;\n}\n\nasync function testRephraseChain() {\n  const historyMessages = [\n    new HumanMessage(\"你好，我是叮当猫\"),\n    new AIMessage(\"你好叮当猫\"),\n  ];\n  const rephraseChain = await getRephraseChain();","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api3.mdx","loc":{"lines":{"from":137,"to":154}}}}],["8a480eaf-6e4b-4408-96af-e01fb28f43d9",{"pageContent":"const question = \"你觉得我的名字怎么样？\";\n  const standaloneQuestion = await rephraseChain.invoke({\n    history: historyMessages,\n    question,\n  });\n\n  console.log(standaloneQuestion);\n}\n\nexport async function getRagChain(): Promise<Runnable> {\n  const vectorStore = await loadVectorStore();\n  const retriever = vectorStore.asRetriever(2);","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api3.mdx","loc":{"lines":{"from":156,"to":167}}}}],["eb41fbe9-3303-4ab8-bdc9-a6b63b0db080",{"pageContent":"/**\n   * 使用 retriever 获取相关文档，然后转换成纯字符串。\n   * @param documents\n   * @returns\n   */\n  const convertDocsToString = (documents: Document[]): string => {\n    return documents.map((document) => document.pageContent).join(\"\\n\");\n  };\n  const contextRetrieverChain = RunnableSequence.from([\n    (input) => input.standalone_question,\n    retriever,\n    convertDocsToString,\n  ]);","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api3.mdx","loc":{"lines":{"from":169,"to":181}}}}],["118148c5-d610-44e5-a9e7-09cca029b84e",{"pageContent":"const SYSTEM_TEMPLATE = `\n    你是一个熟读刘慈欣的《球状闪电》的终极原着党，精通根据作品原文详细解释和回答问题，你在回答时会引用作品原文。\n    并且回答时仅根据原文，尽可能回答用户问题，如果原文中没有相关内容，你可以回答“原文中没有相关内容”，\n\n    以下是原文中跟用户回答相关的内容：\n    {context}\n  `;\n\n  /**\n   * 包含历史记录信息的 prompt\n   */\n  const prompt = ChatPromptTemplate.fromMessages([\n    [\"system\", SYSTEM_TEMPLATE],\n    new MessagesPlaceholder(\"history\"),\n    [\"human\", \"现在，你需要基于原文，回答以下问题：\\n{standalone_question}`\"],\n  ]);","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api3.mdx","loc":{"lines":{"from":183,"to":198}}}}],["258e87d5-15db-4adf-8772-b6c7b009221c",{"pageContent":"const model = new ChatAlibabaTongyi({\n    model: \"qwen-turbo\",\n  });\n  const rephraseChain = await getRephraseChain();\n\n  /**\n   * 改写提问 => 根据改写后的提问获取文档 => 生成回复 的 rag chain\n   */\n  const ragChain = RunnableSequence.from([\n    RunnablePassthrough.assign({\n      standalone_question: rephraseChain,\n    }),\n    RunnablePassthrough.assign({\n      context: contextRetrieverChain,\n    }),\n    prompt,\n    model,\n    new StringOutputParser(),\n  ]);","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api3.mdx","loc":{"lines":{"from":200,"to":218}}}}],["374788be-d97d-42d7-8d6c-5e6fb78e156d",{"pageContent":"const chatHistoryDir = path.join(__dirname, \"../../chat_data\");\n\n  /**\n   * 使用 RunnableWithMessageHistory 去管理 history，给 chain 增加聊天记录的功能\n   * 传给 getMessageHistory 的函数，需要根据用户传入的 sessionId 去获取初始的 chat history\n   */\n  const ragChainWithHistory = new RunnableWithMessageHistory({\n    runnable: ragChain,\n    getMessageHistory: (sessionId) =>\n      new JSONChatHistory({ sessionId, dir: chatHistoryDir }),\n    historyMessagesKey: \"history\",\n    inputMessagesKey: \"question\",\n  });","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api3.mdx","loc":{"lines":{"from":220,"to":232}}}}],["71271d30-d776-4dba-8d63-f1eb1f550bc7",{"pageContent":"return ragChainWithHistory;\n}\n\nasync function run() {\n  const ragChain = await getRagChain();\n\n  const res = await ragChain.invoke(\n    {\n        question: \"什么是球状闪电？\",\n    },\n    {\n      configurable: { sessionId: \"test-history\" },\n    }\n  );\n\n  console.log(res);\n}\n```\n\n测试代码，首先执行 prepare.ts 文件，切割文本，保存到本地的 docstore.json 中：\n```js\n  ts-node ./node/rag/prepare.ts \n```\n\n执行 index.ts 文件，在 index.ts 文件中，先增加函数执行 run()，在执行文件：\n```js\n  ts-node ./node/rag/index.ts \n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api3.mdx","loc":{"lines":{"from":234,"to":261}}}}],["74ab59cd-bc86-4561-906d-2256c21f33e5",{"pageContent":"执行 index.ts 文件，在 index.ts 文件中，先增加函数执行 run()，在执行文件：\n```js\n  ts-node ./node/rag/index.ts \n```\n\n输出内容如下：\n```json\n  球状闪电是刘慈欣作品《球状闪电》中的关键概念，它是一种自然现象，表现为一种明亮的、球形或椭圆形的发光体，通常出现在雷暴天气中。书中提到球状闪电的行为和特性是基于真实历史记录的描述，它们具有量子性质，在失去观察者后会消失并重新生成，显示出超乎寻常的物理特性。在小说中，球状闪电的研究被用于开发一种高度先进的武器系统，但其基本原理和技术细节并未完全揭示给读者。\n```\n\n至此，就完成了一个非常完整的 rag chain，有自动的提问改写、数据检索、聊天记录等基本的功能。\n\n### 部署成 API\n\n  将开发完成的 chain 部署成 API，方便用户调用。新建 server.ts 文件，代码如下：\n```js\nimport express from \"express\";\nimport { getRagChain } from \".\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api3.mdx","loc":{"lines":{"from":258,"to":275}}}}],["61d20dd1-90e6-4341-96e8-c2f556854dce",{"pageContent":"const app = express();\nconst port = 3001;\n\napp.use(express.json());\n\napp.post(\"/\", async (req, res) => {\n  const ragChain = await getRagChain();\n  const body = req.body;\n  const result = await ragChain.stream(\n    {\n      question: body.question,\n    },\n    { configurable: { sessionId: body.session_id } }\n  );\n\n  res.set(\"Content-Type\", \"text/plain\");\n  for await (const chunk of result) {\n    res.write(chunk);\n  }\n  res.end();\n});","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api3.mdx","loc":{"lines":{"from":277,"to":297}}}}],["d5c20572-cc44-45f6-8442-4e052bcd610d",{"pageContent":"app.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n```\n\n启动服务器：\n```js\n  ts-node ./node/rag/server.ts \n```\n\n新增 client.ts 文件，调用 API：\n```js\nconst port = 3001;\n\nasync function fetchStream() {\n  const response = await fetch(`http://localhost:${port}`, {\n    method: \"POST\",\n    headers: {\n      \"content-type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      question: \"什么是球状闪电\",\n      session_id: \"test-server\",\n    }),\n  });","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api3.mdx","loc":{"lines":{"from":299,"to":323}}}}],["af0072d1-108b-43d2-ad36-9628876996b2",{"pageContent":"const reader = response?.body?.getReader();\n  const decoder = new TextDecoder();\n\n  while (true && reader) {\n    const { done, value } = await reader.read();\n    if (done) break;\n    console.log(decoder.decode(value));\n  }\n\n  console.log(\"Stream has ended\");\n}\n\nfetchStream();\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api3.mdx","loc":{"lines":{"from":325,"to":338}}}}],["90fc7ffe-961c-445d-95db-2f3ebe22823e",{"pageContent":"console.log(\"Stream has ended\");\n}\n\nfetchStream();\n```\n\n执行 client.ts，输出内容如下：\n```json\n球\n状\n闪电\n是刘慈欣作品\n《球状闪电》中的关键概念\n，它是一种自然现象，表现为一种\n明亮的、球形或椭圆形\n的发光体，通常出现在雷暴\n天气中。书中提到球状闪电\n的行为和特性是基于真实历史记录\n的描述，它们具有量子性质，在\n失去观察者后会消失并重新\n生成，显示出超乎寻常的物理\n特性。在小说中，球状\n闪电的研究被用于揭示微观世界的秘密\n，尽管其军事应用相对较小。\nStream has ended\n```\n\n到此就完成了一个简单的 rag chain，通过调用 API，实现了问答系统的功能。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/Rag Api3.mdx","loc":{"lines":{"from":334,"to":361}}}}],["51ebe065-0989-4de9-a423-35a64ddc7a65",{"pageContent":"---\ntitle: RAG检索增强生成（一）\ndate: '2024-05-20'\ntags: ['AI大模型', 'javaScript', 'Deno']\ndraft: false\nsummary: Rag 的原理、流程及常用 API\n---\n\n## RAG 原理及流程\n\n### RAG 原理\n  RAG 通过尽可能提供与答案相关的上下文，来提升搜索结果的准确性，用于解决 LLM 基于概率性的底层逻辑。\n### RAG 流程","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":1,"to":13}}}}],["721cd027-2573-4246-985b-dec7c60b55f0",{"pageContent":"## RAG 原理及流程\n\n### RAG 原理\n  RAG 通过尽可能提供与答案相关的上下文，来提升搜索结果的准确性，用于解决 LLM 基于概率性的底层逻辑。\n### RAG 流程\n\n  - 加载数据： 加载不同数据源的数据，例如 pdf、code、现存数据库、云数据库等。\n  - 切分数据： 对数据集进行语意化的切分，根据内容的特点和目标大模型的特点、上下文窗口等，对数据源进行合适的切分。\n  - 嵌入（embedding）： 将切分后的每一个文档块使用 embedding 算法转换成一个向量，存储到向量数据库中，这样每一个原始数据都有一个对应的向量用来检索。\n  - 检索数据： 当所有需要的数据都存储到向量数据库中后，就把用户的提问也 embedding 成向量，用这个向量去向量数据库中进行检索，找到相似性最高的几个文档块。\n  - 增强 prompt： 根据文档块去构建 prompt\n  - 生成结果\n\n## 相关概念及API\n\n### prompt","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":9,"to":24}}}}],["1f39ad7f-0f7d-4372-a558-a1e742418232",{"pageContent":"## 相关概念及API\n\n### prompt\n\n  PromptTemplate 可以帮助我们定义一个包含变量的字符串模版，可以通过向该类的对象输入不同的变量值来生成模版渲染的结果。\n\n#### 基础 prompt\n  **无变量**\n```js\n  import { PromptTemplate } from \"@langchain/core/prompts\";\n\n  const prompt1 = new PromptTemplate({\n    inputVariables: [],\n    template: \"你是谁\",\n  });\n  const msg = await prompt1.format();\n\n  console.log(msg);\n  // 你是谁\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":22,"to":41}}}}],["73f87dea-0c47-4320-97d9-65b0602f1a61",{"pageContent":"console.log(msg);\n  // 你是谁\n```\n\n **带变量**\n```js\n  const paramPrompt = new PromptTemplate({\n    inputVariables: [\"name\"],\n    template: \"我是：{name}\",\n  });\n  const model = await paramPrompt.format({\n    name: \"小明\",\n  });\n\n  console.log(model);\n  // 我是：小明\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":39,"to":55}}}}],["ccea75ee-04cb-4f69-9e2d-53b4f42f61ac",{"pageContent":"console.log(model);\n  // 我是：小明\n```\n\n**多个变量**\n```js\n  const paramPrompt = new PromptTemplate({\n    inputVariables: [\"name\", \"age\", \"sex\"],\n    template: \"我是：{name}，今年{age}岁，{{{sex}}}\",\n  });\n  const model = await paramPrompt.format({\n      name: \"小明\",\n      age: 18,\n      sex: \"男\",\n  });\n\n  console.log(model);\n  // 我是：小明，今年18岁，{男}\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":53,"to":71}}}}],["28873592-7225-43bf-a3af-32843b3e7330",{"pageContent":"console.log(model);\n  // 我是：小明，今年18岁，{男}\n```\n\n**简写**\n```js\n  const simpleTemp = PromptTemplate.fromTemplate(\"我是 {name}，今年{age}岁，{{{sex}}}\");\n  console.log(simpleTemp.inputVariables);\n  // [ \"name\", \"age\", \"sex\" ]\n\n  const modal = await simpleTemp.format({\n    name: \"小明\",\n    age: 18,\n    sex: \"男\",\n  });\n  console.log(modal);\n  // 我是 小明，今年18岁，{男}\n```\n\n**分步传参**\n```js\n  const initialPrompt = new PromptTemplate({\n    inputVariables: [\"name\", \"age\"],\n    template: \"我是：{name}，今年{age}岁\",\n  });","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":69,"to":93}}}}],["054d7e6c-7c66-4f87-bc79-fe69a9522bf0",{"pageContent":"const partialedPrompt = await initialPrompt.partial({\n    name: \"小明\",\n  });\n\n  const format1 = await partialedPrompt.format({\n    age: 23,\n  });\n  console.log(format1);\n  // 我是：小明，今年23岁\n\n  const format2 = await partialedPrompt.format({\n    age: 16,\n  });\n  console.log(format2);\n  // 我是：小明，今年16岁\n```\n\n**动态参数**\n```js\n  const getCurrentTime = () => {\n    return new Date().toLocaleDateString();\n  };","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":95,"to":116}}}}],["81bf940b-a04a-4c34-9b77-7a46fae64113",{"pageContent":"**动态参数**\n```js\n  const getCurrentTime = () => {\n    return new Date().toLocaleDateString();\n  };\n\n  const prompt1 = new PromptTemplate({\n    template: \"现在是{date}，{activity}。\",\n    inputVariables: [\"date\", \"activity\"],\n  });\n\n  const partialedPt = await prompt1.partial({\n    date: getCurrentTime,\n  });\n\n  const formatVal = await partialedPt.format({\n    activity: \"该吃饭了\",\n  });","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":112,"to":129}}}}],["8694b39f-9270-42c8-a1d6-e9681c10b95d",{"pageContent":"const formatVal = await partialedPt.format({\n    activity: \"该吃饭了\",\n  });\n\n  console.log(formatVal);\n  // 现在是2024/5/23，该吃饭了。\n```\n函数 getCurrentTime 在 format 被调用的时候实时执行，也就是可以在被渲染成字符串时获取到最新的外部信息。 目前不支持传入参数，如果需要参数，可以用 js 的闭包进行参数的传递。\n\n#### chat prompt\n\nchatPrompt 主要包括以下几种，分别对应一段 ChatMessage 不同的角色：","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":127,"to":138}}}}],["2591ae96-a167-4d51-b8f4-765ab23bfb28",{"pageContent":"#### chat prompt\n\nchatPrompt 主要包括以下几种，分别对应一段 ChatMessage 不同的角色：\n\n- ChatPromptTemplate ： 描述了用户和 LLM 的对话，包括系统消息、用户消息和 LLM 消息\n- SystemMessagePromptTemplate： 系统消息，通常用于设置对话的上下文或指定模型采取特定的行为模式\n- AIMessagePromptTemplate： 用户消息，代表真实用户在对话中的发言\n- HumanMessagePromptTemplate： AI模型的回复，这些消息是模型根据 system 的指示和 user 的输入生成的\n\n具体使用：\n\n1、构建系统 message\n```js\n  import { SystemMessagePromptTemplate } from \"@langchain/core/prompts\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":136,"to":149}}}}],["0d116321-915b-4326-acd5-5ff9a71733c9",{"pageContent":"1、构建系统 message\n```js\n  import { SystemMessagePromptTemplate } from \"@langchain/core/prompts\";\n\n  const sysTemplate = SystemMessagePromptTemplate.fromTemplate(`你是一个专\n  业的翻译员，你的任务是将文本从{source_lang}翻译成{target_lang}。`);\n```\n\n2、构建用户输入 message\n```js\n  import { HumanMessagePromptTemplate } from \"@langchain/core/prompts\";\n\n  const userTemplate = HumanMessagePromptTemplate.fromTemplate(\"请翻译这句话：{text}\");\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":147,"to":160}}}}],["d8936497-8aa7-4eee-b31d-1101803e4de2",{"pageContent":"const userTemplate = HumanMessagePromptTemplate.fromTemplate(\"请翻译这句话：{text}\");\n```\n\n3、将sysTemplate 和 userTemplate 组合起来，构建一个 PromptTemplate 对象\n```js\n  import { ChatPromptTemplate } from \"@langchain/core/prompts\";\n\n  const chatPrompt = ChatPromptTemplate.fromMessages([\n    sysTemplate,\n    userTemplate,\n  ]);\n```\n\n4、使用 formatMessages 格式化对话信息\n```js\n  const formatPt = await chatPrompt.formatMessages({\n    source_lang: \"中文\",\n    target_lang: \" 日语\",\n    text: \"你好，小明同学\",\n  });","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":159,"to":178}}}}],["54136e8f-281b-4d64-853a-cbca73256362",{"pageContent":"console.log(formatPt);\n```\n\n5、简写写法如下\n```js\n  import { ChatPromptTemplate } from \"@langchain/core/prompts\";\n  \n  const systemTemplate = \"你是一个专业的翻译员，你的任务是将文本从{source_lang}翻译成{target_lang}。\";\n  const humanTemplate = \"请翻译这句话：{text}\";\n\n  const chatPrompt = ChatPromptTemplate.fromMessages([\n    [\"system\", systemTemplate],\n    [\"human\", humanTemplate],\n  ]);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":180,"to":194}}}}],["ce122086-fe1c-4bfc-94e8-2ab62449f16c",{"pageContent":"6、测试\n```js\n  import { ChatAlibabaTongyi } from \"@langchain/community/chat_models/alibaba_tongyi\";\n  import { HumanMessage } from \"@langchain/core/messages\";\n  import { StringOutputParser } from \"@langchain/core/output_parsers\";\n\n  const model = new ChatAlibabaTongyi({\n    model: \"qwen-turbo\", // Available models: qwen-turbo, qwen-plus, qwen-max\n    temperature: 1,\n  });\n\n  const outputPrase = new StringOutputParser();\n  const simpleChain = chatPrompt.pipe(model).pipe(outputPrase);","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":196,"to":208}}}}],["bd468eb2-e5bf-4ad0-81fc-56f065f0f95a",{"pageContent":"const stream = await simpleChain.invoke({\n      source_lang: \"中文\",\n      target_lang: \"日语\",\n      text: \"你好，小明同学\",\n  });\n\n  console.log(stream);\n  // こんにちは、小明さん。\n```\n\n#### 组合多个 prompt\n\nPipelinePromptTemplate 可以将多个独立的 template 构建成一个完整且复杂的 prompt，以此提高独立 prompt 的复用性，进一步增强模块化带来的优势。\n\nPipelinePromptTemplate 两个核心概念：\n- pipelinePrompts  一组 object，每个 object 表示 prompt 运行后赋值给 name 变量\n- finalPrompt  表示最终输出的 prompt","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":210,"to":226}}}}],["79cd79cf-a422-482d-9c3c-00dec2179c70",{"pageContent":"示例如下：\n```js\n  import {\n    PromptTemplate,\n    PipelinePromptTemplate,\n  } from \"@langchain/core/prompts\";\n\n  const getCurrentTime = () => {\n    return new Date().toLocaleDateString();\n  };\n\n  const fullPt = PromptTemplate.fromTemplate(`\n  你是一个智能管家，今天是 {date}，你的主人的信息是{info}, \n  根据上下文，完成主人的需求\n  {task}`);\n\n  const datePt = PromptTemplate.fromTemplate(\"{date}，现在是 {period}\");\n  const periodPt = await datePt.partial({\n    date: getCurrentTime,\n  });","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":228,"to":247}}}}],["c1e6c5f7-39f7-4936-b302-05a6a4cf82b3",{"pageContent":"const infoPt =  PromptTemplate.fromTemplate(\"姓名是 {name}, 性别是 {sex}\");\n\n  const taskPt = PromptTemplate.fromTemplate(`\n  我想吃 {period} 的 {food}。 \n  再重复一遍我的信息 {info}`);\n\n  const composedPrompt = new PipelinePromptTemplate({\n    pipelinePrompts: [\n      {\n        name: \"date\",\n        prompt: periodPt,\n      },\n      {\n        name: \"info\",\n        prompt: infoPt,\n      },\n      {\n        name: \"task\",\n        prompt: taskPt,\n      },\n    ],\n    finalPrompt: fullPt,\n  });","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":249,"to":271}}}}],["cc78a879-a2e7-413f-9e54-c401e5856565",{"pageContent":"const formatPt = await composedPrompt.format({\n      period: \"早上\",\n      name: \"小明\",\n      sex: \"男\",\n      food: \"煎饼\",\n  });\n\n  console.log(formatPt);\n  // 你是一个智能管家，今天是 2024/5/23，现在是 早上，你的主人的信息是姓名是 小明, 性别是 男, \n  // 根据上下文，完成主人的需求\n\n  // 我想吃 早上 的 煎饼。 \n  // 再重复一遍我的信息 姓名是 小明, 性别是 男\n```\n\n**注意**\n\n- 一个变量可以多次复用，例如外界输入的 period 在 periodPt 和 taskPt 都被使用了\n- pipelinePrompts 中的变量可以被引用，比如在 taskPt 使用了 infoPt 的运行结果\n- 支持动态自定义和 partial，示例中也涉及到了这两种特殊的 template\n- langchain 会自动分析 pipeline 之间的依赖关系，尽可能的进行并行化来提高运行速度","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":273,"to":293}}}}],["6402a0cc-32b4-4874-b2f0-495caccddd5d",{"pageContent":"### OutputParser\n\n  OutputParser 用于解析模型输出，将模型输出转换为我们需要的格式。\n\n#### StringOutputParser\n  最简单的 Parser，返回 API 中的文本数据，即 content 部分。langchain 内部有错误处理和 stream 等的支持。\n\n```js\n  import { ChatBaiduWenxin } from \"@langchain/community/chat_models/baiduwenxin\";\n  import { HumanMessage } from \"@langchain/core/messages\";\n  import { StringOutputParser } from \"@langchain/core/output_parsers\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":295,"to":305}}}}],["e0668549-6664-4ede-8906-30f82c79092a",{"pageContent":"const model = new ChatBaiduWenxin({\n    model: \"ERNIE-Speed-8K\", // ERNIE-Lite-8K、ERNIE-Lite-8K-0922、ERNIE-Tiny-8K、ERNIE-Speed-128K、ERNIE-Speed-8K、ERNIE Speed-AppBuilder\n    temperature: 1,\n  });\n\n  const outputPrase = new StringOutputParser();\n  const simpleChain = model.pipe(outputPrase);\n\n  const stream = await simpleChain.invoke([\n      new HumanMessage(\"你是谁\"),\n  ]);\n\n  console.log(stream);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":307,"to":320}}}}],["30ba0951-4494-4aa8-aca7-1e7f16a50104",{"pageContent":"console.log(stream);\n```\n\n#### StructuredOutputParser\n  引导模型引以需要的格式进行输出。\n```js\n  import { StructuredOutputParser } from \"langchain/output_parsers\";\n  import { PromptTemplate } from \"@langchain/core/prompts\";\n\n  const parser = StructuredOutputParser.fromNamesAndDescriptions({\n    answer: \"用户问题的答案\",\n    evidence: \"你回答用户问题所依据的答案\",\n    confidence: \"问题答案的可信度评分，格式是百分数\",\n  });","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":319,"to":332}}}}],["b7e10d77-4a0e-4fc3-bcaa-fd7fbae3f3c6",{"pageContent":"const prompt = PromptTemplate.fromTemplate(\"尽可能的回答用的问题 {instructions} {question}\")\n  const model = new ChatBaiduWenxin({\n    model: \"ERNIE-Speed-8K\",\n    temperature: 1,\n  });\n\n  const chain = prompt.pipe(model).pipe(parser);\n\n  const res = await chain.invoke({\n      question: \"蒙娜丽莎的作者是谁？是什么时候绘制的\",\n      instructions: parser.getFormatInstructions(),\n  });","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":334,"to":345}}}}],["be935688-755e-491e-925f-9d9391860092",{"pageContent":"console.log(res);\n```\n输出格式为：\n```json\n  {\n    answer: \"蒙娜丽莎的作者是列奥纳多·达·芬奇，大约是在15世纪末期绘制的。\",\n    evidence: \"这一信息来源于艺术史和相关的文化资料，蒙娜丽莎是一幅世界著名的画作，其作者和创作时间都是公众熟知的事实。\",\n    confidence: \"95%\"\n  }\n```\n\n#### CommaSeparatedListOutputParser\nCommaSeparatedListOutputParser 是一个输出解析器，用于解析成逗号分隔的列表。\n\n```js\n  import { CommaSeparatedListOutputParser } from \"@langchain/core/output_parsers\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":347,"to":362}}}}],["4266c444-293f-48cc-878a-d7115978962e",{"pageContent":"```js\n  import { CommaSeparatedListOutputParser } from \"@langchain/core/output_parsers\";\n\n  const parser = new CommaSeparatedListOutputParser();\n  const model = new ChatBaiduWenxin({\n    model: \"ERNIE-Speed-8K\",\n    temperature: 1,\n  });\n\n  const prompt = PromptTemplate.fromTemplate(\"列出3个 {country} 的著名的互联网公司. {instructions}\")\n    \n  const chain = prompt.pipe(model).pipe(parser)","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":361,"to":372}}}}],["7f747625-d3c3-4735-8186-d7bd6d3942e8",{"pageContent":"const res = await chain.invoke({\n    country: \"中国\",\n    instructions: parser.getFormatInstructions(),\n  });\n  console.log(res);\n```\n输出内容如下：\n```json\n  [ \"百度，阿里巴巴，腾讯。\" ]\n```\n#### Auto Fix Parser\n\n首先使用 zod 定义一个需要的类型：\n```js\n  import { z } from \"zod\";\n\n  const schema = z.object({\n    answer:  z.string().describe(\"用户问题的答案\"),\n    confidence: z.number().min(0).max(100).describe(\"问题答案的可信度评分，满分 100\")\n  });\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":374,"to":394}}}}],["d3fea976-b5e1-4ed0-a27b-244042e45708",{"pageContent":"使用正常的方式，使用 zod 来创建一个 StructuredOutputParser\n```js\n  import { PromptTemplate } from \"@langchain/core/prompts\";\n  import { StructuredOutputParser } from \"langchain/output_parsers\";\n  import { ChatBaiduWenxin } from \"@langchain/community/chat_models/baiduwenxin\";\n\n  const parser = StructuredOutputParser.fromZodSchema(schema);\n  const prompt = PromptTemplate.fromTemplate(\"尽可能的回答用的问题 \\n{instructions} \\n{question}\")","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":396,"to":403}}}}],["237338c6-7c0d-4852-8ec2-6be10cfe0a1a",{"pageContent":"const model = new ChatBaiduWenxin({\n    model: \"ERNIE-Speed-8K\",\n    temperature: 1,\n  });\n\n  const chain = prompt.pipe(model).pipe(parser);\n  const res = await chain.invoke({\n      question: \"蒙娜丽莎的作者是谁？是什么时候绘制的\",\n      instructions: parser.getFormatInstructions(),\n  });\n                                \n  console.log(res);\n```\n\n输出内容如下：\n```json\n  { answer: \"蒙娜丽莎的作者是列奥纳多·达·芬奇，大约是在15世纪末期绘制的。\", confidence: 100 }\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":405,"to":422}}}}],["a2a365ae-7769-4161-b85d-eadb262cbc14",{"pageContent":"输出内容如下：\n```json\n  { answer: \"蒙娜丽莎的作者是列奥纳多·达·芬奇，大约是在15世纪末期绘制的。\", confidence: 100 }\n```\n\n构造一个可以根据 zod 定义以及错误的输出，来自动修复的 parser:\n```js\n  import { OutputFixingParser } from \"langchain/output_parsers\";\n\n  const fixParser = OutputFixingParser.fromLLM(model, parser);\n```\n\n修复一个错误类型的输出：\n```js\n  const wrongOutput = {\n    \"answer\": \"蒙娜丽莎的作者是达芬奇，大约在16世纪初期（1503年至1506年之间）开始绘制。\",\n    \"sources\": \"90%\",\n  };","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":419,"to":436}}}}],["74e7b2df-0d01-4b43-86e1-4fe7b8bea201",{"pageContent":"const fixParser = OutputFixingParser.fromLLM(model, parser);\n  const output = await fixParser.parse(JSON.stringify(wrongOutput));\n  console.log(output);\n```\n\n输出内容如下：\n```json\n  { answer: \"蒙娜丽莎的作者是达芬奇，大约在15世纪末期至16世纪初期开始绘制。\", confidence: 90 }\n```\n\n定义一个，数值超出限制的错误:\n```js\n  const wrongOutput = {\n    \"answer\": \"蒙娜丽莎的作者是达芬奇，大约在16世纪初期（1503年至1506年之间）开始绘制。\",\n    \"sources\": \"-1\" \n  };","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":438,"to":453}}}}],["56367a5a-f5c1-4ba2-a778-3214358568fb",{"pageContent":"const fixParser = OutputFixingParser.fromLLM(model, parser);\n  const output = await fixParser.parse(JSON.stringify(wrongOutput));\n\n  console.log(output);\n```\n\n输出内容如下：\n```json\n  { answer: \"蒙娜丽莎的作者是达芬奇，大约在15世纪末期至16世纪初期开始绘制。\", confidence: 95 }\n```\n\n### Embedding 多数据源加载\n  RAG 的本质是给 chat bot 外挂数据源，数据源的形式多种多样，可以是文件/数据库/网络数据/代码 等等。\n\n#### TextLoader\n\n  用于对文件所在的路径进行加载。\n```js\n  import { TextLoader } from \"langchain/document_loaders/fs/text\";\n  const loader = new TextLoader(\"data/2.txt\");","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":455,"to":474}}}}],["0a610e01-dbc0-4275-9fb2-08b7b0fab86e",{"pageContent":"const docs = await loader.load();\n  console.log(docs);\n```\n\n输出内容如下：\n```json\n  [\n    Document {\n      pageContent: \"鲁镇的酒店的格局，是和别处不同的：都是当街一个曲尺形的大柜台，柜里面预备着热水，可以随时温酒。做工的人，傍午傍晚散了工，每每花四文铜钱，买一碗酒，——这是二十多年前的事，现在每碗要涨到十文，——靠柜外\"... 2150 more characters,\n      metadata: { source: \"data/2.txt\" }\n    }\n  ]\n```\n返回对象就是一个 Document 对象的实例，其中 pageContent 是文本的原始内容，而在 metadata 中是跟这个对象相关的一些元数据，\n这里就是加载原始文件的文件名。\n\n#### PDFLoader\n\n  加载 PDF 文件作为外挂数据库。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":476,"to":494}}}}],["389df41a-c40d-4d1f-a4cc-b147e56b601a",{"pageContent":"#### PDFLoader\n\n  加载 PDF 文件作为外挂数据库。\n\n  在 Deno 环境下使用 PDFLoader 会有 bug，报错找不到 pdf 文件。\n  解决方法有两个，第一个是把这个文件放在项目根目录里。第二个是修改 deno.json 中 pdf-parser 的别名。\n```json\n  \"pdf-parse\": \"npm:/pdf-parse/lib/pdf-parse.js\"\n```\n\n  加载 pdf 文件：\n```js\n  import * as pdfParse from \"pdf-parse\";\n  import { PDFLoader } from \"langchain/document_loaders/fs/pdf\";\n\n  const loader = new PDFLoader(\"./data/webpack.pdf\");\n  const pdfs = await loader.load()\n  console.log(pdfs);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":492,"to":510}}}}],["ce0b484e-c807-4d6d-ac63-4546c97f91fa",{"pageContent":"输出内容如下：\n```json\n  [\n    Document {\n      pageContent: \"什么是前端工程化\\n\" +\n        \"前端工程化: 在企业级的前端项目开发中，把前端开发所需要的工具，技术，流程，经验等进行规范化，标准化。\\n\" +\n        \"前端工程化的解决方案\\n\" +\n        \"早期的前端工程化解决方案：grunt ,gulp\\n\" +\n        \"目前主\"... 8041 more characters,\n      metadata: {\n        source: \"./data/webpack.pdf\",\n        pdf: {\n          version: \"1.10.100\",\n          info: {\n            PDFFormatVersion: \"1.3\",\n            IsAcroFormPresent: false,\n            IsXFAPresent: false,","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":512,"to":528}}}}],["c2f12bbc-3937-4796-becc-b1a5cb8c7ce8",{"pageContent":"IsAcroFormPresent: false,\n            IsXFAPresent: false,\n            Producer: \"macOS 版本12.3.1（版号21E258） Quartz PDFContext\",\n            CreationDate: \"D:20220430083114Z00'00'\",\n            ModDate: \"D:20220430083114Z00'00'\"\n          },\n          metadata: null,\n          totalPages: 1\n        },\n        loc: { pageNumber: 1 }\n      }\n    }\n  ]\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":527,"to":540}}}}],["56b2129e-82dd-4469-95a9-14695159bf2d",{"pageContent":"打印出来 pdfs是一个 Document 数组，每一个 Document 对象即 pdf 中的一页，这是 PDFLoader 的默认行为。\n关闭这个特性：\n```js\n  const loader = new PDFLoader(\"./data/webpack.pdf\");\n  const pdf = await loader.load();\n```\n\n#### DirectoryLoader\n  用于加载一个文件夹下多种格式的文件。\n```js\n  import { DirectoryLoader } from \"langchain/document_loaders/fs/directory\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":542,"to":552}}}}],["4c0fa3c8-4400-4054-97bd-6ad30b529711",{"pageContent":"const loader = new DirectoryLoader(\n    \"./data\",\n    {\n      \".pdf\": (path) => new PDFLoader(path, { splitPages: false }),\n      \".txt\": (path) => new TextLoader(path),\n    }\n  );\n  const docs = await loader.load();\n  console.log(docs);\n```\n\n返回内容的每个 Document 都对应一篇文档。\n\n#### Github loader\n  获取 Github 上某个仓库的代码，并构建数据库，然后根据用户提问寻找与此相关的代码片段回答用户问题\n```js\n  import { GithubRepoLoader } from \"langchain/document_loaders/web/github\";\n  import ignore from \"ignore\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":554,"to":571}}}}],["5ab1b194-8287-4ef8-82f6-d7fc5d5f0559",{"pageContent":"const loader = new GithubRepoLoader(\n    \"https://github.com/qingxiang1/qingxiang1.github.io\",\n    { \n        branch: \"master\",\n        recursive: false, \n        unknown: \"warn\", \n        ignorePaths: [\"*.md\", \"yarn.lock\", \"*.json\"],\n        accessToken: env[\"GITHUB_TOKEN\"]\n    }\n  );\n```\n相关属性如下：\n- branch        分支\n- recursive     是否递归访问文件夹内部的内容，请求量比较大，等待比较久\n- ignorePaths   使用的 git ignore 的语法，忽略掉一些特定格式的文件\n- accessToken   github API 的 accessToken，在没有设置的情况也可以访问，但有频率限制","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":573,"to":588}}}}],["43249faf-42ad-405d-821f-fea3b5986d32",{"pageContent":"设置 [Github Token](https://github.com/settings/tokens)\n\n#### WebLoader\n  一般使用 Cheerio 来提取网页中的静态内容，类似于 python 中的 BeautifulSoup。\n```js\n  import \"cheerio\";\n  import { CheerioWebBaseLoader } from \"langchain/document_loaders/web/cheerio\";\n\n  const loader = new CheerioWebBaseLoader(\n    \"https://blog.qxmall.store/blog/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80\"\n  );\n\n  const docs = await loader.load();\n  console.log(docs);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":590,"to":604}}}}],["4f0a2bef-b9e8-4b98-91d3-798d9d906509",{"pageContent":"const docs = await loader.load();\n  console.log(docs);\n```\n\n输出内容为：\n```json\n  [\n    Document {\n      pageContent: \"!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localSto\"... 105007 more characters,\n      metadata: {\n        source: \"https://blog.qxmall.store/blog/ai-model/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80\"\n      }\n    }\n  ]\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":602,"to":616}}}}],["df9ee43d-0db3-42ea-a9a7-3b6b574ac47d",{"pageContent":"可以用类似 jQuery 的语法对 html 中的元素进行选择和过滤:\n```js\n  const loader = new CheerioWebBaseLoader(\n    \"https://blog.qxmall.store/blog/ai-model/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80\",\n    {\n      selector: \"h2\",\n    }\n  );\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":618,"to":626}}}}],["eec802c3-ad95-4bc7-bf58-50770198da9a",{"pageContent":"#### Search API\n  给 chatbot 接入网络支持最重要的 API，在 langchain.js 中，常用的是 SearchApiLoader 和 SerpAPILoader，这两个提供的都是接入搜索的能力，免费计划都是每个月 100 次 search 能力，除了 google 外，也支持 baidu/bing 等常用的搜索引擎。\n  \n```js\n  import { SerpAPILoader } from \"langchain/document_loaders/web/serpapi\";\n  // import { SerpAPILoader } from \"@langchain/community/document_loaders/web/serpapi\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":628,"to":633}}}}],["4592d18a-3796-4689-940d-bc65492dffd9",{"pageContent":"const apiKey = env[\"SERP_KEY\"]\n  const question = \"什么是 github\"\n  const loader = new SerpAPILoader({ q: question, apiKey });\n  const docs = await loader.load();\n  console.log(docs);\n```\n申请 [Search Key](https://serpapi.com/searches)","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":635,"to":641}}}}],["33c35e92-0a8c-447e-83e0-15ecdb8e35a8",{"pageContent":"输出内容如下：\n```json\n  [\n    Document {\n      pageContent: '{\"title\":\"GitHub\",\"type\":\"Software company\",\"entity_type\":\"companies, company\",\"kgmid\":\"/m/0ryppmg\",'... 11896 more characters,\n      metadata: { source: \"SerpAPI\", responseType: \"knowledge_graph\" }\n    },\n    Document {\n      pageContent: '{\"position\":1,\"title\":\"GitHub - 维基百科，自由的百科全书\",\"link\":\"https://zh.wikipedia.org/zh-hans/GitHub\",\"redi'... 767 more characters,\n      metadata: { source: \"SerpAPI\", responseType: \"organic_results\" }","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":643,"to":652}}}}],["f067a9ca-1a95-49ab-af91-0a7d9fe97760",{"pageContent":"metadata: { source: \"SerpAPI\", responseType: \"organic_results\" }\n    },\n    Document {\n      pageContent: '{\"position\":2,\"title\":\"Github_百度百科\",\"link\":\"https://baike.baidu.com/item/Github/10145341\",\"redirect_'... 548 more characters,\n      metadata: { source: \"SerpAPI\", responseType: \"organic_results\" }\n    },\n    Document {\n      pageContent: '{\"position\":3,\"title\":\"Github是什么？看完你就了解一些了\",\"link\":\"https://www.cnblogs.com/jiqing9006/p/5584848.htm'... 564 more characters,","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":652,"to":659}}}}],["03ffea9c-30a6-41c6-8125-b41b0ffc084a",{"pageContent":"metadata: { source: \"SerpAPI\", responseType: \"organic_results\" }\n    },\n    ...\n  ]\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型Rag.mdx","loc":{"lines":{"from":660,"to":664}}}}],["7a36de54-5aed-4445-b401-91de46541e3d",{"pageContent":"---\ntitle: Jupyter Notebook 基础\ndate: '2024-05-19'\ntags: ['AI大模型', 'javaScript', 'Deno']\ndraft: false\nsummary: 基于 Deno 与 Jupyter Notebook 链接开源模型\n---\n\n{/* ![名称](图片路径) */}\n\n## 环境安装及配置\n\n### 安装 python\n\n```bash\n  brew install python3\n```\n\n### 安装 pip\n\n```bash\n  sudo easy_install pip\n```\n\n### 安装 Jupyter Notebook\n\n```bash\n  pip install notebook\n```\n\n### 安装 Deno\n\n```bash\n  curl -fsSL https://deno.land/install.sh | sh\n```\n\n#### 配置环境变量（MacOS）","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型基础.mdx","loc":{"lines":{"from":1,"to":37}}}}],["d2883bd2-8ea3-4831-9fcf-e9f23032b148",{"pageContent":"### 安装 Deno\n\n```bash\n  curl -fsSL https://deno.land/install.sh | sh\n```\n\n#### 配置环境变量（MacOS）\n\n  Deno 安装完成后，在 ~/.bash_profile 中添加以下内容：xxxxxx 为当前用户的目录\n```javaScript\n  export DENO_INSTALL=\"/Users/xxxxxx/.deno\"\n  export PATH=\"$DENO_INSTALL/bin:$PATH\"\n```\n\n  如果终端使用 zsh，则修改 ~/.zshrc 文件，加入如下内容：\n```js\n  source ~/.bash_profile\n```\n\n  配置完成后，重启终端，执行 deno --version 命令，如果出现版本信息，则表示安装成功。\n  \n### 配置 Jupyter Notebook\n\n  使用 Deno 为 Jupyter Notebook 配置 kernel：\n```bash\n  deno jupyter --unstable --install\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型基础.mdx","loc":{"lines":{"from":31,"to":57}}}}],["598e9cc8-0bc5-47e3-9185-071c03235b10",{"pageContent":"使用 Deno 为 Jupyter Notebook 配置 kernel：\n```bash\n  deno jupyter --unstable --install\n```\n\n  验证是否配置成功：\n```bash\n  deno jupyter --unstable\n```\n  出现 _Deno kernel already installed_ 即表示配置成功。\n\n  安装完成后，启动 notebook：\n```bash\n  jupyter notebook\n```\n\n  启动成功后，在浏览器中访问 http://localhost:8888/tree 就可以看到 Jupyter Notebook 的界面。\n\n\n## 获取模型\n\n### 获取线上模型\n  以阿里云灵积大模型为例，[线上申请](https://help.aliyun.com/zh/dashscope/developer-reference/activate-dashscope-and-create-an-api-key?spm=a2c4g.11186623.0.0.4e202a9dn7fwHa) 模型。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型基础.mdx","loc":{"lines":{"from":54,"to":76}}}}],["33ca053c-820a-4ede-bb5a-3e683693f6bb",{"pageContent":"模型申请成功后，即可本地访问线上模型，做测试。\n\n### 获取本地模型\n  因为线上模型一般都需要收费，为节约成本，也可以使用本地模型进行测试，但是本地模型对设备资源要求较高，可视情况安装对应的模型。\n\n  本地模型平台 mac 系统推荐 [Ollama](https://ollama.com/)，win 系统推荐 [LM Studio](https://lmstudio.ai/)，进入对应的官网下载即可，\n  安装成功后启动 app，即可在 http://localhost:11434 启动一个 llm 的服务。\n\n  以 Ollama 为例，在 [gitHub](https://github.com/ollama/ollama) 中可以查找其支持的模型。\n  Ollama 服务启动后，在控制台中执行如下命令下载对应的模型到本地：\n```bash\n  ollama run modelName\n```\n\n## 链接模型\n\n在 notebook 界面中，创建项目文件夹，用于存放测试代码，测试代码是基于 Deno 和 js 实现。\n\n### 配置 deno 依赖","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型基础.mdx","loc":{"lines":{"from":78,"to":96}}}}],["bb3b610e-137a-4a62-b433-73423a574fd9",{"pageContent":"## 链接模型\n\n在 notebook 界面中，创建项目文件夹，用于存放测试代码，测试代码是基于 Deno 和 js 实现。\n\n### 配置 deno 依赖\n\nDeno 是直接远程拉取依赖，且自带缓存机制，不需要本地安装，只需要配置依赖项即可。\n模型的链接依赖于 langchain.js。在 Deno 使用 dotenv 来加载环境变量。\n\n在项目根目录下，新建 deno.json，加入以下内容：","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型基础.mdx","loc":{"lines":{"from":92,"to":101}}}}],["a733da7c-062d-418c-8d99-615687eebbd1",{"pageContent":"```json\n  {\n    \"imports\": {\n      \"lodash\": \"npm:/lodash@4.17.21\",\n      \"dotenv\": \"https://deno.land/std@0.220.0/dotenv/mod.ts\",\n      \"langchain\": \"npm:/langchain@0.2.3\",\n      \"langchain/\": \"npm:/langchain@0.2.3/\",\n      \"@langchain/openai\": \"npm:/@langchain/openai@0.0.22\",\n      \"@langchain/openai/\": \"npm:/@langchain/openai@0.0.22/\",\n      \"@langchain/core\": \"npm:/@langchain/core@0.1.48\",\n      \"@langchain/core/\": \"npm:/@langchain/core@0.1.48/\",\n      \"zod\": \"npm:/zod\",","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型基础.mdx","loc":{"lines":{"from":103,"to":114}}}}],["00b7e58c-1742-4455-b033-3e82d44550ad",{"pageContent":"\"@langchain/core/\": \"npm:/@langchain/core@0.1.48/\",\n      \"zod\": \"npm:/zod\",\n      \"pdf-parse\": \"npm:/pdf-parse/lib/pdf-parse.js\",\n      \"ignore\": \"npm:/ignore\",\n      \"cheerio\": \"npm:/cheerio\",\n      \"vectordb\": \"npm:/vectordb\",\n      \"@lancedb/lancedb\": \"npm:/@lancedb/lancedb\",\n      \"faiss-node\": \"npm:/faiss-node\",\n      \"openai\": \"npm:/openai\",\n      \"@langchain/community\": \"npm:/@langchain/community@0.2.2\",\n      \"@langchain/community/\": \"npm:/@langchain/community@0.2.2/\",","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型基础.mdx","loc":{"lines":{"from":113,"to":123}}}}],["401acf23-111a-41f9-a359-f5ca0476c9e8",{"pageContent":"\"@langchain/community/\": \"npm:/@langchain/community@0.2.2/\",\n      \"zod-to-json-schema\": \"npm:/zod-to-json-schema\"\n    },\n    \"deno.enable\": true\n  }\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型基础.mdx","loc":{"lines":{"from":123,"to":128}}}}],["79de7ac1-377c-427a-be18-e181bc9b3814",{"pageContent":"### 链接线上模型\n在项目目录下新建 demo.ipynb 文件，在 notebook 中打开此文件，右侧内核选择 Deno。\n\n目录下新建 .env 文件，加入模型的 API（在对应的控制台获取）：\n```js\n  ALIBABA_API_KEY=xxx\n```\n\n在 ipynb 文件中，首先加载环境变量，由于 langchain.js 是为 node 设计，因此会默认从 process.env 中进行读取。执行以下命令，\n将环境变量加载到 process.env 中：\n```js\n  import { load } from \"dotenv\";\n  const env = await load();\n\n  const process = {\n    env,\n  };\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型基础.mdx","loc":{"lines":{"from":130,"to":147}}}}],["fc65d1d5-0592-453a-adc8-06c52ba844d7",{"pageContent":"const process = {\n    env,\n  };\n```\n\n链接模型，并进行问询，参考自[langchain.js](https://js.langchain.com/v0.1/docs/integrations/chat/alibaba_tongyi/)：\n```js\n  import { ChatAlibabaTongyi } from \"@langchain/community/chat_models/alibaba_tongyi\";\n  // import { ChatBaiduWenxin } from \"@langchain/community/chat_models/baiduwenxin\"; // 百度千帆模型\n  import { HumanMessage } from \"@langchain/core/messages\";","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型基础.mdx","loc":{"lines":{"from":144,"to":153}}}}],["f7822a36-fc80-40e8-94a5-7ed744f5d769",{"pageContent":"const model = new ChatAlibabaTongyi({\n    model: \"qwen-turbo\", // Available models: qwen-turbo, qwen-plus, qwen-max\n    temperature: 1,\n  });","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型基础.mdx","loc":{"lines":{"from":155,"to":158}}}}],["823c3f14-be26-419e-aa9b-a1ab9e2d18cb",{"pageContent":"// 百度千帆模型 ERNIE-Lite-8K、ERNIE-Lite-8K-0922、ERNIE-Tiny-8K、ERNIE-Speed-128K、ERNIE-Speed-8K、ERNIE Speed-AppBuilder 已免费\n  // const model = new ChatBaiduWenxin({\n  //   model: \"ERNIE-Speed-8K\", // ERNIE-Bot,ERNIE-Bot-turbo,ERNIE-Bot-4,ERNIE-Speed-8K,ERNIE-Speed-128K,ERNIE-4.0-8K, ERNIE-4.0-8K-Preview,ERNIE-3.5-8K,ERNIE-3.5-8K-Preview,ERNIE-Lite-8K,ERNIE-Tiny-8K,ERNIE-Character-8K, ERNIE Speed-AppBuilder\n  //   temperature: 1,\n  // });","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型基础.mdx","loc":{"lines":{"from":160,"to":164}}}}],["2955fb15-b9c3-42b7-9e95-f1cacecc9da9",{"pageContent":"const stream = await model.invoke([\n    new HumanMessage(\"讲个笑话\"),\n  ]);\n\n  console.log(stream);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型基础.mdx","loc":{"lines":{"from":166,"to":171}}}}],["20e69900-7743-4f4f-94bc-aaca65d9c429",{"pageContent":"返回内容格式如下：\n```js\n  AIMessage {\n    lc_serializable: true,\n    lc_kwargs: {\n      content: \"为什么袜子总是只丢一只？因为丢两只根本就不会发现。\",\n      tool_calls: [],\n      invalid_tool_calls: [],\n      additional_kwargs: {},\n      response_metadata: {}\n    },\n    lc_namespace: [ \"langchain_core\", \"messages\" ],\n    content: \"为什么袜子总是只丢一只？因为丢两只根本就不会发现。\",\n    name: undefined,\n    additional_kwargs: {},\n    response_metadata: {\n      tokenUsage: { promptTokens: 11, completionTokens: 15, totalTokens: 26 }\n    },","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型基础.mdx","loc":{"lines":{"from":173,"to":190}}}}],["eeb9878c-dddb-4e60-9535-e6a1cd9c70e8",{"pageContent":"tokenUsage: { promptTokens: 11, completionTokens: 15, totalTokens: 26 }\n    },\n    tool_calls: [],\n    invalid_tool_calls: []\n  }\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型基础.mdx","loc":{"lines":{"from":189,"to":194}}}}],["3b0e87dc-52ee-42b7-a51c-2db145bd91a8",{"pageContent":"使用 StringOutputParser 对输出的内容进行处理，处理后只输出普通文本：\n```js\n  import { ChatAlibabaTongyi } from \"@langchain/community/chat_models/alibaba_tongyi\";\n  import { HumanMessage } from \"@langchain/core/messages\";\n  import { StringOutputParser } from \"@langchain/core/output_parsers\";\n\n  const model = new ChatAlibabaTongyi({\n    model: \"qwen-turbo\", // Available models: qwen-turbo, qwen-plus, qwen-max\n    temperature: 1,\n    maxRetries: 0, // 出错重试次数\n  });","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型基础.mdx","loc":{"lines":{"from":196,"to":206}}}}],["5fbffcce-731e-4a49-b6e0-523e5b30298f",{"pageContent":"const outputPrase = new StringOutputParser();\n  const simpleChain = model.pipe(outputPrase);\n\n  const stream = await simpleChain.invoke([\n    new HumanMessage(\"你是谁\"),\n    new HumanMessage(\"讲个笑话\"),\n  ]);\n\n  console.log(stream);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型基础.mdx","loc":{"lines":{"from":208,"to":217}}}}],["b09f1007-e18f-4bdf-9295-511b61af6dbd",{"pageContent":"console.log(stream);\n```\n\n使用 withFallbacks 增加 fallBack 保证在环境差的情况下也有输出：\n```js\n  import { ChatAlibabaTongyi } from \"@langchain/community/chat_models/alibaba_tongyi\";\n  import { HumanMessage } from \"@langchain/core/messages\";\n  import { StringOutputParser } from \"@langchain/core/output_parsers\";\n\n  const model = new ChatAlibabaTongyi({\n    model: \"qwen-turbo\", // Available models: qwen-turbo, qwen-plus, qwen-max\n    temperature: 1,\n    maxRetries: 0, // 出错重试次数\n  });","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型基础.mdx","loc":{"lines":{"from":216,"to":229}}}}],["009881c5-0f28-43b8-89b4-69a6dd2c2a62",{"pageContent":"const model2 = new ChatAlibabaTongyi({\n    model: \"qwen-plus\", // Available models: qwen-turbo, qwen-plus, qwen-max\n    temperature: 1,\n    maxRetries: 0, // 出错重试次数\n  });\n\n  const fallbackModl = model.withFallbacks({\n    fallbacks: [model2]\n  })\n\n  const outputPrase = new StringOutputParser();\n  const simpleChain = fallbackModl.pipe(outputPrase);\n\n\n  const stream = await simpleChain.invoke([\n    new HumanMessage(\"你是谁\"),\n    new HumanMessage(\"讲个笑话\"),\n  ]);\n\n  console.log(stream);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型基础.mdx","loc":{"lines":{"from":231,"to":251}}}}],["5c8e9abd-fcfc-41a0-8a9e-fcb725514be4",{"pageContent":"console.log(stream);\n```\n\n### 链接本地模型\n\n链接本地模型需要使用 ollama，本地启动 Ollama 服务，baseUrl 指向 http://localhost:11434:\n\n参考自[langchain.js](https://js.langchain.com/v0.2/docs/integrations/llms/ollama/#usage)\n```js\n  import { Ollama } from \"@langchain/community/llms/ollama\";\n  import { HumanMessage } from \"@langchain/core/messages\";\n  import { StringOutputParser } from \"@langchain/core/output_parsers\";\n\n  const ollama = new Ollama({\n    baseUrl: \"http://localhost:11434\", \n    model: \"qwen:7b\", \n  });","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型基础.mdx","loc":{"lines":{"from":250,"to":266}}}}],["9bcb3f81-8302-4a68-ae99-1b61f3123490",{"pageContent":"const ollama = new Ollama({\n    baseUrl: \"http://localhost:11434\", \n    model: \"qwen:7b\", \n  });\n\n  const outputPrase = new StringOutputParser();\n\n  const simpleChain = ollama.pipe(outputPrase);\n  const stream = await simpleChain.invoke([\n      new HumanMessage(\"讲个笑话\"),\n  ]);\n\n  console.log(stream);\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/ai-model/大模型基础.mdx","loc":{"lines":{"from":263,"to":276}}}}],["d9a2601c-0948-4208-8274-b9b5dd99d624",{"pageContent":"---\ntitle: linux 安装 git\ndate: '2024-05-04'\ntags: ['linux', '服务部署', 'git']\ndraft: false\nsummary: linux 系统中安装 git\n\n---\n\n1、获取 github 最新的Git安装包下载链接，进入Linux服务器，在指定目录下，执行下载：\n\n```js\n  wget https://github.com/git/git/archive/v2.17.0.tar.gz \n```\n\n2、压缩包解压:\n\n```js\n  tar -zxvf v2.17.0.tar.gz\n```\n\n3、安装编译源码所需依赖\n\n```js\n  yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker\n```\n耐心等待安装，出现提示输入y即可\n\n4、安装依赖时，yum自动安装了Git，需要卸载旧版本Git\n\n```js\n  yum remove git\n```\n\n现提示输入y即可","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/linux/Linux 安装 git.mdx","loc":{"lines":{"from":1,"to":35}}}}],["79471f2e-6023-4f05-aed6-f8a19b6cf289",{"pageContent":"4、安装依赖时，yum自动安装了Git，需要卸载旧版本Git\n\n```js\n  yum remove git\n```\n\n现提示输入y即可\n\n5、进入解压后的文件夹，然后执行编译\n\n```js\n  make prefix=/usr/local/git all\n```\n\n6、安装Git至/usr/local/git路径\n\n```js\n  make prefix=/usr/local/git install\n```\n\n7、打开环境变量配置文件, 在底部加上Git相关配置信息\n```js\n  vim /etc/profile\n\n  PATH=$PATH:/usr/local/git/bin;\n  export PATH;\n```\n\n保存退出，执行命令：\n\n```js\n  source /etc/profile\n```\n使配置生效\n\n8、输入命令 git --version 查看安装的git版本，校验通过，安装成功","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/linux/Linux 安装 git.mdx","loc":{"lines":{"from":29,"to":64}}}}],["b05006c2-c58d-4a5f-bfdd-e1c465b48798",{"pageContent":"---\ntitle: linux 安装 nginx\ndate: '2024-05-03'\ntags: ['linux', '服务部署', 'nginx']\ndraft: false\nsummary: linux 系统中安装 nginx\n\n---\n\n## 安装并启动 nginx\n\n1、首先安装 gcc-c++ 编译器\n\n```js\n  yum install gcc-c++\n  yum install -y openssl openssl-devel\n```\n\n2、安装 pcre 包\n\n```js\n  yum install -y pcre pcre-devel\n```\n\n3、安装zlib包\n```js\n  yum install -y zlib zlib-devel\n```\n\n4、在指定目录下下载nginx源码包\n\n```js\n  wget https://nginx.org/download/nginx-1.19.9.tar.gz\n```\n\n5、解压nginx源码包\n\n```js\n  tar -zxvf nginx-1.19.9.tar.gz\n```\n\n6、使用nginx默认配置","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/linux/Linux 安装 nginx.mdx","loc":{"lines":{"from":1,"to":42}}}}],["fa452bef-b92b-489c-8ed8-2b4bd4138ffb",{"pageContent":"5、解压nginx源码包\n\n```js\n  tar -zxvf nginx-1.19.9.tar.gz\n```\n\n6、使用nginx默认配置\n\n```js\n  cd nginx-1.19.9\n  ./configure\n```\n\n7、编译安装\n\n```js\n  make && make install\n```\n\n8、启动nginx\n\n进入安装路径下的 sbin 目录内，启动 nginx\n```js\n  ./nginx\n```\n\n9、查看nginx运行状态\n\n```js\n  ps -ef | grep nginx\n```\n\n10、常用命令\n\n```js\n  ./nginx           // 开启\n  ./nginx -s stop   // 停止\n  ./nginx -s quit\n  ./nginx -s reload\n\n  // quit 方式停止步骤是待 nginx 进程处理任务完毕进行停止。\n  // stop 方式相当于先查出 nginx 进程id再使用kill命令强制杀掉进程。\n```\n\n## nginx 启动配置\n\n1、修改端口号","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/linux/Linux 安装 nginx.mdx","loc":{"lines":{"from":36,"to":82}}}}],["2794a2bd-8a8a-4b31-af10-62cdaf687b84",{"pageContent":"## nginx 启动配置\n\n1、修改端口号\n\n  进入 usr 下的 nginx 配置文件目录 /nginx/conf，修改之前先备份配置文件\n\n```js\n  cp nginx.conf nginx.conf.bak\n```\n\n  编辑nginx.conf配置文件\n```js\n  vim nginx.conf\n```\n\n  修改nginx.conf配置文件中的listen 80; 为listen 8001;\n\n  重新加载配置文件\n```js\n  ./nginx -s reload\n```\n\n  查询nginx进程\n```js\n  ps aux | grep nginx\n```\n\n2、重启 nginx\n  - 先停止再启动（推荐）\n\n    对 nginx 进行重启相当于先停止再启动，即先执行停止命令再执行启动命令。如下：\n```js\n  ./nginx -s quit\n  ./nginx\n```\n\n  - 重新加载配置文件","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/linux/Linux 安装 nginx.mdx","loc":{"lines":{"from":80,"to":116}}}}],["6bf49613-3cf9-4b28-a96c-e1e7416ac545",{"pageContent":"对 nginx 进行重启相当于先停止再启动，即先执行停止命令再执行启动命令。如下：\n```js\n  ./nginx -s quit\n  ./nginx\n```\n\n  - 重新加载配置文件\n\n    当修改 nginx.conf 配置文件后，要想让配置生效需要重启 nginx，使用如下命令即可生效\n```js\n  ./nginx -s reload\n```\n\n3、设置开机自启动\n\n在etc的rc.local增加启动代码\n```js\n  vim /etc/rc.local\n```\n- 添加语句\n\n```js\n  /usr/local/nginx/sbin/nginx\n```\n\n- 设置权限\n```js\n  chmod 755 /etc/rc.local\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/linux/Linux 安装 nginx.mdx","loc":{"lines":{"from":110,"to":138}}}}],["6982d878-4d72-4db4-bf30-3a88ee57c191",{"pageContent":"---\ntitle: LINUX 安装 nodejs\ndate: '2024-05-02'\ntags: ['linux', '服务部署', nodejs]\ndraft: false\nsummary: linux 系统中安装 nodejs 环境","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/linux/Linux 安装 nodejs.mdx","loc":{"lines":{"from":1,"to":6}}}}],["c3899b7f-42f8-4607-8d6e-e30077f169c8",{"pageContent":"# lastmod: '2021-02-01'\n# summary: 'Looking for a performant, out of the box template, with all the best in web technology to support your blogging needs? Checkout the Tailwind Nextjs Starter Blog template.'\n# images: ['/static/images/canada/mountains.jpg', '/static/images/canada/toronto.jpg']\n# authors: ['default', 'sparrowhawk']\n# layout: PostSimple\n# bibliography: references-data.bib\n---\n\n## 直接安装\n\n1、下载对应版本的 Nodejs","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/linux/Linux 安装 nodejs.mdx","loc":{"lines":{"from":8,"to":18}}}}],["7a3f06a3-e3bd-48d8-b303-db8c78ad6fe7",{"pageContent":"## 直接安装\n\n1、下载对应版本的 Nodejs\n\n在指定目录下下载对应版本的 Nodejs 二进制文件\n```js\n  wget https://nodejs.org/dist/v20.11.0/node-v20.11.0-linux-x64.tar.xz\n```\n\n2、解压\n\n```js\n  tar -xvf node-v20.11.0-linux-x64.tar.xz\n```\n\n更改解压后的目录名\n```js\n  mv node-v20.11.0-linux-x64 nodejs\n```\n\n进入解压目录的 bin 中，检查是否安装成功\n```js\n  ./node -v\n```\n\n3、配置软连接\n\n配置软连接，使全局都可以使用 node 命令。\n\n```js\n  // 将 node 源文件映射到 usr/bin 下的 node 文件\n  ln -s /path/nodejs/bin/node /usr/bin/node  \n  ln -s /path/nodejs/bin/npm  /usr/bin/npm\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/linux/Linux 安装 nodejs.mdx","loc":{"lines":{"from":16,"to":49}}}}],["1086a8ca-8ca0-4f0e-b9e4-a7c9242ba498",{"pageContent":"`/path/nodejs` 为 nodejs 解压后的目录\n\n查看是否配置成功\n```js\n  node -v\n```\n\n4、配置 node 文件安装路径\n\n进入 /path/nodejs 路径下，创建 node_global 和 node_cache 目录\n```js\n  mkdir node_global\n  mkdir node_cache\n```\n\n设置 prefix 与 cache\n```js\n  npm config set prefix 'node_global'\n  npm config set cache 'node_cache'\n```\n\n5、配置阿里源\n\n查看当前源\n```js\n  npm config get registry\n```\n\n配置阿里源\n```js\n  npm config set registry https://registry.npmmirror.com\n```\n\n## 使用 node 管理工具 nvm\n\nnvm 是 node 管理工具，可以方便的管理多个 node 版本，并且可以切换版本。\n\n1、安装 nvm","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/linux/Linux 安装 nodejs.mdx","loc":{"lines":{"from":51,"to":88}}}}],["f376e07a-d4d9-4ac2-bca3-fda7a5fc9ddc",{"pageContent":"## 使用 node 管理工具 nvm\n\nnvm 是 node 管理工具，可以方便的管理多个 node 版本，并且可以切换版本。\n\n1、安装 nvm\n\n```js\n  curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash\n```\n\n2、安装指定版本的 node\n\n```js\n  nvm install v20.11.0\n```\n安装完成后，会默认使用当前安装的版本\n\n3、查看已安装版本\n\n```js\n  nvm ls\n```\n\n4、切换版本\n\n```js\n  nvm use v20.11.0\n```\n\n5、nvm 常用命令","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/linux/Linux 安装 nodejs.mdx","loc":{"lines":{"from":84,"to":113}}}}],["82a21250-ec59-44fa-aa1f-78a619361880",{"pageContent":"3、查看已安装版本\n\n```js\n  nvm ls\n```\n\n4、切换版本\n\n```js\n  nvm use v20.11.0\n```\n\n5、nvm 常用命令\n\n```js\n  nvm ls                               // 查看已安装版本及当前使用的版本\n  nvm ls-remote                        // 查看目前线上所能安装的所有 node 版本\n  nvm install v20.11.0                 // 安装指定版本\n  nvm use v20.11.0                     // 切换版本\n  nvm uninstall v20.11.0               // 卸载指定版本\n  nvm alias default v20.11.0           // 设置默认版本\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/linux/Linux 安装 nodejs.mdx","loc":{"lines":{"from":101,"to":122}}}}],["4fb8a952-8126-48a2-a799-86838b615fe3",{"pageContent":"---\ntitle: linux 安装 redis\ndate: '2024-05-04'\ntags: ['linux', '服务部署', 'redis']\ndraft: false\nsummary: linux 系统中安装 redis\n\n---\n\n1、在指定目录，下载 redis\n\n```js\n  wget https://download.redis.io/releases/redis-6.2.6.tar.gz\n```\n\n2、解压并安装\n\n```js\n  tar -zxvf redis-6.2.6.tar.gz\n```\n\n  更改文件夹名称\n```js\n  mv redis-6.2.6 redis\n```\n\n3、编译安装\n\n进入 /usr/local/redis 目录， 执行 make 命令，进行编译。\n```js\n  make\n```\n\n编译完成后进行安装：\n```js\n  make PREFIX=/usr/local/redis install\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/linux/Linux 安装 redis.mdx","loc":{"lines":{"from":1,"to":37}}}}],["70bcdd7a-a953-4c2e-ba0e-7ccde8a368e3",{"pageContent":"编译完成后进行安装：\n```js\n  make PREFIX=/usr/local/redis install\n```\n\n这里多了一个关键字 PREFIX=，这个关键字的作用是编译的时候用于指定程序存放的路径。比如我们现在就是指定了redis必须存放在/usr/local/redis目录。\n\n假设不添加该关键字Linux会将可执行文件存放在/usr/local/bin目录，库文件会存放在/usr/local/lib目录。配置文件会存放在/usr/local/etc目录。其他的资源文件会存放在usr/local/share目录。\n\n这里指定号目录也方便后续的卸载，后续直接rm -rf /usr/local/redis 即可删除redis。\n\n4、启动redis\n\n在目录/usr/local/redis 输入下面命令启动 redis\n```js\n  ./bin/redis-server & ./redis.conf\n```\n\n上面的启动方式是采取后台进程方式,下面是采取显示启动方式(如在配置文件设置了daemonize属性为yes则跟后台进程方式启动其实一样)。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/linux/Linux 安装 redis.mdx","loc":{"lines":{"from":34,"to":52}}}}],["68857d96-02bf-473a-845a-5725a7c64a9d",{"pageContent":"上面的启动方式是采取后台进程方式,下面是采取显示启动方式(如在配置文件设置了daemonize属性为yes则跟后台进程方式启动其实一样)。\n\n```js\n  ./bin/redis-server ./redis.conf\n```\n\n两种方式区别无非是有无带符号 & 的区别。 redis-server 后面是配置文件，目的是根据该配置文件的配置启动redis服务。redis.conf配置文件允许自定义多个配置文件，通过启动时指定读取哪个即可。\n\n5、redis.conf配置文件\n\n在目录/usr/local/redis下有一个redis.conf的配置文件。上面启动方式就是执行了该配置文件的配置运行的。可以通过cat、vim、less等Linux内置的读取命令读取该文件。\n\n也可以通过redis-cli命令进入redis控制台后通过 CONFIG GET * 的方式读取所有配置项。 如下：\n\n```js\n  redis-cli\n  CONFIG GET *\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/linux/Linux 安装 redis.mdx","loc":{"lines":{"from":52,"to":69}}}}],["39c65d52-0dcb-4eb6-8bba-47210228c8a6",{"pageContent":"也可以通过redis-cli命令进入redis控制台后通过 CONFIG GET * 的方式读取所有配置项。 如下：\n\n```js\n  redis-cli\n  CONFIG GET *\n```\n\n这里要将daemonize改为yes，不然每次启动都需要在 redis-server 命令后面加符号&，不这样操作则只要回到 Linux 控制台则 redis 服务会自动关闭，同时也将 bind 注释，将 protected-mode 设置为no。\n\n这样启动后就可以在外网访问了。\n\n6、查看 Redis 状态\n\n- 查看进程方式\n```js\n  ps -aux | grep redis\n```\n\n- 端口监听查看方式\n```js\n  netstat -anp | grep 6379\n```\n\n7、redis-cli\n\nredis-cli 是连接本地 redis 服务的一个命令，通过该命令后可以进入redis的脚本控制台\n\n输入exit可以退出redis脚本控制台\n\n8、关闭运行中的Redis服务","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/linux/Linux 安装 redis.mdx","loc":{"lines":{"from":64,"to":93}}}}],["48e6bbb6-e4f7-4d88-856e-cdf95a397590",{"pageContent":"redis-cli 是连接本地 redis 服务的一个命令，通过该命令后可以进入redis的脚本控制台\n\n输入exit可以退出redis脚本控制台\n\n8、关闭运行中的Redis服务\n\n输入 redis-cli 进入控制台后输入命令 shutdown 即可关闭运行中的 Redis 服务\n```js\n  redis-cli\n  shutdown\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/linux/Linux 安装 redis.mdx","loc":{"lines":{"from":89,"to":99}}}}],["1ebb4a96-fb0d-401c-a6cf-011f7c2e3100",{"pageContent":"---\ntitle: 前端学习路线\ndate: '2024-03-08'\ntags: ['前端学习路线']\ndraft: false\nsummary: 前端学习路线及需要掌握的基础知识\n---\n\n## 前端学习路线\n\n### HTML \n\n- html语义化标签（对语义化的理解）\n- 文档声明的作用？\n- meta标签\n- html5新特性\n- src和href的区别？\n- 行内元素，块级元素的区别？\n- link和@import导入样式的区别？\n- 常用的图片格式和应用场景\n- 常见的浏览器内核\n- srcipt中defer和async的区别？\n- 需要注意哪些SEO\n\n\n### CSS","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/前端学习路线.mdx","loc":{"lines":{"from":1,"to":26}}}}],["4ceb5576-0a54-49f8-9e02-b9fc84d8bfb0",{"pageContent":"- css选择器 \n- css选择器权重 \n- 盒子模型（标准盒子模型和怪异盒子模型）\n- margin塌陷和margin重叠现象\n- 如何清除浮动 \n- css定位属性position（文档流）\n- flex布局（grid布局） （必问，可以看阮一峰老师的那篇文档）\n- css单位的区别？(px, em, rem, vw, vh)\n- display相关属性\n- BFC(高频) \n- 常见布局方式 【 重点 】\n   - 居中的实现方式（必问）\n   - 三栏布局：圣杯布局和双飞翼布局\n   - css画三角形\n- 媒体查询\n- 移动端响应式布局方式 \n- less和scss/sass的基本使用\n- 回流和重绘 \n- z-index压盖顺序\n- 过渡与动画\n- 伪类和伪元素的区别\n- before和after双冒号和单冒号有什么区别？\n- css3新增了哪些特性？ \n- css雪碧图的作用？\n- display:none和visibility:hidden、opacity: 0的区别\n- opacity和rgba区别\n- line-height如何继承？\n- 如何脱离文档流","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/前端学习路线.mdx","loc":{"lines":{"from":28,"to":55}}}}],["7cee21f2-9156-43fa-b688-aa88200a1546",{"pageContent":"- display:none和visibility:hidden、opacity: 0的区别\n- opacity和rgba区别\n- line-height如何继承？\n- 如何脱离文档流\n- 怎么让chrome支持12px以下的文字\n- 怎么画宽度为0.5px的线","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/前端学习路线.mdx","loc":{"lines":{"from":52,"to":57}}}}],["1bf66a1d-12b8-491d-a95d-5be0b43b3d0b",{"pageContent":"### Javascript(全都是重点） \n\n1. 数据类型（原始数据类型和引用数据类型，堆栈内存），数据类型检测和数据类型转换\n2. 数组常用方法、对象常用方法\n3. 类数组和数组的区别和转换，数组的检测方式，数组去重和排序\n4. 函数执行机制和执行上下文，执行上下文栈（普通函数，立即执行函数，箭头函数、构造函数）\n5. 闭包作用域（变量提升，arguments, 作用域与作用域链，闭包的应用场景，闭包优缺点）\n6. 内存泄漏和垃圾回收机制\n7. this指向的规则（call/bind/apply的使用)\n8. new和构造函数\n9. 原型与原型链的理解\n10. 继承实现的方式和区别？\n11. 深拷贝与浅拷贝\n12. 事件循环机制（任务队列，微任务，宏任务，同步，异步，进程和线程，浏览器线程）\n13. JS异步解决方案（回调函数、Promise、Generator、async、定时器）\n14. DOM选择器\n15. 常见DOM操作（增，删，改）\n16. 事件流的过程（事件冒泡和事件捕获）、事件处理程序（DOM0级事件处理程序和DOM2级事件处理程序）、事件对象、事件委托","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/前端学习路线.mdx","loc":{"lines":{"from":59,"to":76}}}}],["3a5f38cb-8d8c-48c4-9964-953b3c08f1cf",{"pageContent":"### ES6 \n\n1. let、const、var的区别\n2. 块级作用域\n3. 暂时性死区\n4. 解构赋值\n5. 箭头函数和普通函数的区别（this的指向）\n6. Symbol概念和作用\n\n--------------------\n\n下面几个可以适当掌握\n\n7. Set和Map数据结构\n8. WeaSet和WeakMap\n8. Proxy\n9. Reflect对象\n--------------------\n10. Promise（Promise的链式调用，Promise的状态、Promise的方法）【必考】\n11. Generator及其异步方面的应用\n12. async函数和await\n13. class基本语法及继承\n14. 模块加载方案比较（CommonJS和ES6的Module）\n15. Iterator和for...of（Iterator遍历器的实现）\n\n**js面试题补充**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/前端学习路线.mdx","loc":{"lines":{"from":80,"to":105}}}}],["0c822be4-e8b1-4051-94dd-8e2d7ef97c0d",{"pageContent":"**js面试题补充**\n\n1. addEventListener和onClick()的区别\n2. new和Object.create()的区别\n3. DOM的location对象\n4. Object.defineProperty()的使用\n5. Array.sort()方法与实现机制\n6. 函数柯里化、组合函数\n7. BOM属性对象方法（scroll/client/offset）\n8. null和undefined的区别 \n9. ==数据类型转换的规则\n10. 数组高阶函数、some、every、filter、map、reduce\n11. mouseenter和mouseover的区别？\n12. 伪数组转为数组的方式 \n13. 遍历对象属性的方法\n\n   - 判断是否是对象的私有属性：obj.hasOwnProperty()\n   - 获取对象的所有实例属性和函数，不包含原型链继承的属性和函数 Object.getOwnPropertyNames()\n   - 获取对象可枚举的属性，不包含继承属性 Object.keys()","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/前端学习路线.mdx","loc":{"lines":{"from":105,"to":123}}}}],["104aacbe-5a4b-4d4e-9593-e775a3a1509b",{"pageContent":"14. 合并数组的方法\n15. document和window的区别\n16. Object.is和===的区别\n17. isNaN和Number.isNaN()的区别？\n18. 0.1 + 0.2 !== 0.3\n19. 判断一个变量是数组还是对象\n20. 属性访问时点操作符和[]中括号操作符的区别\n21. 严格模式\n22. 扩展运算符与rest运算符的区别\n23. Object.assign()\n24. Map和普通对象、WeakMap的区别？\n25. 循环语法比较及使用场景（for、forEach、map的区别/ for...in、for...of的区别）\n26. forEach可以中断吗\n27. forEach和map方法的区别?\n28. e.target和e.currentTarget的区别？\n29. 阻止事件冒泡event.stopPropagation()\n30. event.stopPropagation()和stopImmediatePropagation()\n31. HTMLCollection和NodeList的区别？\n\n### Ajax","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/前端学习路线.mdx","loc":{"lines":{"from":125,"to":144}}}}],["5fb6a5c9-c6d5-40d7-854f-5455db81c68c",{"pageContent":"### Ajax\n\n1. Ajax的请求过程(手写ajax)\n2. POST请求格式\n3. 跨域、同源策略及跨域实现方式和原理\n4. JSONP, CORS\n5. JSON序列化和反序列化\n6. Axios的使用\n7. Ajax和Fetch,Axios有什么区别\n\n### 手写题\n\n1. new 【高频】\n2. call/bind/apply\n3. Promise.all 【 大厂高频 】\n4. instanceof\n5. 柯里化函数，组合函数\n6. 防抖和节流【必考】\n7. Ajax【必考】\n8. 深拷贝与浅拷贝【必考】\n9. 继承【必考】\n10. 数组去重，数组排序【小公司必会】\n11. 数组扁平化\n12. 字符串中出现最多次数的字符\n13. 字符串反转\n14. 字符串驼峰转换\n15. 实现trim过滤字符串空格\n16. 事件委托\n17. 解析url中的key\n18. 正则匹配手机号\n\n\n### Vue \n\n1. vue生命周期(父子组件)\n\n   - created和mounted的区别\n   - 在那个生命周期中获取数据","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/前端学习路线.mdx","loc":{"lines":{"from":144,"to":181}}}}],["6edbb527-9d95-4361-bdbc-74c889d9f609",{"pageContent":"### Vue \n\n1. vue生命周期(父子组件)\n\n   - created和mounted的区别\n   - 在那个生命周期中获取数据\n\n2. computed/methods/watch的区别\n3. v-show和v-if的区别\n4. v-if和v-for优先级 \n5. v-for为什么要用key \n6. 组件通信 \n7. 插槽的使用\n8. nextTick的使用和原理\n9. 常用的指令\n10. scoped的作用\n11. 常用的修饰符\n12. keep-alive的作用？keep-alive中的生命周期钩子\n13. vue如何监听对象或者数组属性的变化\n\n------------\n**面试高频**\n\n1. 说说你对vue的理解？\n2. v-model的实现原理\n3. 双向数据绑定的原理\n4. MVVM和MVC的区别？\n5. 虚拟DOM和diff算法\n6. Proxy和defineProperty的区别\n7. Vue3.0为什么要使用proxy\n8. Composition API\n\n------------\n**路由相关**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/前端学习路线.mdx","loc":{"lines":{"from":176,"to":209}}}}],["7562b1db-771c-4ce2-9392-fbe970bfd418",{"pageContent":"------------\n**路由相关**\n\n1. hash和history模式的区别？\n2. SPA单页面应用的优缺点\n3. params和query传递参数的区别\n4. 路由钩子函数/路由守卫\n5. 路由懒加载\n6. router和route的区别\n7. 编程式导航和声明式导航\n\n--------------------\n\n1. vuex的作用？\n2. state/mutation/action/getter/module的作用\n3. mutation和action的区别？\n\n### React\n\n1. 生命周期\n2. 类组件和函数式组件的区别\n3. setState是同步更新还是异步更新\n4. 高阶组件\n5. 虚拟DOM和diff算法\n6. key的作用\n7. React Hook\n8. Redux工作流程\n\n### Webpack\n\n1. webpack的基础配置和基本概念\n2. loader和plugin的不同\n3. 常用的loader和plugin?\n4. webpack的proxy配置解决跨域问题\n\n### 网络/浏览器","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/前端学习路线.mdx","loc":{"lines":{"from":208,"to":243}}}}],["49d6aaba-4a54-45f7-a201-e1c5a7d6e2fd",{"pageContent":"1. webpack的基础配置和基本概念\n2. loader和plugin的不同\n3. 常用的loader和plugin?\n4. webpack的proxy配置解决跨域问题\n\n### 网络/浏览器\n\n1. TCP/IP网络分层\n2. tcp和udp的区别和使用场景\n3. 三次握手和四次挥手\n4. HTTP请求方法\n5. GET和POST的区别\n6. HTTP请求报文和响应报文、请求头和响应头\n7. HTTP状态码 【 高频 】\n8. HTTP缓存 【 高频 】\n9. HTTP1.0/1.1/2.0/3.0之间的区别？\n10. HTTPS和HTTP之间的区别？\n11. 对称加密和非对称加密\n12. 对Keep-Alive的理解\n13. DNS查询过程\n14. CDN\n\n--------------------\n\n1. XSS攻击及防御\n2. CSRF攻击及防御\n\n--------------------\n\n1. 浏览器页面渲染过程\n2. 浏览器缓存 （强缓存和协商缓存）\n3. 浏览器存储\n\n   - localStorage、sessionStorage、cookie之间的区别？","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/前端学习路线.mdx","loc":{"lines":{"from":238,"to":271}}}}],["34dbe6c5-8a6b-4c2a-b9b0-0543d221fa44",{"pageContent":"1. 浏览器页面渲染过程\n2. 浏览器缓存 （强缓存和协商缓存）\n3. 浏览器存储\n\n   - localStorage、sessionStorage、cookie之间的区别？\n\n4. 从url输入到界面展示，发生了什么？\n5. 重排和重绘\n6. 浏览器进程\n7. 浏览器同源策略\n\n---------------------\n\n1. 进程和线程之间的区别\n2. 进程通信\n3. 死锁\n\n### 其他\n\n1. 项目性能优化方案\n\n- CDN\n- 懒加载\n- 防抖和节流\n- 回流与重绘\n- 图片优化\n- webpack优化\n- 代码优化\n\n### 补充\n\n1. 发布-订阅设计模式\n2. 函数式编程\n3. git的使用 [重要]\n4. 代码规范：eslint","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/前端学习路线.mdx","loc":{"lines":{"from":267,"to":301}}}}],["fdd58c59-3611-4bd3-9b61-f9785274cc32",{"pageContent":"---\ntitle: 前端长度单位\ndate: '2024-05-12'\ntags: ['CSS']\ndraft: false\nsummary: 常用的前端长度单位含义\n---\n\n### **绝对长度单位**\n#### **px**\npx 实际上是一个按角度度量的单位\n#### **in**\n英寸是一个物理度量单位，是在CSS领域，英寸被直接映射成像素\n#### **cm**\n厘米是比较熟悉的物理度量单位,它也映射成像素\n#### **mm**\n毫米是个小数量级的物理度量单位\n#### **em**\nem 是一个相对单位。起初[排版度量](http://en.wikipedia.org/wiki/Em_(typography))时是基于当前字体大写字母”M”的尺寸的。当改变 font-family 时，它的尺寸不会发生改变，但在改变 font-size 的大小时，它的尺寸就会发生变化。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/前端长度单位.mdx","loc":{"lines":{"from":1,"to":19}}}}],["5815e2d9-43fc-42f9-a63e-f2fdc1e4700c",{"pageContent":"在没有任何CSS规则的前提下，1em的长度是：\n1em == 16px == 0.17in == 12pt == 1pc == 4.2mm == 0.42cm\n如果有CSS规则改变了字体大小(不管在文档的什么位置)，1em的长度会变成相对于新的 font-size 的大小。\n\nem单位当设置了font-size属性后，它会逐级向上相乘，所以如果一个设置了 font-size:1.1em 的元素在另一个设置了 font-size: 1.1em 的元素里，而这个元素又在另一个设置了 font-size:1.1em 的元素里，那么最后计算的结果是 1.1X1.1X1.1=1.331rem（根em）。这意味着即使一个元素设置为10em，这个元素也不会在他出现的每个地方都是10em。如果font-size变化了，它可能会更宽，也可能会更窄。\n\n#### **rem**\nrem 和 em一样也是一个相对单位，但和em不同的是 rem 总是相对于根元素(如:root{})，而不像em一样使用级联的方式来计算尺寸。这种相对单位使用起来更简单。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/前端长度单位.mdx","loc":{"lines":{"from":21,"to":28}}}}],["2be24b3d-e28d-434e-aa07-d2308f185639",{"pageContent":"#### **rem**\nrem 和 em一样也是一个相对单位，但和em不同的是 rem 总是相对于根元素(如:root{})，而不像em一样使用级联的方式来计算尺寸。这种相对单位使用起来更简单。\n\n#### **points**\npoint 是一个物理度量单位，1pt=1/72 in。在CSS之外 point 是最常用的尺寸类型。\n在打印样式表和物理媒介中，point是最有意义的，当然也可以用在屏幕媒介上使用，或者其他的地方。值得注意的浏览器支持问题：在屏幕呈现pt尺寸的时候，会有很大的不同。\n\n#### **pica**\npica 和 points 一样，只不过 1pc = 12pt。\n\n#### **ex**\nex是一个基于当前字体的 **x** 字母高度度量的。ex 度量有时根据字体自身的信息，有时由浏览器指明是通过一个小写字形来度量，最糟糕的情况是，它被设置成0.5em。它之所以被命名为“x”的高度，是因为是基于 x 字母的高度的。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/前端长度单位.mdx","loc":{"lines":{"from":27,"to":38}}}}],["97136796-d24f-467f-a80f-25f355f5d766",{"pageContent":"要理解x-height，想象一个小写字母，比如“d”，它会有一部分翘起，x-height是不包括翘起的这一部分的，它的高度是那个字母最下面的那一部分。\n和 em 不同，当改变 font-family 时 em 不会改变，而ex单位会变化，因为一个单位的值和那个字体是特殊的约束关系。\n\n#### **ch**\nch的内涵和x高度相似，只是ch是基于字符0的宽度的而不是基于字符x高度的。当font-family改变的时候ch也会随着改变。\n\n### **百分比长度单位**\n\n#### **vw**\nvw 是可视区宽度单位。1vw等于可视区宽度的百分之一。vw单位跟百分比很相似，不同的是vw的值对所有的元素都一样，与他们父元素或父元素的宽度无关。其是相对于根元素。\n\n#### **vh**\nvh和vw（viewport widht）单位一样，不同的是vh是相对于可视区的高度。   \n\n#### **vmin**\nvmin的值是当前vw和vh中较小的值。在标准尺寸类型的使用实例中，和由自己确定屏幕大小的vw、vh单位相比，vmin是一个更有用的度量标准。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/前端长度单位.mdx","loc":{"lines":{"from":40,"to":55}}}}],["d164192b-8682-4be8-b1ec-0ffca7fc9e81",{"pageContent":"#### **vmin**\nvmin的值是当前vw和vh中较小的值。在标准尺寸类型的使用实例中，和由自己确定屏幕大小的vw、vh单位相比，vmin是一个更有用的度量标准。\n\n#### **vmax**\nvmax的值是vw和vh中的较大的值。\n\n示例\n```css\nimage {\n  width: 100vmin;\n  height: 100vmin;\n}\n```","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/前端长度单位.mdx","loc":{"lines":{"from":54,"to":66}}}}],["4121dbcb-9598-4df1-994a-8f547eccfaed",{"pageContent":"---\ntitle: 浏览器基础\ndate: '2024-04-20'\ntags: ['浏览器', 'javaScript']\ndraft: false\nsummary: 浏览器基础内容\n---\n\n### 渲染流程\n#### 浏览器输入url后经历的过程\n\n1. 首先，在浏览器地址栏中输入url\n2. 浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作\n3. 在发送 http 请求前，需要域名解析(DNS寻址)，解析获取相应的IP地址\n4. 浏览器向服务器发起 tcp 连接，与浏览器建立TCP三次握手\n5. 握手成功后，浏览器向 web 服务器发送HTTP请求，请求数据包\n6. 服务器处理收到的请求，并返回HTTP响应\n7. 四次挥手，释放TCP连接\n8. 浏览器收到HTTP响应，读取页面内容，浏览器渲染，解析html源码\n9. 生成Dom树、解析css样式、js交互\n\n#### 寻址过程\n\n**DNS概念**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/浏览器基础.mdx","loc":{"lines":{"from":1,"to":24}}}}],["bdfb82ac-492c-46b2-ad19-4ad4da5ff5cd",{"pageContent":"#### 寻址过程\n\n**DNS概念**\n\n因特网上作为域名和 IP地址 相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。通过主机名，最终得到该主机名对应的 IP地址 的过程叫做域名解析（或主机名解析）。\n\n**DNS寻址过程**\n\n1. 浏览器从 DNS 缓存文件中查找域名对应的IP，如果没有，进行下一步\n2. 从操作系统的缓存文件（hosts）中查找，如果没有，进行下一步\n3. 从本地域名服务器进行查找，如果没有，进行下一步\n4. 使用**递归查询**或者**迭代查询**，从根域名服务器开始查找\n5. 本地服务器查询到域名的IP地址后，就返回浏览器进行缓存并开始建立TCP链接","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/浏览器基础.mdx","loc":{"lines":{"from":22,"to":34}}}}],["75f06007-a8f1-4d5e-8bdb-51c4b684ae56",{"pageContent":"![](https://cdn.nlark.com/yuque/0/2024/png/253721/1712025866540-cc11b2d0-e55c-4e75-a679-e62b98c0fe68.png#averageHue=%23040404&clientId=uf1daa401-49e3-4&from=paste&height=525&id=u64c401eb&originHeight=464&originWidth=511&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=ua1412573-6564-49a3-ac98-fb8b74e477a&title=&width=578)\n\n**递归查询**\n\n1. 本地域名服务器向根域名服务器发送查询请求\n2. 根域名服务器向顶级域名服务器发送查询请求 \n3. 顶级域名服务器向权威域名服务器发送查询请求 \n4. 若某一个环节查到，则会进行缓存且按照查询的路径返回\n\n**迭代查询**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/浏览器基础.mdx","loc":{"lines":{"from":36,"to":45}}}}],["1b2a405f-a709-4d12-b91b-e1a5c6c51275",{"pageContent":"**迭代查询**\n\n1. 本地域名服务器会先向根域名服务器发送请求获取顶级域名服务器地址 \n2. 本地域名服务器向顶级域名服务器发送DNS解析请求，顶级域名服务器返回权威域名服务器地址 \n3. 本地域名服务器向权威域名服务器地址发送DNS解析请求，获取到域名的IP地址\n\n#### 文档解析\n\n**构建DOM树**\n\n1. 从请求的 HTML 文档中读取到文档字符串\n2. 将文档字符串转换为Token(词语)，每一个标签代码都会被转成一个Token对象（**Token对象的生成是通过元素标签的开始标签和结束标签判断的**，根据子节点标签是否在父节点开始和结束标签之间来判断父子关系）\n3. 当一个 Token 对象产生后，会立即通过该 Token 对象创建DOM节点对象，同时会继续生成新的Token对象\n4. 当所有的DOM节点创建完成后即形成了DOM树\n\n流程图如下","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/浏览器基础.mdx","loc":{"lines":{"from":45,"to":60}}}}],["3dafe38b-b37e-4518-8adc-2408b89af0a8",{"pageContent":"流程图如下\n\n![](https://cdn.nlark.com/yuque/0/2024/png/253721/1712025866533-19d461c4-0711-4ab0-b71e-564f8b6c9f1b.png#averageHue=%23f1eeee&clientId=uf1daa401-49e3-4&from=paste&id=u794c0ad5&originHeight=507&originWidth=1024&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u672cbcf5-3d84-4a48-a59f-a48fddf7861&title=)\n\n生成 Token 的示意图","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/浏览器基础.mdx","loc":{"lines":{"from":60,"to":64}}}}],["0bf156c6-7e41-4f27-bea9-e81f79f615e3",{"pageContent":"生成 Token 的示意图\n\n![](https://cdn.nlark.com/yuque/0/2024/png/253721/1712025866551-a05ffcb1-6d64-4187-92eb-36b2210d539d.png#averageHue=%23b5d998&clientId=uf1daa401-49e3-4&from=paste&id=u1b163cd1&originHeight=107&originWidth=1024&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u2739e3ac-3833-4d8d-9202-1782dcd8eb1&title=)\n\nToken，分为 **Tag Token** 和**文本 Token**，Tag Token 又分 **StartTag** 和 **EndTag**。\n\n每个环境都有对应的**处理类**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/浏览器基础.mdx","loc":{"lines":{"from":64,"to":70}}}}],["ee0ac474-c3c5-40a1-989d-49d70c20d1ca",{"pageContent":"Token，分为 **Tag Token** 和**文本 Token**，Tag Token 又分 **StartTag** 和 **EndTag**。\n\n每个环境都有对应的**处理类**\n\n- 词法分析 HTMLTokenizer 类\n- 词语验证 XSSAuditor 类\n- 从词语到节点 HTMLDocumentParser 类、 HTMLTreeBuilder 类\n- 从节点到 DOM 树 HTMLConstructionSite 类\n\n**构建CSSOM树**\n\n- CSSOM树的构建过程与DOM树类似，都是从字符串转成Token对象再创建对应的节点对象\n- CSS解析时通过递归去获得每个元素的全部样式\n\n**其他过程**\n\n- 构建DOM树过程中如果遇到script标签，会去加载JS代码，如未使用async和defer，则会等到JS代码解析执行完成才继续\n- 浏览器也会同时去构建一个适用于无障碍模式的Accessibility的DOM树\n  \n#### 页面渲染\n**构建渲染树**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/浏览器基础.mdx","loc":{"lines":{"from":68,"to":88}}}}],["3c13fb31-523e-41f9-b0de-06612688f886",{"pageContent":"- 从 DOM 树根节点开始遍历其每个子节点，找到每个节点对应的CSS样式规则并应用\n- 不可见的节点在遍历中会被跳过\n\n**布局**\n\n- 当渲染树构建完成后，从根节点开始遍历，计算每个节点的宽高、位置等信息\n- 第一次确定节点的宽高和位置信息称为布局，后面的每一次变化都称为回流\n- 回流会重新计算节点位置信息，开销较大，且回流一定会触发重绘\n\n**绘制**\n\n- 绘制过程将前面布局计算好的节点绘制在浏览器窗口\n- 当元素的任何属性发生变化时，都会进行“重绘”操作来更新元素\n  \n### 浏览器缓存\n\n缓存是指代理服务器或客户端本地磁盘内保存的资源副本，利用缓存可减少对源服务器的访问，节省通信流量和通信时间。\n\n**HTTP缓存机制**\n\n利用HTTP响应头将所请求的资源在浏览器中进行缓存。\n\n**优点**\n\n- 减少了冗余的数据（重复资源）传输，节省了网费\n- 减少了服务器的负担（开销），大大提升了网站的性能\n- 加快了（提高）客户端加载网页的速度\n\n**浏览器缓存的分类**\n\n- 协商缓存\n- 强缓存\n\n浏览器在第一次请求发生后，再次请求时：","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/浏览器基础.mdx","loc":{"lines":{"from":90,"to":123}}}}],["66c868c8-ce7f-425c-8394-5a09eef8c0f5",{"pageContent":"**浏览器缓存的分类**\n\n- 协商缓存\n- 强缓存\n\n浏览器在第一次请求发生后，再次请求时：\n\n1. 浏览器会先获取该资源缓存的 header 信息，根据其中的 expires 和 cahe-control 判断是否命中强缓存，若命中则直接从缓存中获取资源，本次请求不会与服务器进行通信\n\n2. 如果没有命中强缓存，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的header 字段信息（Last-Modified / IF-Modified-Since、Etag / IF-None-Match），由服务器根据请求中的相关 header 信息来对比结果是否命中**协商缓存**，若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取\n\n3. 均未命中则返回最新的资源内容\n\n### 强缓存\n\n强缓存指的是在缓存时间内不会向服务器发起请求，只有过期之后才会向服务器发起请求。\n\n强缓存分为 **Expires**、**cache-control** 两种\n\n#### Expires","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/浏览器基础.mdx","loc":{"lines":{"from":118,"to":137}}}}],["c5f8ea39-fbd2-499f-8a68-445b95bf77fc",{"pageContent":"强缓存指的是在缓存时间内不会向服务器发起请求，只有过期之后才会向服务器发起请求。\n\n强缓存分为 **Expires**、**cache-control** 两种\n\n#### Expires\n\n该字段是**http1.0** 时的规范，用于表示资源的过期时间的请求头字段，它的值为一个绝对时间的GMT格式时间字符串，是由服务器端返回的。\n\n浏览器第一次请求服务端资源时，响应头会携带 Expires 信息，标识资源过期时间，下次请求这个资源时会根据上次的 **Expires** 字段判断是否使用缓存资源。\n**expires 是根据本地时间来判断的，假设客户端和服务器时间不同，会导致缓存命中误差，且不会判断资源是否变更**。\n\n#### Cache-Control\n\nCache-Control 是 **http1.1** 时出现的 header 信息，主要是利用该字段的 **max-age** 值来进行判断，它是一个相对时间，例如，Cache-Control: max-age=3600，代表着资源的有效期是3600秒。\n\n**常用的设置值**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/浏览器基础.mdx","loc":{"lines":{"from":133,"to":148}}}}],["dc4290d0-0058-4c40-90b0-5f75057479b2",{"pageContent":"**常用的设置值**\n\n- **max-age**\n  \n  缓存失效相对时间，单位为秒，值为3600，表示（当前时间+3600秒）内不与服务器请求新的数据资源\n\n- **s-maxage**\n  \n  和max-age一样，但这个是设定代理服务器的缓存时间\n\n- **no-cache**\n  \n  储存在本地缓存区中，只是在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用\n\n- **no-store**\n  \n  不缓存任何数据\n\n- **public**\n  \n  所有内容都将被缓存(客户端和代理服务器都可缓存)\n\n- **private**\n  \n  内容只缓存到私有缓存中(仅客户端可以缓存，代理服务器不可缓存)\n\n- **only-if-cached**\n  \n  用户只接受中间缓存服务器的资源\n\n**Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高。**\n\n### 协商缓存","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/浏览器基础.mdx","loc":{"lines":{"from":148,"to":180}}}}],["bd5a382f-07e3-46d8-89ec-3c46ee5d0914",{"pageContent":"**Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高。**\n\n### 协商缓存\n\n协商缓存都会**向服务器发送请求**，判断缓存数据是否过期，过期的话会返回新的内容，没有过期则使用本地的缓存数据。对于协商缓存主要利用两个字段：Last-Modify、Etag。\n\n强缓存都是由本地浏览器确定是否使用缓存，当浏览器没有命中强缓存就会向服务器发送请求，验证协商缓存是否命中，如果缓存命中则返回304状态码，否则返回新的资源数据。\n\n请求头字段含义\n\n- **Last-modified**\n  \n  服务器返回给浏览器的资源最近修改时间\n\n- **if-modified-since**\n  \n  浏览器请求服务端携带的资源最近修改时间\n\n- **ETag**\n  \n  是一个文件的唯一标识符，当资源发生变化时这个ETag就会发生变化。弥补了上面 last-modified 可能出现文件内容没有变化，但是last-modified发生了变化出现重新向服务器请求资源的情况，也由服务器返回","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/浏览器基础.mdx","loc":{"lines":{"from":178,"to":198}}}}],["071dcd25-494a-4c36-9e2c-bb0c0b92b5cc",{"pageContent":"- **if-none-match**\n  \n  浏览器请求服务端时带上的字段，值是上次服务器返回的ETag\n\n  浏览器请求服务端资源时会携带**If-Modified-Since 和 If-None-Match** 两个请求头，服务端根据这两个头判断资源是否失效，若未失效则返回给浏览器**304**，让浏览器从缓存中读取文件。\n\n浏览器请求流程图","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/浏览器基础.mdx","loc":{"lines":{"from":200,"to":206}}}}],["81b6e32e-67a7-45b1-b7df-42473e300eef",{"pageContent":"浏览器请求流程图\n\n![](https://cdn.nlark.com/yuque/0/2024/png/253721/1712025866538-0bd5c255-e3c3-4ec9-8977-6ebe810245d9.png#averageHue=%23f9f9f9&clientId=uf1daa401-49e3-4&from=paste&id=ud5d11556&originHeight=859&originWidth=1024&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u6cd55230-fbb3-4c3f-a5ca-da8bad5e75d&title=)\n\n**Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304**。\n\n**强缓存与协商缓存的区别**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/浏览器基础.mdx","loc":{"lines":{"from":206,"to":212}}}}],["df5f4a1b-5730-48c9-92d2-b7b7379d4776",{"pageContent":"**强缓存与协商缓存的区别**\n\n| **缓存类型** | **获取资源形式** | **状态码** | **发送请求到服务器** |\n| --- | --- | --- | --- |\n| 强缓存 | 从缓存取 | 200（from cache) | 否，直接从缓存取 |\n| 协商缓存 | 从缓存取 | 304（Not Modified) | 否，通过服务器来告知缓存是否可用 |\n\n### 浏览器内核\n\n- 浏览器内核包含渲染引擎和JS引擎两部分\n- 渲染引擎负责读取页面内容（XML、图片、CSS等）并处理渲染逻辑，最终展示在视窗内\n- JS引擎负责解析和执行JS代码，处理JS中的事件， 实现页面的动态交互","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/浏览器基础.mdx","loc":{"lines":{"from":212,"to":223}}}}],["04015e17-7dfa-4215-9f2f-7453e315fba3",{"pageContent":"---\ntitle: 计算机网络\ndate: '2024-04-01'\ntags: ['计算机网络']\ndraft: false\nsummary: 计算机网络基础内容\n---\n\n## 网络体系结构\n### OSI 体系结构(7层)\n\n为了使全世界不同体系结构的计算机能够互联，国际化标准组织 ISO 提出开放系统互联基本参考模型，简称OSI，即所谓的7层协议体系结构。\n\n- 应用层\n- 表示层\n- 会话层\n- 运输层\n- 网络层\n- 数据链路层\n- 物理层\n  \n### TCP/IP体系结构（四层）\n\n由实际应用发展总结出来的，因特网从1983年开始使用TCP/IP协议族。(**事实上的国际标准**)\n\n- 应用层\n- 运输层\n- 网际层（网络层，在网络层使用的协议是IP协议（中文：网际协议），因此TCP/IP体系结构的网络层也常称为网际层）\n- 网络接口层\n  \n### 五层体系结构\n\n五层模型只出现在计算机网络学习教学过程中，是对七层模型和四层模型的一个折中，综合了OSI和TCP/IP 体系结构的优点，这样既简洁又能将概念阐述清楚。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/计算机网络.mdx","loc":{"lines":{"from":1,"to":33}}}}],["af0f0992-d302-4f94-92f4-37c1bef71128",{"pageContent":"五层模型只出现在计算机网络学习教学过程中，是对七层模型和四层模型的一个折中，综合了OSI和TCP/IP 体系结构的优点，这样既简洁又能将概念阐述清楚。\n\n- 应用层\n- 运输层\n- 网络层\n- 数据链路层\n- 物理层\n  \n### 各层级对应协议\n| 层级 | 协议 |\n| --- | --- |\n| 应用层 | http 超文本传输协议\nsmtp 电子邮件协议\nftp 文件传输协议\ntelnet 远程登陆协议\ndns 域名系统 |\n| 运输层 | TCP 传输控制协议\nUDP 用户数据报协议 |\n| 网络层 | IP 协议 |\n\n## 域名系统(DNS)\n\n域名系统包含**根域名**、**顶级域名**、**二级域名**、**三级域名**、**四级域名**等。\n\n每一级域名都包含一个域名服务器，域名服务器一共有四类：\n\n- 顶级域名服务器\n- 根域名服务器\n- 权威域名服务器\n- 本地域名服务器\n\nDNS查询有两种方式\n\n- 迭代查询\n- 递归查询\n\n域名解析记录类型包含","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/计算机网络.mdx","loc":{"lines":{"from":33,"to":69}}}}],["f0b4517f-fc1c-4173-bb08-f386feee29f4",{"pageContent":"- 顶级域名服务器\n- 根域名服务器\n- 权威域名服务器\n- 本地域名服务器\n\nDNS查询有两种方式\n\n- 迭代查询\n- 递归查询\n\n域名解析记录类型包含\n\n- A记录 将域名指向一个 IPV4 地址\n- MX记录 将域名指向邮件服务器地址\n- CNAME记录 将域名指向另外一个域名\n- TXT记录 文本长度限制512，通常做 SPF 记录\n- NS记录 将子域名指定其他 DNS 服务器解析\n  \n## HTTP协议\n\nHTTP **超文本传输协议**，是用于从万维网服务器传输超文本到本地浏览器的传送协议。基于TCP/IP通信协议来传递数据。\n\n### HTTP 状态码\n\n- 1xx 服务端收到请求，但需要客户端再发一个请求以进行后续动作\n- 2xx 服务端收到请求并处理成功\n- 3xx 临时请求，需要进一步细化 重定向\n- 4xx 客户端发起请求出现了问题\n- 5xx 服务端处理请求出现了问题\n  \n### HTTP 1.0\n\n1.0的HTTP版本，是一种无状态，无连接的应用层协议。 HTTP1.0 规定浏览器和服务器保持短暂的链接。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/计算机网络.mdx","loc":{"lines":{"from":59,"to":91}}}}],["671162dc-295c-42c0-ace8-2195fb967222",{"pageContent":"1.0的HTTP版本，是一种无状态，无连接的应用层协议。 HTTP1.0 规定浏览器和服务器保持短暂的链接。\n\n- 无法复用连接，每次请求都会建立一个新的TCP连接\n- 队头阻塞，后一个请求必须得在前一个请求响应之后才能发起\n- 没有 host 域\n  \n### HTTP 1.1\n\n- 默认支持**长连接**，增加了 **Connection** 字段，通过设置 **Keep-Alive** 保持HTTP连接不断卡\n- **管道化**(**假并行传输**) 后一个请求可以在前一个请求响应前发起，但请求的响应必须与发起顺序相同\n- 增加了缓存处理(**强缓存、协商缓存**)\n- 增加了Host字段，允许一个服务端同时处理多个Web站点的请求\n- 由于长连接会给服务器造成压力\n  \n### HTTP 2.0\n\n- **二进制分帧** \n  \n  在应用层和传输层之间增加一个二进制分层帧，将请求header和body通过二进制编码分帧后传输，从而提升性能改进传输性能","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/计算机网络.mdx","loc":{"lines":{"from":91,"to":109}}}}],["e1dee3e9-7d25-4251-b749-04aa1419e758",{"pageContent":"- **二进制分帧** \n  \n  在应用层和传输层之间增加一个二进制分层帧，将请求header和body通过二进制编码分帧后传输，从而提升性能改进传输性能\n\n- **多路复用**(**真并行传输**)，\n  \n  可以在一个连接中并行请求，并通过帧头的stream id来进行消息组装和请求归属\n\n- **头部压缩**\n  \n  使用HPACK算法进行头部压缩\n\n- **服务器推送**\n  \n  服务端可以主动向客户端推送消息\n\n### HTTP 3.0\n\nGoogle 搞了一个基于 UDP 协议的 **QUIC** 协议，并且使用在了HTTP/3上， HTTP/3之前的名称为 HTTP-over-QUIC。\n\n- **0-RTT — QUIC协议相比HTTP2.0的最大优势** \n  \n  缓存当前会话的上下文，下次恢复会话时，只需将之前的缓存传递给服务器，验证通过，即可进行传输\n\n- **多路复用** \n  \n  QUIC基于UDP，一个连接上的多个stream之间没有依赖，即使丢包，只需要重发丢失的包即可","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/计算机网络.mdx","loc":{"lines":{"from":107,"to":133}}}}],["c720abc9-f7f3-4996-b568-ccca63613c44",{"pageContent":"- **多路复用** \n  \n  QUIC基于UDP，一个连接上的多个stream之间没有依赖，即使丢包，只需要重发丢失的包即可\n\n- **更好的移动端表现** \n  \n  而QUIC是通过ID识别链接，无论网络环境如何变化，只要ID不变，就能迅速重连\n\n- **加密认证的报文** \n  \n  武装到牙齿\n\n- **向前纠错机制** \n  \n  每个数据包除了它本身的内容之外还包括了其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传\n  \n## HTTPS\n\n### 概念\n\n**安全超文本传输协议**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/计算机网络.mdx","loc":{"lines":{"from":131,"to":151}}}}],["d31ff0fa-4de5-4ac3-95c2-c92e14c182b7",{"pageContent":"### 概念\n\n**安全超文本传输协议**\n\n  HTTPS 利用 HTTP 协议位于应用层，底层可以调用多种协议的可扩展性，通过调用**SSL安全套接字层/TLS**（传输层安全协议）保证数据传输的安全（**SSL就是TLS的前身**，TLS 在 SSL 基础上做了部分优化，所以文章后面直接用 TLS 代称 SSL/TLS）因此 HTTPS 在 TCP 三次握手之后还需要进行 **TLS 握手**，并且二者之间还有一个区别是 HTTP 默认端口是 **80 且性能较低**，而 HTTPS 是 **443 且性能较高**（**基于 HTTP + SSL/TLS**）。\n\n**优点**\n\n- 数据完整性 \n  \n  内容传输会进行完整性校验\n\n- 数据加密性 \n  \n  内容经过对称加密，每一个链接生成唯一密钥\n\n- 身份认证 \n  \n  第三方无法伪造客户端（服务端）的身份\n\n### 加密方式\n\n- **对称加密** \n  \n  同一个密钥可以同时用作信息的加密和解密(算法公开、计算量小、加密速度快、加密效率高)","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/计算机网络.mdx","loc":{"lines":{"from":149,"to":173}}}}],["3eea7327-03a5-49ff-bcd5-607f7dc55957",{"pageContent":"### 加密方式\n\n- **对称加密** \n  \n  同一个密钥可以同时用作信息的加密和解密(算法公开、计算量小、加密速度快、加密效率高)\n\n- **非对称加密** \n  \n  需要**两个密钥来进行加密和解密**，这两个密钥是**公开密钥(public key，简称公钥）**和**私有密钥(private key，简称私钥)**\n\n- **非对称加密+对称加密** \n  \n  先通过对称加密来加密报文，再通过非对称加密来加密对称加密的密钥\n  \n### 数字签名\n#### 数据摘要\n\n**数据摘要（也称为数字指纹）是指通过一种算法将任意长度的数据转换成固定长度的二进制字符串**。这个转换过程使得不同的数据很难产生相同的数字指纹，同时保证相同的数据始终能够生成相同的数字摘要\n\n**特点**\n\n- **唯一性** \n  \n  理论上，不同的数据生成的数字摘要应该是唯一的，即使数据中只有微小的差异，生成的数字指纹也会有显著的变化\n\n- **不可逆性** \n  \n  数字指纹的生成算法具有不可逆性，不能通过数字指纹还原出原始数据，这样可以保持原始数据的机密性","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/计算机网络.mdx","loc":{"lines":{"from":169,"to":196}}}}],["543018d3-9e71-4e91-9437-f680de70be64",{"pageContent":"- **不可逆性** \n  \n  数字指纹的生成算法具有不可逆性，不能通过数字指纹还原出原始数据，这样可以保持原始数据的机密性\n\n- **固定长度** \n  \n  生成的数字指纹具有固定的长度，不论输入数据多长，都会生成指定长度的数字指纹。\n\n- **敏感性** \n  \n  对于输入数据的微小改动，生成的数字指纹也会有较大的差异，这使得数字指纹可以用于检测数据是否被篡改\n  \n#### 数字签名\n\n**数字签名是一种用于验证电子文档或数据完整性和真实性的技术手段**。它类似于传统纸质文件的签名，在数字领域提供了身份认证、数据完整性保护和防止抵赖等功能。\n\n**基本原理如下**\n\n- **私钥和公钥** \n  \n  数字签名使用非对称加密算法，签名者拥有一对密钥，一个私钥，用于生成数字签名；一个公钥，用于验证签名\n\n- **数据摘要** \n  \n  签名者首先对原始数据进行哈希计算，生成唯一的数据摘要，数据摘要的作用是将数据压缩成固定长度的字符串，具备唯一性和不可逆性","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/计算机网络.mdx","loc":{"lines":{"from":194,"to":218}}}}],["307e4d49-5e10-4655-a93b-8e9e362383f3",{"pageContent":"- **数据摘要** \n  \n  签名者首先对原始数据进行哈希计算，生成唯一的数据摘要，数据摘要的作用是将数据压缩成固定长度的字符串，具备唯一性和不可逆性\n\n- **数字签名生成** \n  \n  签名者使用私钥对数据摘要进行加密操作，生成数字签名，只有使用对应的公钥才可以验证数字签名的合法性\n\n- **数字签名验证** \n  \n  接收者获取到原始数据、数字签名和签名者的公钥。接收者使用签名者的公钥（CA公钥是公开的）对数字签名进行解密操作，得到解密后的数据摘要。然后，接收者对原始数据进行同样的哈希计算，生成新的数据摘要。最后将两个数据摘要进行比较，如果相同，则说明数据完整且未被篡改，数字签名有效\n\n**签名流程**图示","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/计算机网络.mdx","loc":{"lines":{"from":216,"to":228}}}}],["50b2a829-2972-4420-bf9e-47ce84cd113f",{"pageContent":"**签名流程**图示\n\n![](https://cdn.nlark.com/yuque/0/2024/png/253721/1712026024001-93b3aa9a-33c2-4a5f-a1b4-3c445fbaef4a.png#averageHue=%23f7f6f6&clientId=ud1258a6e-3579-4&from=paste&height=988&id=u4f739e51&originHeight=1024&originWidth=634&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u4dde42bd-b535-41c3-baa3-4e21f2f4a6a&title=&width=612)\n\n**验证流程**图示","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/计算机网络.mdx","loc":{"lines":{"from":228,"to":232}}}}],["d8754676-0d6d-41cd-9ce6-09d608ba8e14",{"pageContent":"**验证流程**图示\n\n![](https://cdn.nlark.com/yuque/0/2024/png/253721/1712026024177-c0772b73-91c4-4801-8fb5-9f542f3a4961.png#averageHue=%23f6f6f6&clientId=ud1258a6e-3579-4&from=paste&id=uc1f004f9&originHeight=1006&originWidth=682&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=uc790c864-f62c-49b0-b673-54a13bf03f5&title=)\n\n### 数字证书\n数字证书由CA机构颁发，并且会在系统和浏览器中预装根证书。\n\n## TCP / UDP\n### TCP","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/计算机网络.mdx","loc":{"lines":{"from":232,"to":240}}}}],["c9a1aaea-a79d-4912-b6ca-897b073157ea",{"pageContent":"### 数字证书\n数字证书由CA机构颁发，并且会在系统和浏览器中预装根证书。\n\n## TCP / UDP\n### TCP\n\nTCP 是一种面向**有连接**的**可靠的**、**基于字节流**的传输层协议，能够对自己提供的连接实施控制，适用于要求可靠传输的应用，例如文件传输。**每次数据传输都需要先建立连接**。\n\n**特点**\n\n- **面向连接** \n  \n  一定是“一对一”才能连接，TCP协议无法实现一个主机向多个主机发送消息，即一对多是无法实现的\n\n- **可靠的** \n  \n  无论网络链路中出现怎样的链路变化，TCP都能保证一个报文一定能到达接收端\n- **字节流** \n  - （1）当使用TCP协议进行传输时，**数据传输可能会被操作系统分组成多个TCP报文**，如果接收方不知道数据的边界，就无法读取出一个有效的数据。\n  - （2）同时TCP的**报文是有序的**，当接收方先接收到后一个报文，前一个报文没有收到时，也不能交给应用层去处理\n  - （3）当TCP接收到重复的TCP报文时，会**自动丢弃重复的报文**，只保留一个\n\n**TCP原理**","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/计算机网络.mdx","loc":{"lines":{"from":236,"to":258}}}}],["8c0a830f-8e0b-4f82-ad7a-c58e9b92c8ba",{"pageContent":"**TCP原理**\n\nTCP的可靠性传输是由**确认应答机制**和**超时重传机制**来实现的。\n\n- **1)、确认应答机制（安全机制）**\n  \n  确认应答机制是发送端发送数据给接收端，接收端收到数据后给发送端发送一个应答报文。\n- **2)、超时重传机制（安全机制）**\n- **3)、连接管理机制（安全机制）**\n\n  在正常情况下，TCP要经过三次握手建立连接，四次挥手断开连接。\n- **4)、滑动窗口机制（效率机制）**\n\n  使用滑动窗口机制，一次发送多条数据，可以提高性能（将多个段的等待时间重叠在一起）操作系统开辟**发送缓冲区**，确认应答的才会从缓存区清空。\n- **5)、流量控制机制**\n\n  接收端将自己可以接收的缓冲区大小放入 TCP 首部中的 “窗口大小” 字段，通过ACK端通知发送端；窗口大小字段越大，说明网络的吞吐量越高；\n\n  接收端一旦发现自己的缓冲区快满了，就将窗口大小设置成一个更小的值通知给发送端；发送端接受到这个窗口之后，就会减慢自己的发送速度；","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/计算机网络.mdx","loc":{"lines":{"from":258,"to":276}}}}],["ccd02fa8-e77e-438a-a8f5-8d49a951eed8",{"pageContent":"接收端一旦发现自己的缓冲区快满了，就将窗口大小设置成一个更小的值通知给发送端；发送端接受到这个窗口之后，就会减慢自己的发送速度；\n\n  如果接收端缓冲区满了，就会将窗口置为0；这时发送方不再发送数据，但是需要定期发送一个窗口探测数据段，使接收端把窗口大小告诉发送端\n\n- **6)、拥塞控制（安全机制）**\n\n  虽然 TCP 有了滑动窗口这个大杀器，能够高效可靠的发送大量的数据。但是如果在刚开始阶段就发送大量的数据，仍然可能引发问题。TCP引入 **慢启动**机制，先发少量的数据，了解网络拥堵状态，再决定按照多大的速率传输数据。\n\n- **7)、延迟应答（效率机制）**\n\n  如果接收数据的主机立刻返回ACK应答，这时候返回的窗口可能比较小 。**窗口越大，网络吞吐量就越大，传输效率就越高**。\n\n- **8)、捎带应答（效率机制）**\n\n  基于延时应答的基础上，引入的。**ACK**是立即就要返回的，但是由于延时应答，业务上也有一个响应的报文，就将二者合并打包发送。\n\n### UDP","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/计算机网络.mdx","loc":{"lines":{"from":276,"to":292}}}}],["408b6066-1690-47da-9a82-b78ab8a1ba60",{"pageContent":"- **8)、捎带应答（效率机制）**\n\n  基于延时应答的基础上，引入的。**ACK**是立即就要返回的，但是由于延时应答，业务上也有一个响应的报文，就将二者合并打包发送。\n\n### UDP\n\nUDP 是一种面向**无连接**的、**不可靠的**、**面向数据报**的传输层协议，不会对自己提供的连接实施控制，适用于实时应用。\n\n**特点**\n\n- 提供无连接的，尽最大可能的数据传输服务\n- 无连接，不保证可靠的交付\n- 面向报文\n- 没有拥塞控制，即使网络阻塞依然不影响发送速率\n- 支持一对一、一对多、多对多传输\n  \n## 三次握手与四次挥手\n\nTCP 提供面向连接的服务，在传送数据之前必须先建立连接(三次握手)，数据传送结束后要释放连接（四次挥手）。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/计算机网络.mdx","loc":{"lines":{"from":288,"to":306}}}}],["e572abae-8aaa-4584-a042-44da70ccbbd4",{"pageContent":"TCP 提供面向连接的服务，在传送数据之前必须先建立连接(三次握手)，数据传送结束后要释放连接（四次挥手）。\n\n![](https://cdn.nlark.com/yuque/0/2024/png/253721/1712026024036-3281b6f6-df0c-48ea-b121-89246a68658f.png#averageHue=%23dbe4c8&clientId=ud1258a6e-3579-4&from=paste&id=uf874dfed&originHeight=902&originWidth=801&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=ua409d6b9-40b5-41fc-9149-848c88a2353&title=)\n\n### 三次握手","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/计算机网络.mdx","loc":{"lines":{"from":306,"to":310}}}}],["d14944bd-5d67-44a5-a976-42830aea95cb",{"pageContent":"### 三次握手\n\n- **第一次**\n  \n  客户端发送建立TCP连接的请求报文，其中报文中包含seq序列号，是由发送端随机生成的，并且将报文中的SYN字段置为1，表示需要建立TCP连接。（SYN=1，seq=x，x为随机生成数值）\n\n- **第二次**\n  \n  服务端回复客户端发送的TCP连接请求报文，其中包含seq序列号，是由回复端随机生成的，并且将SYN置为1，而且会产生ACK字段，ACK字段数值是在客户端发送过来的序列号seq的基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP建立请求已得到验证。（SYN=1，ACK=x+1，seq=y，y为随机生成数值）这里的ack加1可以理解为是确认和谁建立连接\n\n- **第三次**\n  \n  客户端收到服务端发送的TCP建立验证请求后，会使自己的序列号加1表示，并且再次回复ACK验证请求，在服务端发过来的seq上加1进行回复。（SYN=1，ACK=y+1，seq=x+1）\n\n**SYN 标志数为 1，表示建立 TCP 连接；ACK表示验证字段**\n\n### 四次挥手","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/计算机网络.mdx","loc":{"lines":{"from":310,"to":326}}}}],["439d8c85-6487-49f8-8e5e-dda8ae55eb33",{"pageContent":"**SYN 标志数为 1，表示建立 TCP 连接；ACK表示验证字段**\n\n### 四次挥手\n\n- **第1次挥手**\n  \n  客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态；\n\n- **第2次挥手**\n  \n  服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务端进入CLOSE_WAIT状态；\n\n- **第3次挥手**\n  \n  服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入LAST_ACK状态；\n\n- **第4次挥手**\n  \n  客户端收到FIN后，客户端进入TIME_WAIT状态，接着发送一个ACK给服务端，确认序号为收到序号+1，服务端进入CLOSED状态，完成四次挥手\n\n**FIN 标志位为1，表示断开TCP连接**。\n\n## CDN\n\n**CDN** 即内容分发网络，在距离用户更近的地方设置缓存服务器，当用户访问资源时，由该缓存服务器返回资源，从而提升响应速度。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/计算机网络.mdx","loc":{"lines":{"from":324,"to":348}}}}],["18130d82-d946-4c47-a58c-68bc53eb9e29",{"pageContent":"**FIN 标志位为1，表示断开TCP连接**。\n\n## CDN\n\n**CDN** 即内容分发网络，在距离用户更近的地方设置缓存服务器，当用户访问资源时，由该缓存服务器返回资源，从而提升响应速度。\n\n当用户访问CDN地址时，请求会先打到CDN负载均衡服务器上，再由该服务器选择一台CDN缓存服务器去请求资源。\n\nCDN的缓存除了受缓存时间到期自动刷新外，也支持用户手动刷新。\n\nCDN的好处除了提升响应速度，还包含隐藏源服务器IP、分散请求压力等。","metadata":{"source":"/Users/luoqingxiang/Documents/my-blog/blog-site-template/data/blog/计算机网络.mdx","loc":{"lines":{"from":344,"to":354}}}}]],{"0":"5040da0e-0a63-4916-a188-4c95dc435e54","1":"4be754a4-89e2-4ca1-9524-16f3289294ec","2":"35e2d5af-6ee2-4db4-9310-9aa13cdb6c13","3":"360d0bf5-2d16-4ef5-8425-4a485dbe218e","4":"1de17dee-7d7f-4057-9e15-dc700e415680","5":"c58263f9-bd18-48b9-b169-b3d2b79248d7","6":"befb9a3d-ee0d-4953-9be3-8be7b0c76690","7":"5d99fa1d-9512-4a37-a6b7-3e653fe96471","8":"feb1758e-d0bc-4a4a-bcb8-d2ea7cf97b1f","9":"d066eddc-ad61-4a0f-8433-c46a99163495","10":"3c45f4ad-8048-4d8a-8f31-a942732da764","11":"b35eb30e-f5b3-4ac0-b78f-f54bd4cb8b19","12":"3a824b58-01bd-412b-a239-7614c59f6616","13":"f3da158c-cdc3-4546-be33-0bf057fe59c4","14":"f6036deb-9731-4d09-988c-c48599774e0e","15":"f78e3b44-eb7e-4197-b8d0-a5d2198a04c8","16":"0fd7cb39-36dc-4f98-8387-08090356d090","17":"9f4a3313-c75c-4310-a99c-dc602b70dc0b","18":"aa05edc5-c8fa-4a65-992e-8337463af661","19":"86d56b22-f6e1-4afa-b5ba-f54dadbb85a5","20":"d8d64f27-838a-4078-823f-1bae3a68213b","21":"77704ddb-80be-4a37-be86-e3dddacc64fa","22":"edcd9abc-a1cc-4126-8cd0-e822766b1e67","23":"b1457ed4-e8a1-49b1-a6f7-da5cfc000e5b","24":"158307e2-7089-4915-8eae-4cb451ffabca","25":"9428ac30-e3f4-458e-8f3f-9bc76c98a5c7","26":"d21092f9-9d6a-4df5-8327-9df6abe69ba7","27":"a30adce9-2b3c-4508-b3f9-c7847cc6a371","28":"0b28ab4d-99a2-421f-a268-026c20f872fa","29":"f84f079c-02a7-4924-86ff-8e9099287dac","30":"d111cd66-975f-40e3-90dc-6abe37533838","31":"3fa3ba7a-cfab-475d-8f2f-733e3b51f4a1","32":"454e4907-7d9d-4e49-b1d8-14467e1221a6","33":"3944a5ce-edb8-43ba-b909-cc33dfa2b398","34":"3890de09-88bd-4b27-976b-d952820dc7d5","35":"3756f441-510e-4284-bd15-bf04c69aca76","36":"3011ed0f-03db-437c-b141-b0588d5ed156","37":"4a4265ec-4b31-4fce-98d8-19df9b59341b","38":"7854f120-b2a7-430a-89e3-99efb43c5b2f","39":"fa9171e3-8fa1-4b9d-8930-c6c4bf9cb315","40":"354fb307-bcec-4cb1-b379-7760d19d7cb5","41":"0fc685a9-ac06-437b-9386-0ac27d640461","42":"b4844708-157a-45ba-8afa-f1389400c608","43":"7c1e907d-c614-47b5-9aab-dbb915569112","44":"e0b6f6e8-188b-463a-b0b6-32d36744bbd1","45":"230b0d44-5f01-4508-aaef-f02c6105e44d","46":"e828da98-4578-47de-8e96-92f99cef8a4c","47":"46f91035-42e5-443f-b79e-38c6fa667f13","48":"3c4d0219-aee0-49ff-ba77-1c710e824732","49":"8d47c5c2-a897-42fe-beb6-165e02ebb165","50":"87b44d62-9a88-49d7-a0b4-30e04782a515","51":"4ced1339-c23a-460a-9d04-3b1abfb90ee8","52":"3467e5cd-c08b-401c-9135-f4b8b59cae4d","53":"fd187602-ec9d-4753-b5d0-418d4d762d50","54":"d955b044-2dde-4c37-8d38-ff879f282ffa","55":"2378c22b-ef3a-45d1-8f52-279ada688402","56":"1912e189-b94c-490f-879c-72a59081a9fc","57":"aff7a466-852c-451e-a3c1-44ca26469982","58":"98704e4b-f1e6-4a7f-84cf-79c920c868e9","59":"c20903a1-fb64-49d7-af37-3a984862686b","60":"6298e876-8277-40a5-a5c8-9c5936b4aa11","61":"db4cee14-50ed-49e4-a0b1-5e5581b6afeb","62":"d1250ac8-1811-46ac-8788-52cca14f9f8c","63":"2562c0cc-d582-4321-a08c-ca035af6baf0","64":"d8e46d47-0fd1-463e-bf27-61d0d6f89212","65":"aeeae56d-d067-4e5b-bbd8-6becfdf24164","66":"4faadbb7-f8bd-4506-86df-7d11b1cedcb3","67":"fd76a021-3664-431b-b9da-ededb3ef2926","68":"4e183079-7e27-455e-9227-3685b40c2c15","69":"6cea9ea0-931c-4090-a07d-9920689c53ec","70":"8dd6ef00-f88d-4c4f-ad07-360216f97321","71":"061470e5-363e-4d28-afbf-f0161eb32363","72":"fe1a923f-1fe8-4f3d-aa06-545f4aca6704","73":"dde9c0df-3cc1-434b-b360-e5335aad5283","74":"20a92555-1d36-4f50-8a37-564b471436da","75":"465100cb-70c2-442a-bf80-c10d82e938b8","76":"c377cab6-e244-4a6d-84eb-431915e5770e","77":"702c8f4e-501b-46c8-8296-d2848292b9f9","78":"2607211e-43f4-4253-94ec-5f979c8d1126","79":"0635e659-2566-4753-bbe6-ad27d2394d9c","80":"e2abc4a7-4be8-4d71-9d2e-71d24af5bab0","81":"f519923d-3779-499e-abc5-23176719533e","82":"0f933a83-c8d5-4db6-98fc-bb78e430a4a7","83":"363f7fa2-4a51-4a60-96f9-ac91533f0cdb","84":"88e8d74c-9bf2-4615-bf63-8a75d92a9088","85":"feb1ad4b-ec38-439a-92a8-60551ea7c836","86":"d1419343-60ae-4a58-97cd-ca8490d9f453","87":"8cb48538-e246-42a8-8d97-6fb3dff9adec","88":"58af4436-c9e0-4f9d-bece-5b91951805fd","89":"5efd94f7-a8ad-48ef-b28d-7a4fa5e83243","90":"c403ec5c-44b8-4945-89a5-f21da8495cbe","91":"96023e99-32f8-4dda-a9d2-3f6df505df93","92":"52bf5cab-00de-47ce-925d-c45cce9ca568","93":"55cf0c65-24bd-4397-9708-94486454c306","94":"8b159284-1dff-40f0-a0ea-4571b75a08c3","95":"96fef29c-1abf-4027-b84a-6e85ba9c72c6","96":"ee858399-cd96-4648-850a-f4b4318a19d8","97":"9c1be010-4c76-45b2-9047-cc798091b9fc","98":"e7a19d53-3eae-4261-85a3-1616c97caacc","99":"e201ed0d-96ea-403e-8a7c-82a04a0147a9","100":"563c5e19-786b-42bb-b014-2964fd422c36","101":"01e75eac-16b7-4a9a-8b6c-ef3ef9863732","102":"975497ea-50fb-4d02-bae2-4d10ecb104d5","103":"ab6688f5-c84e-4c6f-b485-bb5e752b3089","104":"fa3a1357-6f73-4ae4-95f2-08818a253a8c","105":"171e798f-d780-4218-870a-66a03a4e45bf","106":"501fc707-133d-4a6b-8f14-9a275fb2350b","107":"a86c78c8-cfb2-45ac-9496-dfbca6bf5e84","108":"0b73eaf9-a21a-4eac-af8e-f03fc6f176f7","109":"79baa21f-6b41-4c78-8f89-bcfadefdf366","110":"c8c7effd-da8b-4674-a11b-c66e4f74354a","111":"c0a56b08-bc6d-4e43-9852-d0c3d2a6aa16","112":"1f85ebcc-6eaf-4280-a892-6338d7be86dd","113":"7f6d490f-a187-42ab-bd68-5afd5c545111","114":"b6b8b3e5-cc2b-4cf1-a7e4-55fa68380bb9","115":"9776e514-eba6-456e-acc4-6e937cba4038","116":"54c3638f-9e79-48bc-90c5-b621a42de77f","117":"ea39e474-d0cc-4d45-a05e-444508894088","118":"194f57c3-789e-4a1b-8d2f-95cc5b24aa59","119":"8613c31a-c16b-46b0-a600-95b2b5dc79bd","120":"31c73be8-7dc5-4fea-bea6-47bab4248cbb","121":"b5f66f1a-3580-4f3b-b954-d097def16063","122":"e4d1ae2a-c0b6-4512-9ae6-270a3ef31318","123":"7892eafc-b654-4dcd-83b5-66368cf928ee","124":"cd4588a8-4d7e-409e-a744-afd055adf166","125":"e77c932d-0b53-49bb-9163-24d44f6ea674","126":"57f33a58-dbcb-45e2-a855-be81f98e73ca","127":"480d328c-4f0d-446d-aabb-1b10c1d2223f","128":"8cd86ced-357e-4324-9a60-d9419e63795d","129":"5f12754a-0150-4ced-94ce-0e98b6ec8ef4","130":"5ec1d104-e707-4f90-91dc-a57597acec9c","131":"7e504552-59ff-435e-877c-6e3c32a51d7d","132":"e4d99aa3-c269-4f98-94ac-ac7f738ea7c8","133":"86e9ca90-4991-4e2b-8a9c-f8de97bc2b3d","134":"3042079d-463c-444f-8d7d-3160508f1272","135":"685991af-6c60-4c15-a950-ba4ff8061a30","136":"88eac97b-65fb-44a9-8cf5-a031204b8170","137":"b7f57aac-6444-4026-90d3-6e273af2bd51","138":"599802d5-6005-4ff1-b10d-912a7a570b54","139":"a4864998-dcc0-4e8a-9d9b-88ee187c738b","140":"c6904bcd-7dce-4b93-968c-303862dd593d","141":"7e979159-a7ff-4c8e-8962-2c069f0a2c26","142":"0f013c54-4ba6-4167-8add-6d41a541865a","143":"6e38e796-c102-4f69-84eb-c86b433f1cea","144":"ff51628b-be55-4b95-89c4-cc91291d3f9a","145":"35461804-be70-4659-b8ee-17b7df42c455","146":"082b98fc-f9c9-4614-ba1a-d5fdd064a22a","147":"ed2d5547-3c65-49dd-84df-72151902fd07","148":"0ce6490a-37f7-405c-abc7-b8c764823de4","149":"c6d36054-2f87-47fd-98b0-edc08f5a85b0","150":"8c1c0c35-962a-4c78-8a72-a518f2c279d4","151":"8a3e5dd8-27d5-4be9-a08d-45cc5b8145f5","152":"5079a73c-3abc-4420-96ca-07502775e9f0","153":"0d658cac-2394-4a73-8056-cbf88c93518b","154":"2ebc185a-2d47-4fb7-9fce-037afaa59c38","155":"8473ffa0-53a4-405f-af35-6d489c63d132","156":"ebb2190b-4ab3-4ee5-b085-18bc796a71f9","157":"e2c3552d-68d8-42b9-8410-08dec67956e8","158":"1868c2ae-3025-4d03-b5a5-cf78111b871a","159":"3510a998-aaf8-4067-9f8e-d3f1d5e1d89c","160":"18d9c37c-c2b5-47b1-9abf-b78127770c2a","161":"355d1d84-fdad-4742-bac9-8c864e3f4a15","162":"5e850736-3539-40a9-9dac-8b5d91a2e019","163":"6c45e1b7-b763-4149-aa1d-150d0b59450f","164":"27b5c667-6701-4636-9c8c-d381a33a8c95","165":"3b07a482-b8a2-4a39-a1ad-df5be56ee97f","166":"98dbcca0-3130-44cd-9308-4daaeb16934b","167":"517fc8a7-1b9f-46bb-8b6f-79f772a81984","168":"f30df21e-6860-4436-ace1-fcb0c482d97e","169":"8b101e71-9b05-4e17-9b6b-0d1daea13e5f","170":"4c7c20ae-420e-4c66-839b-3a0865b0beb2","171":"bf985ca5-68e7-47dd-9c4c-01d09c37d6f7","172":"73f0a023-67c8-49a7-b37a-a2bf12cf914c","173":"932c7262-f5f7-4784-9906-080f3d54277f","174":"a51e999e-9bea-475d-80bb-8fbab12d5161","175":"7f47bab2-65d5-4614-b331-358f1dbe5251","176":"e82911f6-5f55-4edf-97fc-71271c308b38","177":"50629b65-4b87-4776-a81e-d9cb3e447822","178":"d5d98e59-d310-40c8-b00f-1f4f1b967f37","179":"91331e8b-e7d4-4b40-a15f-70b75183fe8d","180":"c2265291-c69c-43e7-93f2-51c8e9b93f12","181":"9c452c60-c907-4296-81fc-05c10500ebb5","182":"c52f0e20-6a8f-4df4-81c2-c67b017bfce3","183":"f347d254-9f6b-414a-a4e8-297307650f54","184":"3330727d-78c1-4f7f-b267-2832378ef38c","185":"cf910a8d-3243-4866-bfbd-bd01ad63c602","186":"eaac91b2-de36-4bb6-a3de-2afdedac28ba","187":"bf33b124-194d-4738-bc2e-098e0f933ca7","188":"0ecda16e-40d1-4313-aa51-505431207bef","189":"4cbe76d4-d81e-43fa-a7f9-d0c98688d2ba","190":"4f82b75c-190a-46d5-9acd-c16181b98ce9","191":"590cdec7-3688-4521-8829-6861df96ead4","192":"cb124469-fbc5-4b0a-bfd7-7a7b2614fda1","193":"52b695de-4eab-42ae-9def-0beea3762a7e","194":"2291e964-9bcd-436b-95f9-d0dcb4543054","195":"7a340e9f-64c5-4e5c-b13a-ecbfd078a149","196":"fb8e378a-6a98-443b-a358-dd3dbeb0faab","197":"aede7c0d-72b0-4c96-8cb7-fd07de449639","198":"8810f0ed-7183-4740-88f2-b3204e46efdc","199":"43211874-88df-45d7-b374-4b1f9c769a5d","200":"f02f0c06-b256-4e90-aa93-9cfe3e811936","201":"d2925972-6343-4312-b1ea-b24d120b5105","202":"0277bec8-2b6d-49d8-8c3f-8fdd6aea15ae","203":"e85e3b6a-0175-4807-be61-b26ef324c23f","204":"8c84555a-48bd-4d19-9ac2-4e37d862d888","205":"376d1311-f452-4386-a914-0bf8d55d6aa2","206":"01f07f77-e163-4e93-a272-3d464372c943","207":"50cb5233-6245-44e3-840b-21586a3c85b9","208":"74cb436e-b777-490b-ade3-f341de412a0f","209":"76f5ad5a-b64f-4655-89a2-085cb974a848","210":"956fb0f6-d0b3-4b5a-983a-e7486da09256","211":"02378f94-e84a-4457-b16a-b514bd8ff4f4","212":"b867ba34-4a5d-47dc-9d73-24eca37afb7f","213":"731f7b3c-c658-41cb-b5fb-a98bfa748d5f","214":"a79aed80-af35-462b-a720-5530fbac3971","215":"683e2d18-ce3f-4ae8-8941-b46a76d68bd2","216":"982325b7-2fdd-419e-8177-b00052bcd453","217":"b8be3eb9-9f6a-41f5-bb1d-7345bdc03f54","218":"853d9c6d-db33-4ea0-9ea5-98a605242954","219":"9ab0108b-bebd-43e9-8ea9-d352d679b679","220":"2c7cb656-3abf-4631-afd5-5a84632803ed","221":"7cbcd254-e412-4499-97aa-d398ce5233f7","222":"86a5293a-a634-4eb9-a0a4-c1bede737ece","223":"77769cf5-f74b-48f4-965d-7241028cf261","224":"dbd1ac21-6b42-4971-85fc-2b3843540884","225":"ee8eb2c0-6851-4a1f-be1e-21a63ea244bf","226":"57f6dc60-15e6-4145-9efe-9b8ca902621e","227":"2639242b-fe38-4903-928c-7210ed328c68","228":"07e8c267-c713-40b9-abcd-aee74e3b5034","229":"4224ee6e-0762-44cf-95be-c5413babfaec","230":"68861643-18f0-40d7-a3f6-11879293e91c","231":"acf0a061-91f0-44dd-9ed8-8661fdf3c6aa","232":"9cae7cf5-79bd-4dc8-a2a4-f9f08c4b6e66","233":"89fe1f46-7606-4f44-be04-257f294c8a34","234":"f1dc8266-2011-4054-b7c8-ee5e01b718c8","235":"a9519fe5-2127-456c-b9bb-c210912320f1","236":"77273b48-5723-429b-9d11-f5b52239167c","237":"fa66a929-c183-49a6-ad1b-fb65f4cf9d1c","238":"62d48e3d-bdd0-4f38-8410-1853654f6462","239":"1197f36d-5f17-42c3-9a8a-6e04fb73072c","240":"92b2454c-bcc0-4dde-a65f-1791cdf6524b","241":"6cf708ae-4bd0-401e-815b-2b62b31cfe8b","242":"422dd42b-385f-4579-b9c6-1817d958662b","243":"61d2aeb7-c788-4266-b5a3-e1df5af46d00","244":"8ca53406-b32c-4721-8feb-9c2d6327d09a","245":"557f8cf1-fdfa-45cf-9cc6-256f35c19b6b","246":"d697f858-3553-4730-bbb8-e1f3ec125145","247":"904d1857-64db-42ff-9707-3ec41d683365","248":"1d6289b7-5381-40fa-8d95-7b9c5a80aa9f","249":"49337718-bdf7-41b5-9767-6413ac989495","250":"c467bd3d-0b98-4ec4-9f37-9520316ecda3","251":"749c3113-4556-45a6-b8d2-748089d7b68c","252":"01dd0c41-b6a3-41dc-ace5-7c0505d36b7f","253":"7660e41e-4442-458c-919b-0eaf457c8ac8","254":"333370c6-4d0f-4c0a-8a7b-79964408cb38","255":"350d9849-2401-4ee5-a883-3a6654f3ea97","256":"5c5bd7de-af43-493a-9383-b6aae40901d9","257":"6cb415f2-32ed-446a-82f9-6d60063a2181","258":"543aba35-f180-4836-a775-7565be75903b","259":"33dc17f3-88db-4b00-a6f7-9f3235ec0222","260":"40ea9310-2c29-4f86-8291-2f273de8548b","261":"b00bc8a8-00ad-4403-b0b6-c5d0e5067b2d","262":"d32c5895-ece9-4b5f-8b30-b0d4c3b81d33","263":"ac33b0cb-2ac9-45e0-b339-e44df80b4d94","264":"c69dae18-4182-4f49-b73d-a820b7a2cbde","265":"d2be3c38-a15c-4b3c-8d5b-a0009445c282","266":"dc0da0f0-3e33-4403-a167-ead45e6c7371","267":"3eeb2a62-7cc0-4761-b91c-bee5f9272798","268":"328886c4-d6bd-402f-b807-ba776f4cd892","269":"fc79642b-7159-48b9-a65a-0f748fef1053","270":"ad34f656-194a-474a-ab24-347ec2f0ecf8","271":"41d3eb42-c688-4371-b69b-04f3c270d402","272":"22322cb6-5e71-438b-8279-9b03bf9a0964","273":"7fe73108-ba08-475e-9961-ab7160e879d9","274":"b06d8e81-a0b0-49c6-bb0c-5c85b9a37df4","275":"60b8668a-41b5-434d-9a1a-e520cd0b6c75","276":"c0add16a-f465-41a1-ac7c-9f50a3b7c722","277":"381f4a51-32fa-479c-8efc-7d3e1bf9761f","278":"4ad84b0d-02b0-46a5-b78e-5530a8f0c128","279":"2fab9052-29bd-4c63-8185-310fe38695ff","280":"54795368-1b6b-4e7e-b4f6-119b8c42453c","281":"387a29dd-f86c-4a50-b639-eb5d86fa2748","282":"8d0d7bda-84f7-42f5-b51c-7bae92774ab7","283":"0fb899c2-70b0-46f6-89da-3e8c957cfc4b","284":"de3a5614-b469-468b-baf4-477afc755568","285":"2719b02d-95b2-4f3d-8b30-b1d7722efe01","286":"1fc1c0a4-a01d-4d4e-b070-ecdc364c6309","287":"bd79af06-7fba-4978-9230-70c64f23861e","288":"9968fefd-f4bc-4d97-b61a-d22cb624e4c1","289":"8334462f-24d6-4d0f-9174-cb2ad20957c8","290":"fd9cb0ab-ab99-440e-ad08-d8b0beaf1551","291":"97ea3772-e3d4-488d-ba0c-f7688b0884ad","292":"7f8b9e9a-7295-4019-8456-3525bdae07fd","293":"d9cacc3a-1ef9-4500-93da-7c5434b03a19","294":"b7371a42-e5fa-4d21-9442-eb3ae3f003eb","295":"b05e4e3c-6c2f-4991-87d8-5d7a9c2ca41d","296":"065330e8-8485-456f-8a06-d1fe9de91499","297":"45424361-9bb8-4fd1-b00e-61f08bf0825c","298":"76967e44-9feb-42ee-9173-748ec1320392","299":"3b6336b5-77f8-4a32-bb86-ebfe63075420","300":"2ece56e9-2257-4621-a502-1400d691189a","301":"6e633cb5-1250-4ebf-af57-0c9203383742","302":"61ccfbd7-f6e3-4cef-87cb-465cc3a62722","303":"09d7be8c-2d0d-4f7a-83fa-edf96775ec0b","304":"3e3484d5-bc84-46fa-a281-e18a223687eb","305":"084545c7-81c4-4cff-ab4f-3d774b211f41","306":"21add748-59fd-4323-9729-6626816cb4f9","307":"e6e52b8e-7a02-4c88-99b4-da1400741c86","308":"0603b48e-d982-4dd1-8ca0-18f7664e811d","309":"d13c8f67-c0c8-4110-b248-a623c53ed9da","310":"280bec7f-b383-450b-ad46-9a28f502baa5","311":"fc4335e9-c57f-4614-8985-7d72baae261c","312":"1e2a6d20-28fb-43b1-8966-e4e06e3fa9f1","313":"a852465a-7187-46ce-85da-410f8a541285","314":"f6588196-4e7b-4a35-aafd-67f5b59b8e41","315":"07df8c3b-6aad-46a8-9cb7-26682cfc52c3","316":"35ddf9d9-fd66-4664-9f76-72b03122f582","317":"c8daf015-5798-4294-9919-e92c3b9a3b10","318":"678a22dd-e973-4439-9bb0-97e47f48d506","319":"ed5c46d0-10ae-40ad-9f8c-0c44d15e352a","320":"1ae6a6f0-1ca9-4df3-a1ba-0be680c53fa9","321":"033c1613-4538-49c6-8ea1-11f637f9345b","322":"11cbb990-e0bd-49d4-8b75-c1e66ba7146e","323":"51ad6ab8-0cc0-492b-aa43-a7bdb7a91438","324":"5709eff0-81db-4dd1-974c-739ea899af63","325":"bc9c37df-58f2-4287-a2ea-6330c5aac2d7","326":"60528c67-a3d3-4a44-80b7-a3ba560d097c","327":"22ccdbba-5697-4ad8-afb3-0886486c51e3","328":"111eb825-76b3-458e-9859-1446c22ea6f6","329":"58aa560f-5674-4beb-a22c-bee6c93790af","330":"fc79ddac-5f33-4679-b34a-02b277932872","331":"c7ebcfca-3dd1-47b6-a24d-9b15d7f9466e","332":"31efe5ff-82cf-48cb-9a6c-a9b687b655b1","333":"945e0c66-1bab-427f-8bf7-4e0d649731c3","334":"9b3e6e56-5074-455d-bf2d-26d890d5c653","335":"b7f49035-4ccb-4a62-98cc-ac402f157ec3","336":"30c4b4c1-a578-4add-afd4-3fe3f79728c5","337":"aa74c91f-3148-44f5-abde-2791b633e4a7","338":"374bc3ae-874e-43ad-aeb3-0cefe089eb3c","339":"6d5ab896-f0a1-4c3e-9cc2-1c3fc5e005ae","340":"ba1e220b-6b59-4ea6-85e2-9eccb73ab34a","341":"53e547ec-d9da-4def-b917-707a496b0093","342":"ebfb20c2-4a60-4d69-b99f-cfccec6c17b3","343":"73cbae8e-952a-4ddc-b82d-2ca5d41deb5a","344":"ab5edd8d-e3c4-4cc5-be6b-9856761e803f","345":"2dd11539-2e4d-4182-9cdc-b95421bbb7f3","346":"25a6b405-0dcf-4f74-bfe0-cc11a6d767f3","347":"0834ebb3-f089-443f-b1e0-6fb63372094a","348":"a6a768c2-cbf5-430d-be5f-8f987be95520","349":"142605dd-8248-4433-889b-45c52408af3a","350":"db2b5157-3fa6-46cd-82a8-0acd83a21279","351":"2d913edf-2186-4f1a-85a7-71ed6e2b9f1e","352":"92a2f034-500a-4023-86c3-30b3eb996670","353":"04e7e51b-0365-421c-ba06-c06c8e558d60","354":"584a932f-5fd4-4952-a2dd-803e4fca3385","355":"1193c52e-d704-451e-92e8-879e63d7316f","356":"639185de-c71b-4d95-81a8-f2e51435f661","357":"3f154713-6a71-44aa-a15b-9112a76961eb","358":"c7433ffa-fff0-4bc8-b001-1ea77338456e","359":"6a2119db-8236-4808-b0ae-dd54ffca8609","360":"814080b4-e8fd-478b-8f63-d4c17983f2ec","361":"2a50b5da-249e-4166-ad5a-9234c398aa8e","362":"8dd393ca-fe09-4d28-b235-b13b98a9d2df","363":"a854f4d1-dcbb-4fe0-992f-54c67502892d","364":"400ffad3-9c65-4674-8716-35d129494dfa","365":"2fe2d8c9-508b-453b-85b6-16ec4c808fd1","366":"3ab533e7-a92f-4d4c-8eb4-cc1cdf5af44f","367":"e709c278-c700-447e-8d55-a4aafd691c2f","368":"b0b6b2a1-82b3-4089-9681-875224da94d2","369":"02b745cf-4110-400f-9a73-1c67936dbac2","370":"5d677a24-c591-4078-bffd-da53ddbdb3f6","371":"908b60de-a23b-400b-98e6-89e32bbfb363","372":"8632a3a8-b60f-4b2a-8ea0-6abe86131a5e","373":"5e2fa31c-7107-44d5-997e-7a287ee467aa","374":"7ebe5ef6-2cc0-4b4f-8b1b-c3a71ff5765c","375":"89d7137a-95da-40e6-9878-ee4ce4c880e3","376":"8a480eaf-6e4b-4408-96af-e01fb28f43d9","377":"eb41fbe9-3303-4ab8-bdc9-a6b63b0db080","378":"118148c5-d610-44e5-a9e7-09cca029b84e","379":"258e87d5-15db-4adf-8772-b6c7b009221c","380":"374788be-d97d-42d7-8d6c-5e6fb78e156d","381":"71271d30-d776-4dba-8d63-f1eb1f550bc7","382":"74ab59cd-bc86-4561-906d-2256c21f33e5","383":"61d20dd1-90e6-4341-96e8-c2f556854dce","384":"d5c20572-cc44-45f6-8442-4e052bcd610d","385":"af0072d1-108b-43d2-ad36-9628876996b2","386":"90fc7ffe-961c-445d-95db-2f3ebe22823e","387":"51ebe065-0989-4de9-a423-35a64ddc7a65","388":"721cd027-2573-4246-985b-dec7c60b55f0","389":"1f39ad7f-0f7d-4372-a558-a1e742418232","390":"73f87dea-0c47-4320-97d9-65b0602f1a61","391":"ccea75ee-04cb-4f69-9e2d-53b4f42f61ac","392":"28873592-7225-43bf-a3af-32843b3e7330","393":"054d7e6c-7c66-4f87-bc79-fe69a9522bf0","394":"81bf940b-a04a-4c34-9b77-7a46fae64113","395":"8694b39f-9270-42c8-a1d6-e9681c10b95d","396":"2591ae96-a167-4d51-b8f4-765ab23bfb28","397":"0d116321-915b-4326-acd5-5ff9a71733c9","398":"d8936497-8aa7-4eee-b31d-1101803e4de2","399":"54136e8f-281b-4d64-853a-cbca73256362","400":"ce122086-fe1c-4bfc-94e8-2ab62449f16c","401":"bd468eb2-e5bf-4ad0-81fc-56f065f0f95a","402":"79cd79cf-a422-482d-9c3c-00dec2179c70","403":"c1e6c5f7-39f7-4936-b302-05a6a4cf82b3","404":"cc78a879-a2e7-413f-9e54-c401e5856565","405":"6402a0cc-32b4-4874-b2f0-495caccddd5d","406":"e0668549-6664-4ede-8906-30f82c79092a","407":"30ba0951-4494-4aa8-aca7-1e7f16a50104","408":"b7e10d77-4a0e-4fc3-bcaa-fd7fbae3f3c6","409":"be935688-755e-491e-925f-9d9391860092","410":"4266c444-293f-48cc-878a-d7115978962e","411":"7f747625-d3c3-4735-8186-d7bd6d3942e8","412":"d3fea976-b5e1-4ed0-a27b-244042e45708","413":"237338c6-7c0d-4852-8ec2-6be10cfe0a1a","414":"a2a365ae-7769-4161-b85d-eadb262cbc14","415":"74e7b2df-0d01-4b43-86e1-4fe7b8bea201","416":"56367a5a-f5c1-4ba2-a778-3214358568fb","417":"0a610e01-dbc0-4275-9fb2-08b7b0fab86e","418":"389df41a-c40d-4d1f-a4cc-b147e56b601a","419":"ce0b484e-c807-4d6d-ac63-4546c97f91fa","420":"c2f12bbc-3937-4796-becc-b1a5cb8c7ce8","421":"56b2129e-82dd-4469-95a9-14695159bf2d","422":"4c0fa3c8-4400-4054-97bd-6ad30b529711","423":"5ab1b194-8287-4ef8-82f6-d7fc5d5f0559","424":"43249faf-42ad-405d-821f-fea3b5986d32","425":"4f0a2bef-b9e8-4b98-91d3-798d9d906509","426":"df9ee43d-0db3-42ea-a9a7-3b6b574ac47d","427":"eec802c3-ad95-4bc7-bf58-50770198da9a","428":"4592d18a-3796-4689-940d-bc65492dffd9","429":"33c35e92-0a8c-447e-83e0-15ecdb8e35a8","430":"f067a9ca-1a95-49ab-af91-0a7d9fe97760","431":"03ffea9c-30a6-41c6-8125-b41b0ffc084a","432":"7a36de54-5aed-4445-b401-91de46541e3d","433":"d2883bd2-8ea3-4831-9fcf-e9f23032b148","434":"598e9cc8-0bc5-47e3-9185-071c03235b10","435":"33ca053c-820a-4ede-bb5a-3e683693f6bb","436":"bb3b610e-137a-4a62-b433-73423a574fd9","437":"a733da7c-062d-418c-8d99-615687eebbd1","438":"00b7e58c-1742-4455-b033-3e82d44550ad","439":"401acf23-111a-41f9-a359-f5ca0476c9e8","440":"79de7ac1-377c-427a-be18-e181bc9b3814","441":"fc65d1d5-0592-453a-adc8-06c52ba844d7","442":"f7822a36-fc80-40e8-94a5-7ed744f5d769","443":"823c3f14-be26-419e-aa9b-a1ab9e2d18cb","444":"2955fb15-b9c3-42b7-9e95-f1cacecc9da9","445":"20e69900-7743-4f4f-94bc-aaca65d9c429","446":"eeb9878c-dddb-4e60-9535-e6a1cd9c70e8","447":"3b0e87dc-52ee-42b7-a51c-2db145bd91a8","448":"5fbffcce-731e-4a49-b6e0-523e5b30298f","449":"b09f1007-e18f-4bdf-9295-511b61af6dbd","450":"009881c5-0f28-43b8-89b4-69a6dd2c2a62","451":"5c8e9abd-fcfc-41a0-8a9e-fcb725514be4","452":"9bcb3f81-8302-4a68-ae99-1b61f3123490","453":"d9a2601c-0948-4208-8274-b9b5dd99d624","454":"79471f2e-6023-4f05-aed6-f8a19b6cf289","455":"b05006c2-c58d-4a5f-bfdd-e1c465b48798","456":"fa452bef-b92b-489c-8ed8-2b4bd4138ffb","457":"2794a2bd-8a8a-4b31-af10-62cdaf687b84","458":"6bf49613-3cf9-4b28-a96c-e1e7416ac545","459":"6982d878-4d72-4db4-bf30-3a88ee57c191","460":"c3899b7f-42f8-4607-8d6e-e30077f169c8","461":"7a3f06a3-e3bd-48d8-b303-db8c78ad6fe7","462":"1086a8ca-8ca0-4f0e-b9e4-a7c9242ba498","463":"f376e07a-d4d9-4ac2-bca3-fda7a5fc9ddc","464":"82a21250-ec59-44fa-aa1f-78a619361880","465":"4fb8a952-8126-48a2-a799-86838b615fe3","466":"70bcdd7a-a953-4c2e-ba0e-7ccde8a368e3","467":"68857d96-02bf-473a-845a-5725a7c64a9d","468":"39c65d52-0dcb-4eb6-8bba-47210228c8a6","469":"48e6bbb6-e4f7-4d88-856e-cdf95a397590","470":"1ebb4a96-fb0d-401c-a6cf-011f7c2e3100","471":"4ceb5576-0a54-49f8-9e02-b9fc84d8bfb0","472":"7cee21f2-9156-43fa-b688-aa88200a1546","473":"1bf66a1d-12b8-491d-a95d-5be0b43b3d0b","474":"3a5f38cb-8d8c-48c4-9964-953b3c08f1cf","475":"0c822be4-e8b1-4051-94dd-8e2d7ef97c0d","476":"104aacbe-5a4b-4d4e-9593-e775a3a1509b","477":"5fb6a5c9-c6d5-40d7-854f-5455db81c68c","478":"6edbb527-9d95-4361-bdbc-74c889d9f609","479":"7562b1db-771c-4ce2-9392-fbe970bfd418","480":"49d6aaba-4a54-45f7-a201-e1c5a7d6e2fd","481":"34dbe6c5-8a6b-4c2a-b9b0-0543d221fa44","482":"fdd58c59-3611-4bd3-9b61-f9785274cc32","483":"5815e2d9-43fc-42f9-a63e-f2fdc1e4700c","484":"2be24b3d-e28d-434e-aa07-d2308f185639","485":"97136796-d24f-467f-a80f-25f355f5d766","486":"d164192b-8682-4be8-b1ec-0ffca7fc9e81","487":"4121dbcb-9598-4df1-994a-8f547eccfaed","488":"bdfb82ac-492c-46b2-ad19-4ad4da5ff5cd","489":"75f06007-a8f1-4d5e-8bdb-51c4b684ae56","490":"1b2a405f-a709-4d12-b91b-e1a5c6c51275","491":"3dafe38b-b37e-4518-8adc-2408b89af0a8","492":"0bf156c6-7e41-4f27-bea9-e81f79f615e3","493":"ee0ac474-c3c5-40a1-989d-49d70c20d1ca","494":"3c13fb31-523e-41f9-b0de-06612688f886","495":"66c868c8-ce7f-425c-8394-5a09eef8c0f5","496":"c5f8ea39-fbd2-499f-8a68-445b95bf77fc","497":"dc4290d0-0058-4c40-90b0-5f75057479b2","498":"bd5a382f-07e3-46d8-89ec-3c46ee5d0914","499":"071dcd25-494a-4c36-9e2c-bb0c0b92b5cc","500":"81b6e32e-67a7-45b1-b7df-42473e300eef","501":"df5f4a1b-5730-48c9-92d2-b7b7379d4776","502":"04015e17-7dfa-4215-9f2f-7453e315fba3","503":"af0f0992-d302-4f94-92f4-37c1bef71128","504":"f0b4517f-fc1c-4173-bb08-f386feee29f4","505":"671162dc-295c-42c0-ace8-2195fb967222","506":"e1dee3e9-7d25-4251-b749-04aa1419e758","507":"c720abc9-f7f3-4996-b568-ccca63613c44","508":"d31ff0fa-4de5-4ac3-95c2-c92e14c182b7","509":"3eea7327-03a5-49ff-bcd5-607f7dc55957","510":"543018d3-9e71-4e91-9437-f680de70be64","511":"307e4d49-5e10-4655-a93b-8e9e362383f3","512":"50b2a829-2972-4420-bf9e-47ce84cd113f","513":"d8754676-0d6d-41cd-9ce6-09d608ba8e14","514":"c9a1aaea-a79d-4912-b6ca-897b073157ea","515":"8c0a830f-8e0b-4f82-ad7a-c58e9b92c8ba","516":"ccd02fa8-e77e-438a-a8f5-8d49a951eed8","517":"408b6066-1690-47da-9a82-b78ab8a1ba60","518":"e572abae-8aaa-4584-a042-44da70ccbbd4","519":"d14944bd-5d67-44a5-a976-42830aea95cb","520":"439d8c85-6487-49f8-8e5e-dda8ae55eb33","521":"18130d82-d946-4c47-a58c-68bc53eb9e29"}]